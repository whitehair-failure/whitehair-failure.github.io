[{"title":"CSS 学习笔记","url":"/2023/07/06/CSS/","content":"CSS介绍\n​    HTML主要用于描述网页的结构和内容\n\n​    CSS美化网页,给网页化妆\n\n​    所以需要先有HTML结构, 再写CSS样式\n\n​    CSS 的全称是 Cascading Style Sheet（层叠样式表），它主要用来控制网页的样式（美化网页）。CSS 早已被所有主流浏览器采用，它允许你轻松控制以下样式：\n\n颜色 color\n\n背景 background\n\n字体 font\n\n浮动 float\n\n位置 position\n\n显示 display\n\n边框 border\n\n内边距 padding\n\n外边距 margin\n\n行高 line-height\n\n装饰 text-decoration\n\n过渡 transtion\n\n变化 transform\n\n动画 animation\n\n\n页面样式的属性有几百个，但常用的不过几十个\n\nCSS需要学习两大内容(CSS选择器, CSS属性)\n\nCSS选择器用于选择目标标签使用,一个网页可以有很多很多标签,给某个或者某些标签设置样式,就需要用到选择器\n\nCSS属性就是用什么工具化妆\n\n\nCSS的书写位置\n嵌入式也可以叫内嵌式, 就是把css代码写style标签中\nstyle标签也属于HTML标签,所以style可以出现在网页的任何地方,出现任意次, 建议style标签写在head标签中\n嵌入式仅能控制当前页面的样式\n\n&lt;style&gt;       div &#123;           color: red;           background: skyblue;       &#125;       p &#123;           color: orange;           background: lightgreen;       &#125;&lt;/style&gt;\n\n\n外链式可以控制多个页面的样式\n外链式的意思就是把css样式写在一个单独的css文件中通过link标签引入css文件样式表带当前页面中\n\n\n&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件所在路径&quot;&gt;\n\n\n行内式通过HTML标签的全局属性style设置的, 仅能控制当前标签的样式 行内式在JS中使用的比较多\n\n&lt;p style=&quot;color:red;&quot;&gt;pppppppppp&lt;/p&gt;\n\n\n输入样式表（不常用）\n将一个css文件，通过 @import关键字导入到另外一个css中。\n\n\n&lt;!-- 通过style标签中,使用@import关键字引入外链式css文件 --&gt;&lt;style&gt;    /* 注意: @import引入的时候要写在前面 */    @import url(./css/01.css);    h2 &#123;        border: 5px solid blue;    &#125;&lt;/style&gt;\n\nCSS三大特性\n层叠性, 同一个元素被同一个选择器选中, 设置CSS属性,如果CSS属性是相同的,那么后面设置的属性值会覆盖前面设置的属性值; 如果是不同的CSS属性,那么会叠加生效\n\n继承性, 某些CSS样式,是可以被继承的, text-开头, font-开头, line-开头以及color属性 子承父业  如果子元素有自己的属性,那么将使用自己的属性值 不继承父元素的属性;\n\n优先级,  不同的选择器,选中同一个元素, 优先级高选择器设置的样式会覆盖优先级低的\n\n基本选择器的优先级\n\n继承的 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; style行内式\n!important在CSS中的作用, 它主要是用来提升属性的权重(简单理解就是优先级)。其属性的权重值无穷大！\n\n!important语法格式\ncss属性:css属性值 !important;\n使用!important一定要注意以下几点\n\n!important它是提升的属性的权重，而不是提升选择器的优先级！\n!important它只能提升作用于自己身上的属性，并不能提升继承过来属性的权重！\n\n\n\n\n复合选择器我们不叫优先级了,我们称之为权重\n\n复合选择器的权重计算： (0 0 0 0)\n从左到右：\n第一个0表示!important的个数\n第二个0表示id选择器的个数\n第三个0表示类选择器或伪类的个数\n第四个0表示标签选择器的个数\n\n比较方法：从左往右：如果第一个0大，表示这个选择器的权重高，那么使用这个选择器的样式，后面不用比较，如果第一个0相等，那么继续比较第二个0，如果第二个0大，那么就是这个选择器的权重高，使用他的样式，如果相等，继续往下比较，依次类推\n如果优先级相同,那么则考虑层叠性\n\n\n\n\n\n\nCSS三大模块\n“盒子模型(内容width,height+边框border+内填充padding+外边距margin)”\n所谓盒子模型: 就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的”内容(width,height)”、”内边距(padding)”、”边框(border)”和”外边距(margin)”组成。\n\n“浮动(float)” \n\n“定位(position)”\n\n\n其余的都是细节。要求这三部分，无论如何也要学的非常精通。\nCSS基本选择器/* 标签选择器,选择所有相同标签名的标签, 选择器名就是标签名 */      p &#123;          color: red;      &#125;      /* 类选择器,选择具有这个类名的单个或者多个标签, 选择器名是 .class属性值 */      .one &#123;          background-color: skyblue;      &#125;      /* 多类名选择器, 一个标签的class属性值可以设置多个类名,没给类名可以使用&quot;空格&quot;隔开  */      .two &#123;          border: 5px solid orange;      &#125;      /* id选择器, 选择具有这个id属性值的标签, id属性值需要唯一, 选择器名 #id属性值 */      #three &#123;          color: green;      &#125;/* 通配符选择器 选择页面所有标签, 选择器名是* */      * &#123;          border: 5px solid blue;      &#125;\n\n类和id的命名规则​    1. 可以有数字、字母、下划线_、短横线-​   \n​    2.不能以数字开头   \n​    3.不能使用单个短横线   \n​    4.不能使用短横线+数字开头  \n\n建议:   \n​    1.命名建议使用有意义的名字;\n​    2.尽量使用驼峰命名法。    \n\n当有多个单词组成的一个词的时候，第一个单词的首字母小写，后面每个单词的首字母大写  如：userName  userPwd  heightSchoolStudent\n\n\n颜色取值方式&lt;style&gt;    .div1 &#123;        /* 颜色取值方式一: 英文颜色单词 */        color: red;        /* color: pink; */    &#125;    .div2 &#123;        /* 颜色取值方式二: rgb(0~255,0~255,0~255) */        /* color: rgb(255, 255, 255); */        /* color: rgb(0, 0, 0); */        color: rgb(255, 0, 0);    &#125;    .div3 &#123;        /* 颜色取值方式三: rgba(0~255,0~255,0~255, 0~1) */        /* 最后一个a表示alpha透明度的意思, 取值0表示完全透明, 取值1表示完全不透明度 */        /* color: rgba(255, 0, 0, 1); */        /* color: rgba(255, 0, 0, 0); */        /* color: rgba(255, 0, 0, 0.5); */        /* color: rgba(255, 0, 0, 0.22); */        /* 在CSS中,如果取值是小数的时候,可以省略0 */        color: rgba(255, 0, 0, .22);    &#125;    .div4 &#123;        /* 颜色取值方式四: #+六位或者三位0~9a到f之间的组成的字符 */        /* color: #ff0000; */        /* color: #f00; */        /* color: #00ff00; */        /* color: #0f0; */        color: #a6e22e;    &#125;&lt;/style&gt;\n\n尺寸属性\ncss的width属性设置元素的宽度,取值 数值+css单位 或者 百分比\ncss的height属性设置元素的高度, 取值 数值+css单位 或者 百分比\n百分比一半是相对父元素而言\ncss单位最常见的px(像素), em, rem, vw,vh等\n\n文本相关属性\n❤color ( 文本颜色 ) 取值颜色值 英文颜色单词, rgb, rgba, 十六进制 \n\n❤text-align ( 文本水平对齐方式 ) 取值 left center right \n\n❤line-height (行高) 设置行与行之间垂直的间隔距离 取值数字不带单位(几倍行高),  也可以数值带单位\n设置行高, 不带单位,表示多少倍行高 \nline-height: 1;line-height: 2;line-height: 3;\n\n❤text-indent ( 首行缩进文本 )\n\n❤text-decoration ( 文本装饰线 ) 取值: \n\n❤underline下划线 \n\n❤none没有线,去掉修饰线 \n\noverline上划线 \n\nline-through删除线\n\n\n\nword-spacing ( 单词的间距 )\n\nletter-spacing ( 字母或者字符的间距)\n\ntext-transform ( 文本转换 , 转成英文字母的大小写) \n取值: \n\nuppercase转成大写字母\n\nlowercase转成小写字母\n\ncapitalize首字母大写\n\n\n\ntext-indent（设置首行缩进）\n\n\n/* 设置首行缩进 */text-indent: 32px;/* text-indent: 48px; *//* text-indent: 60px; *//* css单位em   1em就等于当前1个字体大小 */text-indent: 2em;\n\n将文本溢出的部分以省略号替代\n单行文字出现省略号\n\n&lt;style&gt;    * &#123;        margin: 0;        padding: 0;    &#125;    .div1 &#123;        background: pink;        width: 150px;        /* 强制代码一行显示 */        white-space: nowrap;        /* 溢出部分内容隐藏 */        overflow: hidden;        /* 溢出部分内容使用省略号代码 */        text-overflow: ellipsis;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;h2&gt;❤单行文字出现省略号&lt;/h2&gt;    &lt;div class=&quot;div1&quot;&gt;Skechers斯凯奇男鞋运动鞋旗舰店秋冬季缓震健步鞋休闲透气网面跑步鞋220035 【时尚款】全黑 42&lt;/div&gt;&lt;/body&gt;\n\n\n多行文字出现省略号\n\n&lt;style&gt;    .div2 &#123;        background: pink;        width: 150px;        /* 溢出隐藏 */        overflow: hidden;        /* 纯英文换行 */        word-break: break-all;        display: -webkit-box;        -webkit-box-orient: vertical;        /* 这里是超出几行省略 */        -webkit-line-clamp: 3;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;h2&gt;多行文字出现省略号&lt;/h2&gt;    &lt;div class=&quot;div2&quot;&gt;Skechers斯凯奇男鞋运动鞋旗舰店秋冬季缓震健步鞋休闲透气网面跑步鞋220035 【时尚款】全黑 42&lt;/div&gt;&lt;/body&gt;\n\n 06-将文本溢出的部分以省略号替代.html \nfont字体属性\nfont-size设置字体大小,默认谷歌浏览器的字体大小是”16px”\n建议字体大小使用”偶数”,因为偶数兼容性比较好\nfont-size: 16px;font-size: 30px;font-size: 40px;\n\nfont-weight设置字体是否加粗, 取值 bold加粗,也可以用700表示 normal不加粗,也可以400表示;\nfont-weight: bold;font-weight: 700;\n\nfont-style设置字体是否倾斜, 取值 italic斜体 , normal不倾斜\nfont-style: italic;\n\nfont-family设置字体名称; 取值字体名称, 默认是微软雅黑\nfont-family: &quot;宋体&quot;;font-family: &quot;SimSun&quot;;font-family: &quot;\\5B8B\\4F53&quot;;\n\n注：可以同时设置多个字体, 从左到右依次匹配,谁能用就用谁 如果都不能使用,将使用浏览器默认字体\nfont-family: “宋体”, “楷体”, “黑体”;\n\n\nfont简写属性\nfont简写属性,是可以使用font属性可以所有跟字体相关的属性以及行高\n\nfont简写属性,一定要设置字体大小和字体名称,并且顺序不能调换\nfont: 36px &quot;宋体&quot;;\n\n其他font-weight,font-style需要放在前面, 并且font-weight,font-style的取值可以互换位置\nfont: bold italic 36px &quot;宋体&quot;;font: italic bold 36px &quot;宋体&quot;; \n\n在字体大小通过&#x2F;后面设置的就是行高的值\nfont: italic bold 36px/200px &quot;宋体&quot;;font: bold italic 36px/200px &quot;宋体&quot;;\n\nCSS复合选择器(派生选择器)  复合选择器是由”两个”或”多个基础选择器”，通过”不同的方式”组合而成的,目的是为了可以选择更准确更精细的目标元素标签。\n后代选择器\n后代选择器就是选中子孙后代(需要标签是嵌套关系)\n选择器1 选择器2 选择器3…{\n​    }\n\n\n子元素选择器\n子元素选择器只能选中子代(只能找到亲儿子,不能孙子后代)\n选择器1 &gt; 选择器2 &gt; 选择器3…{\n​    }\n\n\n兄弟选择器\n兄弟选择器需要标签是同级关系(兄弟关系)\n选择器1 + 选择器2 + 选择器3 …{\n​    }\n\n\n并集选择器\n并集选择器也可以叫分组选择器,意思就是把多个选择器放在同一组,他们具有相同样式,分组选择器一般用于提取公共样式\n选择器1, 选择器2, 选择器3…{\n   }\n\n\n交集选择器\n交集选择器，是p标签而且这个p标签又具有.one类名, 同时成立\np.one &#123;    background-color: orange;&#125;\n\nCSS3同胞选择器同胞选择器（E~F），用于选”择某元素后面”的”所有同胞元素”。也就是说，”E和F是同辈元素”，且”F在E元素的后面”，它们之间可以有，也可以没有其他同胞元素。\n同胞元素其实就是兄弟元素 \n09-CSS3同胞选择器.html \nCSS3属性选择器CSS 属性选择器通过已经存在的属性名或属性值匹配元素。\n\nCSS属性选择器参考文档: https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors\n\nattr&#x3D;&gt;attribute属性的意思value就是属性值的意思\n\n第一部分语法:\n\n[attr] 表示带有以 attr 命名的属性的元素。\n\n❤[attr&#x3D;”value”] 表示带有以 attr 命名的属性，且属性值为 value 的元素。\n\n[attr^&#x3D;”value”] 表示带有以 attr 命名的属性，且属性值是以 value开头的元素。\n\n[attr$&#x3D;”value”] 表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。\n\n[attr*&#x3D;”value”] 表示带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素。\n/* 是p标签并且要具有title属性 */p[title] &#123;    border: 2px solid blue;&#125;/* 是p标签并且要具有title属性,而且属性值要为&quot;c&quot; */p[title=&quot;c&quot;] &#123;    font-size: 30px;&#125;/* 是p标签并且要具有title属性,而且属性值要以a开头 */p[title^=&quot;a&quot;] &#123;    background-color: orange;&#125;/* 是p标签并且要具有title属性,而且属性值要以c结尾 */p[title$=&quot;c&quot;] &#123;    font-style: italic;&#125;/* 是p标签并且要具有title属性,而且属性值含有b */p[title*=&quot;b&quot;] &#123;    font-weight: bold;&#125;\n\n\n第二部分语法:\n[attr~&#x3D;”value”] 表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。\n[attr|&#x3D;”value”] 表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀。\nspan[class~=&quot;one&quot;] &#123;    color: red;&#125;span[class|=&quot;user&quot;] &#123;    background-color: skyblue;&#125;input[type=&quot;password&quot;] &#123;    background-color: lightgreen;&#125;\n\n 10-CSS3属性选择器.html \n伪选择器\n概念：在 CSS 中允许使用伪类来添加一些选择器的特殊效果。\n\n语法：CSS选择器:伪类 {CSS属性: CSS属性值;}\n\n什么是伪类选择器？\n伪类选择器:给页面上的元素设置样式，必须满足一定的条件，我们的伪类选择器设置的样式才会显示。\n\n\ndiv:hover &#123;    width: 300px;    background: skyblue;&#125;\n\n链接伪类选择器(锚伪类)通过超级链接的不同状态，对其设置不同的样式！\n\n:link 未访问的状态 超级链接没有被访问\n:visited 访问过后状态 超级链接已经被访问\n:hover 鼠标放上状态 鼠标放在超级链接上面，但是并没有将鼠标的左键按下去\n:active 激活状态 鼠标左键已经按下去了，但是并没有将鼠标的左键弹出\n\n伪类选择器都是带有冒号“:”\n\n链接伪类选择器有4个状态,书写的时候,有顺序要求, 爱很准则(先有爱(love) 后面恨(hate) )\n\na:link &#123;    color: black;&#125;a:visited &#123;    color: green;&#125;a:hover &#123;    color: orange;&#125;a:active &#123;    color: blue;&#125;\n\nhover伪类选择器:link和:visited只对a标签有效,:hover和:active对任何都有效\n重点记住:hover\n:hover鼠标移上元素以后的样式\ndiv &#123;    width: 100px;    height: 100px;    background: pink;&#125;div:link &#123;    background: red;&#125;div:visited &#123;    background: green;&#125;div:hover &#123;    background: purple;&#125;div:active &#123;    background: orange;&#125;p &#123;    width: 120px;    height: 120px;    background: skyblue;&#125;p:hover &#123;    width: 300px;&#125;p:active &#123;    height: 400px;&#125;\n\n 16-hover伪类选择器.html \n表单伪类:focus 获取焦点以后的样式\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        input:focus &#123;            background-color: pink;        &#125;        textarea:focus &#123;            color: red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; /&gt;    &lt;textarea&gt;123abc456789&lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt;\n\n 17-表单伪类.html \nCSS3结构伪类选择器以下的E表示element元素的意思\nE:first-child 匹配父元素中的第一个子元素E\n.box div:first-child &#123;        border: 3px solid blue;    &#125;\n\nE:last-child 匹配父元素中最后一个子元素E\n.box div:last-child &#123;        background-color: orange;    &#125;\n\nE:nth-child(n) 匹配父元素中的第n个子元素E(常用)\n.box div:nth-child(2) &#123;        font-size: 30px;    &#125;\n\n\n结构伪类选择器就是选择第n个\nnth-child从所有子级开始算的，可以不是同一种类型标签\nn可以是数字，关键字和公式\nn如果是数字，就是选择第n个\n常见的关键词 even 偶数 odd 奇数\n但是 第0个元素或者超出了元素的个数会被忽略 )\n常见的公式如下 ( 如果n是公式，则从0开始计算）公式 取值2n 偶数2n+1 奇数5n 5的倍数  5 10 15 …n+5 从第5个开始（包含第五个）到最后-n+5 前5个（包含第5个）…\n\n/* 使用关键字 odd表示奇数 even表示偶数 */ul li:nth-child(odd) &#123;    background-color: pink;&#125;ul li:nth-child(even) &#123;    background-color: skyblue;&#125;/* 如果n是公式，则从0开始计算 *//* 2n就是的2的倍数 */ul li:nth-child(2n) &#123;    background-color: lightgreen;&#125;/* 3n就是的3的倍数 */ul li:nth-child(3n) &#123;    background-color: lightgreen;&#125;/* 从第5个元素开始,包括第5个 */ul li:nth-child(n + 5) &#123;    background-color: lightgreen;&#125;/* 找到前4个元素,包括第4个 */ul li:nth-child(-n + 4) &#123;    background-color: lightgreen;&#125;\n\n 18-CSS3结构伪类选择器.html \nnth-of-type选择器\n使用:first-child, :last-child以及:nth-child需要看HTMML结构所在位置\n:nth-of-type(n)可以直接指定类型E的第n个\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        /* E:first-of-type 指定类型E的第一个 */        .box div:first-of-type &#123;            color: red;        &#125;        /* E:last-of-type 指定类型E的最后一个 */        .box div:last-of-type &#123;            color: blue;        &#125;        /* E:nth-of-type(n) 指定类型E的第n个 */        .box div:nth-of-type(3) &#123;            color: orange;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;span&gt;span&lt;/span&gt;        &lt;span&gt;span&lt;/span&gt;        &lt;div&gt;div1&lt;/div&gt;        &lt;div&gt;div2&lt;/div&gt;        &lt;span&gt;span&lt;/span&gt;        &lt;span&gt;span&lt;/span&gt;        &lt;div&gt;div3&lt;/div&gt;        &lt;div&gt;div4&lt;/div&gt;        &lt;div&gt;div5&lt;/div&gt;        &lt;span&gt;span&lt;/span&gt;        &lt;span&gt;span&lt;/span&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n列表样式属性列表样式属性主要给无序列表和有序列表使用列表样式属性可以给ul,ol,li这三个标签设置都可以\n\n列表样式类型 list-style-type取值disc实心圆(默认值) square正方形 circle空心圆  none没有列表项目符号\n\n/* list-style-type: disc; *//* list-style-type: square; */list-style-type: circle;/* list-style-type: none; */\n\n\n列表项目符号出现的位置 取值 inside里面 outside外面(默认值)\n\nlist-style-position: inside;/* list-style-position: outside; */\n\n\n使用图片替换列表项目符号 取值 url(图片所在路径)\n\n/* list-style-image: url(./images/cc_cat.png); *//* list-style-image: url(./images/3.jpg); */list-style-image: url(./images/li01.jpg);\n\n\nlist-style简写属性,可以设置列表相关样式, 多个属性值之间使用空格隔开, 没有顺序要求 也可以省略某个或者某些属性值\n\n/* list-style: circle; *//* list-style: inside; *//* list-style: url(./images/sina.png); */list-style: inside circle url(./images/sina.png);\n\n\n一般我们在使用列表项目符号样式的时候,都是去掉列表项目符号\n\n所以,大家只需要记 list-style-type:none; 或者 list-style:none;\n\n\n元素的显示方式定义:HTML标签默认情况下在展示的时候会出现一些独占一行，或者多个HTML标签都在一行上显示的现象，因此我们根据元素的显示方式不同,将元素分为”块级元素”,”行内元素”,”行内块元素”。\n元素显示方式的分类\n块级元素：多个同名元素默认情况都会独占一行，且宽高属性可以起作用,宽度默认是父元素的100%\n块级元素显示方式：  display:block;\n特点：\n​    1.独占一行\n​    2.能够设置有效宽高\n​    3.宽度默认是父元素的100%\n常见块级元素：\ndiv h1 h2 h3 h4 h5 h6 p ul li ol…\n\n行内元素：多个同名元素默认情况下会在一行显示，且宽高属性不起作用,默认宽度由内容决定。\n行内元素的显示方式： display:inline\n特点：\n​    1.一行可以显示多个\n​    2.默认宽度就是它本身内容的宽度，不能设置有效宽高\n常见的行内元素：\nspan i s del b strong em ins a…\n\n行内块级元素：多个元素默认会显示在一行，且宽高属性起作用。\n行内块级元素：  display： inline-block;\n特点：\n​    1.一行显示多个\n​    2.能设置有效宽高\n​    3.默认宽度就是它本身内容的宽度 \n常见的行内块级元素： \n  input  img  textarea\n\n通过display属性可以改变元素的显示方式, 改变成什么元素,就具有什么元素的特点\n\ndisplay:block; 转换成块级元素\n\ndisplay:inline; 转换成行内元素\n\ndisplay:inline-block; 转换成行内块元素\n\n\n\n\nCSS背景属性\n\n\n背景属性\n描述\n\n\n\nbackground-color\n设置元素的背景颜色\n\n\nbackground-image\n设置元素的背景图像\n\n\nbackground-repeat\n控制背景图像是否重复\n\n\nbackground-attachment\n控制背景图像是否跟随窗口滚动\n\n\nbackground-position\n控制背景图像在元素中的位置\n\n\nbackground-size\n设置背景图像的尺寸\n\n\nbackground-origin\n设置 background-position 属性相对于什么位置来定位背景图像\n\n\nbackground-clip\n设置背景图像的显示区域\n\n\nbackground\n背景属性的缩写，可以在一个声明中设置所有的背景属性\n\n\n\n参考文档:CSS background（背景） (biancheng.net)\n\nCSS精灵图雪碧图（CSS Sprite）又叫CSS精灵图，是一种网页图片应用处理方式，他允许你将一个页面设计到 所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，由从前的多次请求变为一次请求，客户端显示一张图片都会向服务器发送请求，所以图片请求越多，造成延迟的可能性就越大，当页面有许多字体图标时，推荐使用CSS Sprite 。\n.div1 &#123;    background-image: url(./images/biaoqing.png);    background-repeat: no-repeat;    /* 如果想要取出雪碧图中某个小图片,我们就需要使用背景定位技术 */    /* 1. 把目标小图片,通过背景定位,移动到元素的&quot;左上角&quot; */    background-position: -351px -43px;    /* 2. &quot;改变宽度高度&quot;,让元素的宽度高度仅能显示这个小图片 */    width: 80px;    height: 88px;&#125;/* 通过这个网站可以帮助我们实现背景定位 *//* http://www.spritecow.com/ */.div2 &#123;    background: url(./images/index.png) no-repeat -137px -35px;    width: 25px;    height: 27px;&#125;\n\n 27-背景定位应用-精灵图(雪碧图).html \n伪元素选择器\n伪类选择器:给页面上的元素设置样式，”必须满足一定的条件”，我们的伪类选择器设置的样式才会显示。\n比如,  :hover 鼠标悬停在元素上面的以后,才会触发的样式\n\n伪元素选择器: 伪元素顾名思义,就是假的元素,不是真正HTML元素; 在 CSS 中允许使用伪元素来添加一些选择器的特殊效果\n伪元素选择器有很多,但是常用的就几个\n\nE::first-letter 文本的第一个字母或字(如中文、日文、韩文等）\n\nE::first-line   文本第一行\n\nE::selection  选中文本以后的样式 \n注意: “first-letter” 伪元素只能用于”块级元素”。这个伪元素用于指定一个元素第一个字母的样式。所有前导标点符号应当与第一个字母一同应用该样式。注意: “first-line” 伪元素只能用于”块级元素”。注意: E::selection只可以应用于少数的CSS属性:   color, background,text-shadow文字阴影\n\n\n\n\np::first-letter &#123;    font-size: 50px;    color: red;&#125;p::first-line &#123;    font-weight: bold;    font-style: italic;&#125;p::selection &#123;    background: pink;    color: blue;    text-shadow: 2px 2px 1px green;&#125;\n\n 01-伪元素选择器.html \nbefore伪元素和after伪元素\nE::before伪元素在标签内容之”前”添加一个”行内元素”,通过content属性设置行内元素的标签内容, “content属性不能省略”\nE::after伪元素在标签内容之”后”添加一个”行内元素”,通过content属性设置行内元素的标签内容, “content属性不能省略”\n\nli::before &#123;    content: &quot;★&quot;;    /* content: &quot;&quot;; */    font-size: 30px;    color: yellow;    background: skyblue;    width: 100px;    height: 50px;    display: inline-block;    text-align: center;    line-height: 50px;&#125;li::after &#123;    content: &quot;❤&quot;;    color: red;&#125;\n\n 02-before伪元素和after伪元素.html \n换行问题\n通过.div1~.div5现象观察,我们可以得到结论,默认纯字母或者纯数字,是不会自动换行的;\n只有中文内容才会自动换行; 但是可以通过设置word-break: break-all;属性实现英文和数字自动换行\n\n05-换行问题.html \noverflow属性\n**概念：**CSS属性 overflow 定义当一个元素的”内容太大”而无法适应 块级格式化上下文 时候该做什么。\n\noverflow: visible | hidden | scroll | auto | inherit;\n\nvisible (默认)：内容不会被修剪，会呈现在元素框之外 \n❤❤hidden：内容会被修剪，并且其余内容不可见\nscroll：内容会被修剪，浏览器会显示滚动条以便查看其余内容 \n❤auto：由浏览器定夺，如果内容被修剪，就会显示滚动条\ninherit： 规定从父元素继承overflow属性的值\n\n\n\n 06-overflow属性.html \nborder边框\n边框属性语法\nborder: border-width border-style border-color;\nborder: 边框粗细 边框样式 边框颜色;\n边框粗细取值是数值带px单位\n边框样式取值 ❤solid实线 ❤dashed虚线 ❤none没有线 double(双实线) dotted(点状线) \n边框颜色取值就是颜色值\nborder设置的是四个方向(上下左右)的边框线\n\n\n\nborder: 10px solid blue;\n\n\n设置不同方向的边框\nborder-top: 边框粗细 边框样式 边框颜色;\nborder-bottom: 边框粗细 边框样式 边框颜色;\nborder-left: 边框粗细 边框样式 边框颜色;\nborder-right: 边框粗细 边框样式 边框颜色;\n\n\n\nborder-top: 10px solid red;border-bottom: 5px dashed green;border-left: 10px dotted orange;border-right: 20px double purple;\n\n边框应用-制作三角形transparent是透明色\ndiv &#123;    width: 0px;    height: 0px;    border: 20px solid transparent;    border-left-color: green;    border-top-color: green;&#125;\n\n 09-边框应用-制作三角形.html \n圆角边框(CSS3)border-radius: 数值带px单位或者百分比;\n❤设置border-radius:50%可以让一个正方形变成圆形\n10-圆角边框(CSS3).html \n轮廓属性outline\n轮廓属性outline,也称之为外轮廓线,外边框线\n\noutline语法跟border的语法几乎一样\noutline: 2px solid red;\n\n去掉input标签的外轮廓线\ninput &#123;/* outline: none; */outline: 0;&#125;\n\n内填充(padding)内填充指的是 从”内容到边框”的距离\n\npadding的取值是数值带px单位,只能正值,不允许负值\n\npadding:1个值\n\npadding:2个值\npadding: 上下 左右\n\npadding:3个值\npadding: 上 左右 下\n\npadding:4个值\n padding: 上 右 下 左\n\n\n\n设置某个方向的内填充\n\npadding-top上填充\npadding-bottom下填充\npadding-left左填充\npadding-right右填充\n\n\n注意: padding和border会撑开盒子宽度跟高度 但是padding只能影响内容,不影响背景图片\n\n默认盒子真实宽度 &#x3D;  宽度 + 左右边框 + 左右内填充\n默认盒子真实高度 &#x3D;  高度 + 上下边框 + 上下内填充\n\n\n\n外边距(margin)margin外边距, 是盒子与盒子之间的距离 是边框外面的距离\nmargin的用法跟padding类似\n\nmargin的取值可以写数值带px单位, 允许”负值”\nmargin的取值还可以写一个auto关键字, auto表示自动的意思\n\n设置某个方向的内填充\n\nmargin-top上外边距\nmargin-right右外边距\nmargin-bottom下外边距\nmargin-left左外边距\n\n\n\nmargin实现盒子水平居中\nauto表示自动分配剩余空间\n\n/* margin-left: auto;表示把所有剩余空间都给左边 */margin-left: auto;/* margin-right: auto;表示把所有剩余空间都给右边 */margin-right: auto;\n\n\nmargin实现盒子水平居中(重点,常用,必须得掌握)\nxxxxxxxxxx     &#x2F;&#x2F; 与v-for同级的ref 返回值都是列表渲染出来当前元素数组集合            &#x2F;&#x2F;v-for 内部的ref 返回值也是列表渲染出来当前元素数组集合        -span        没用的a                &lt;button @click&#x3D;”showRefList”&gt;click​    new Vue({        el: &#39;#app&#39;,        data: {            arr: [1, 2, 3, 4, 5]        },        methods: {            showRefList() {​                console.log(this.$refs.numList,                            this.$refs.spanList)                // [p,p,p,p,p] , [span,span,span,span,span]              }        }    })html\n\n必须是块级元素。\n盒子必须指定了小于父元素100%的宽度(width)\n然后就给左右的外边距都设置为auto，就可使块级元素水平居中。\n\n\n\n.box &#123;    background: skyblue;    width: 300px;    height: 50px;    /* 让元素内容水平居中 */    text-align: center;    /* 实现单行文字垂直居中 */    line-height: 50px;    margin: 0 auto;    margin: 100px auto;    margin: auto;&#125;\n\n 19-margin实现盒子水平居中(重点,常用,必须得掌握).html \n清除元素的默认内外边距使用通配符选择器\n* &#123;    margin: 0;    padding: 0;&#125;\n\nmargin外边距合并现象\n相邻(兄弟关系)块元素垂直外边距的合并\n当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并(也称外边距塌陷)。\n\n解决方法: 不要同时设置两个盒子 只需要设置其中一个即可\n\n\n 17-margin外边距合并现象-情况1.html \n\n嵌套(父子关系)块元素垂直外边距的合并\n对于两个嵌套关系的块元素，如果父元素没有上内填充及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。\n\n解决方法\n方法1: 不给子元素设置margin-top, 给父元素设置padding-top, 注意高度要减去多余的\n方法2: 给父元素设置1px上边框或者内填充即可\n方法3: 给父元素设置overflow:hidden\n\n\n 18-margin外边距合并现象-情况2.html \n\n嵌套块(父子关系)元素给”子元素设置上外边距”出现整体塌陷(掉下来)现象\n\n解决方法\n方法1: 不给子元素设置margin-top, 给父元素设置padding-top, 注意高度要减去多余的\n方法2: 给父元素设置1px上边框或者内填充即可\n方法3: 给父元素设置overflow:hidden\n\n\n 19-margin外边距合并现象-情况3.html \n居中&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;style&gt;            * &#123;                margin: 0;                padding: 0;            &#125;            .box1 &#123;                width: 300px;                height: 100px;                background: skyblue;                text-align: center;            &#125;            .box2 &#123;                width: 300px;                height: 100px;                background: pink;                margin-left: auto;                margin-right: auto;            &#125;            .box3 &#123;                width: 600px;                height: 400px;                background: lightgreen;                text-align: center;            &#125;            .box4 &#123;                /* width: 600px; */                width: 411px;                height: 400px;                background: tomato;                padding-left: 189px;            &#125;            .box5 &#123;                width: 600px;                height: 400px;                background: aqua;            &#125;            .box5 img &#123;                margin-left: 189px;            &#125;            .box6 &#123;                width: 600px;                height: 400px;                background: chocolate url(./images/3.jpg) no-repeat center top;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h2&gt;文字水平居中 text-align:center&lt;/h2&gt;        &lt;div class=&quot;box1&quot;&gt;内容&lt;/div&gt;        &lt;h2&gt;盒子水平居中 设置已有宽度的块级元素的左右margin为auto&lt;/h2&gt;        &lt;div class=&quot;box2&quot;&gt;内容&lt;/div&gt;        &lt;h2&gt;图片水平居中 设置父元素的text-align:center&lt;/h2&gt;        &lt;div class=&quot;box3&quot;&gt;            &lt;img src=&quot;./images/3.jpg&quot;&gt;        &lt;/div&gt;        &lt;h2&gt;图片水平居中 设置父元素的padding-left&lt;/h2&gt;        &lt;div class=&quot;box4&quot;&gt;            &lt;img src=&quot;./images/3.jpg&quot;&gt;        &lt;/div&gt;        &lt;h2&gt;图片水平居中 设置子元素的margin-left&lt;/h2&gt;        &lt;div class=&quot;box5&quot;&gt;            &lt;img src=&quot;./images/3.jpg&quot;&gt;        &lt;/div&gt;        &lt;h2&gt;背景图片水平居中 使用背景定位属性background-position&lt;/h2&gt;        &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;\n\n 21-文字水平居中,盒子水平居中,图片水平居中,背景图片水平居中.html \n浮动（float)\n标准文档流就是HTML元素的默认排列方式, 块级元素独占一行, 行内元素或者行内块元素不独占一行\n\n浮动的语法\nfloat: none(默认值,不浮动,按标准文档流排列) 或者 left(左浮) 或者 right(右浮)\n\n左浮动和右浮动区别\n\n左浮动是把元素移动左边,直到遇到上一个浮动元素或者父元素的边界停止\n右浮动是把元素移动右边,直到遇到上一个浮动元素或者父元素的边界停止\n\n\n浮动的特点\n\n即使元素浮动以后, 还是父元素的内容, 会受到padding和obrder的约束 不会跑出父元素之外\n浮动以后的元素,会脱离标准文档流的约束(简称脱标), 不占位置标准文档流的约束就是块级元素从上到下排列, 行内或者行内块元素从左到右排列\n父容器的宽度不够的时候, 浮动元素只能下一行 \n文字是无法跑到浮动元素的上面,  因为浮动最初设计出来是实现图文混排\n\n\n\n 06-浮动的使用.html \n清除浮动\n为什么要清除浮动,因为浮动元素会脱标,不占位置,不占位置,不占位置\n比如子元素都浮动,容易导致父元素高度为0, 所以我们需要清除浮动带来的影响\n\n清除浮动方法一: 给父元素设置一个固定高度, 该方式不推荐 缺点该方式需要手动计算父元素的高度\n\n清除浮动方法二: 给父元素设置overflow:hidden;溢出隐藏, 缺点是超出父元素之外的内容会被隐藏 \n\n清除浮动方法三: 额外标签法, 在”最后一个浮动元素的后面”,添加一个”空的块级元素”,并且给这个块级元素设置clear:both;属性  \nclear是专门用于清除浮动的属性, clear属性的取值可以写left, right和both clear:left清除左浮动 clear:right清除右浮动 clear:both;清除左右浮动 \n缺点, 会有一个多余的块级元素\n\n❤❤❤清除浮动方法四: ::after伪元素清除法, 它是额外标签法的升级版 定义一个清除浮动类, 并且在父元素上面添加这个类名\n.clearfix1::after &#123;    /* content属性不能省略 */    content: &quot;&quot;;    /* 清除左右浮动 */    clear: both;    /* 转成块级元素 */    display: block;&#125;\n\n清除浮动方法五: 双伪元素清除浮动法  定义清除浮动类 并且在父元素上面添加这个类名\n.clearfix2::before, .clearfix2::after&#123;    content:&quot; &quot;;    display: table;&#125;.clearfix2::after&#123;    clear:both;&#125;\n\n版心布局\n因为版心布局页面中用的非常多,所以可以专门定义一个版心类\n版心类代码,仅需要设置宽度和margin左右auto即可\n\n\n.container &#123;    width: 1000px;    margin: 0 auto;&#125;\n\n\n版心布局是 宽度超过页面的一半,元素需要水平居中在页面的中间\n多类名选择器 同一个标签的class属性值可以设置多个类名,类名之间使用空格隔开\n\n\n&lt;div class=&quot;div1 container&quot;&gt;div1的内容&lt;/div&gt;&lt;div class=&quot;div2 container&quot;&gt;div2的内容&lt;/div&gt;&lt;div class=&quot;div3 container&quot;&gt;div3的内容&lt;/div&gt;\n\n 14-版心布局.html \n通栏布局\n通栏布局的宽度是百分比, 高度一般不超过页面的一半\n\n.container &#123;    width: 1000px;    margin: 0 auto;&#125;.header &#123;    height: 50px;    background: #ee0215;&#125;\n\n\n通栏布局一半会配合版心布局使用, 外面通栏布局,内部版心布局\n\n&lt;div class=&quot;header&quot;&gt;    &lt;div class=&quot;container&quot;&gt;header头部&lt;/div&gt;&lt;/div&gt;\n\n 15-通栏布局.html \n分栏布局\n浮动我们也会经常使用, 所以也可以跟版心类一样,定义两个浮动类\n\n.fl&#123;    float: left;&#125;.fr&#123;    float: right;&#125;\n\n\n分栏布局,就是一个大盒子中,里面会有不同的栏目, 多个栏目排成一排,核心是使用浮动\n\n&lt;div class=&quot;div2 container&quot;&gt;    &lt;div class=&quot;one fl&quot;&gt;one&lt;/div&gt;    &lt;div class=&quot;two fl&quot;&gt;two&lt;/div&gt;    &lt;div class=&quot;three fr&quot;&gt;three&lt;/div&gt;&lt;/div&gt;\n\n定位(position)\n浮动只能左浮和右浮, 网页中也会出现某个元素压住另一个元素,而且在这个元素的某个位置上 这种情况就需要使用定位\n还有一些固定在页面某个位置的元素,不随页面滚动而滚动的,这种也需要使用定位, 固定定位\n\n定位: 就是把元素定在某个位置上\n定位 &#x3D; 定位模式(position属性) + 偏移量(left,right  top,bottom)\n定位模式是告诉元素定位的参照物是谁\n偏移量就是定位坐标\n\nposition的取值：\n\nstatic(静态定位)\n\nabsolute(绝对定位)\n\nrelative(相对定位)\n\nfixed(固定定位)\n\nsticky(粘性定位)\n\n\n不同的定位模式,有不同特点,特点我们需要牢记\n\n先有定位模式, 再有偏移量\n偏移量的取值是数值带px单位 或者 百分比  允许负值\n\n\n静态定位(static)静态定位(position:static)的特点\n\n所有元素默认的定位方式都是静态定位\n静态定位模式下, 偏移量无效\n\n相对定位(relative)相对定位特点:\n\n如果只设置相对定位，不设置偏移量，元素位置不变\n元素不脱标，占位置\n相对于”自身原来的位置”为基点做定位\n设置了相对定位以后,float不失效, margin-left:auto; 跟 margin-right:auto;也不失效\n\n 03-相对定位(relative).html \n绝对定位(absolute)绝对定位特点\n\n只设置绝对定位,不设置偏移量, 该绝对定位元素位置不变\n脱标,不占位置\nfloat浮动失效 , margin左右auto也会失效\n改变元素的显示方式, 具有”行内块特性”, 行内块特性就是可以设置宽度高度, 默认宽度由内容决定\n如果所有父辈”都是静态定位”, 那么相对整个浏览器(页面)做位置的偏移\n如果有”一个”父辈元素是”非静态定位”,那么相对这个非静态定位父辈元素做位置的偏移\n如果有”多个”父辈元素是”非静态定位”,那么相对离当前绝对元素”最近”的非静态父辈元素, 做位置的偏移\n\n 04-绝对定位(absolute) 重点,难点.html 重点,难点.html) \n使用绝对定位实现子元素在父元素中水平垂直都居中子绝父相,就是子元素设置绝对定位,父元素设置相对定位\n.father &#123;    width: 600px;    height: 400px;    background: orange;    margin: 100px auto;    padding: 10px;    border: 5px solid blue;    /* 父元素相对定位 */    position: relative;&#125;.father .son &#123;    width: 200px;    height: 150px;    background: pink;    /* 设置绝对定位 */    position: absolute;    left: 50%;    top: 50%;    /* 设置外边距 */    /* margin-left:-自身宽度的一半; */    /* margin-top:-自身高度的一半; */    margin-left: -100px;    margin-top: -75px;&#125;\n\n&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;son&quot;&gt;son元素&lt;/div&gt;&lt;/div&gt;\n\n固定定位(fixed)固定定位的特点\n\n只设置固定定位,不设置偏移量, 该固定定位元素的位置不变\n\n固定定位元素脱标,不占位置\n\n固定定位元素具有行内块特性\n\n大多数情况,都是根据整个页面(浏览器)进行位置的偏移\n\n注意：fixed一般都会以页面左上角作为坐标原点，但是如果该元素中存在某个父辈元素设置了CSS3部分属性\n比如 transform, perspective 属性，或 filter 属性非 none 时，元素将会以该父辈左上角作为坐标原点。\n\n因为固定定位会脱标,不占位置,所以原来设置的float,和margin左右auto都会失效\n\n\n 08-固定定位(fixed).html \nsticky（粘性定位）CSS3新增\nCSS3新增 position:sticky（粘性定位）\n\n介绍：元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级元素祖先，包括table-related元素进行偏移。粘性定位可以被认为是”相对定位”和”固定定位”的混合。元素在跨越”特定阈值”前为相对定位，之后为固定定位偏移值不会影响任何其他元素的位置。\n\n\n文档:  https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n\n特别注意:  设置粘性定位的层需要是body的”子元素”,否则可能粘性定位失效\n\n\n堆叠顺序(z-index)\n堆叠熟悉怒就是非静态定位元素的层级, 谁压住谁 层级可以压住层级低的\nz-index取值是数值,不带CSS单位\n\nz-index 的特性如下:\n\n属性取值:正整数、负整数或 0 或者 auto，默认值是 0，数值越大，盒子越靠上；\nauto取值, 盒子不会创建一个新的本地堆叠上下文。在当前堆叠上下文中生成的盒子的堆叠层级和父级盒子相同。\n如果属性值相同，则按照书写顺序，后来居上；\n数字后面不能加单位。\nz-index只对非静态定位元素有效\n\n\n\n 09-堆叠顺序（层叠上下文）.html \n元素的显示和隐藏(display)\n隐藏元素display:none\ndisplay:none隐藏的元素会不占位置\n\n显示元素display:block\n\n\n.father .son1 &#123;    width: 100px;    height: 100px;    background: pink;    /* 隐藏元素 */    display: none;&#125;.father .son2 &#123;    width: 100px;    height: 100px;    background: skyblue;&#125;/* 鼠标移上.father元素以后  .father的后代.son1对应的样式 */.father:hover .son1 &#123;    /* 显示元素 */    display: block;&#125;\n\n元素的显示和隐藏(visibility)\n隐藏元素visibility: hidden;\nvisibility: hidden;隐藏的元素,只是在页面中看不见,但是还占据原有的位置\n\n显示元素visibility: visible;\n\n\n.father .son1 &#123;    width: 100px;    height: 100px;    background: pink;    /* 隐藏元素 */    visibility: hidden;&#125;.father .son2 &#123;    width: 100px;    height: 100px;    background: skyblue;&#125;/* 鼠标移上.father元素以后  .father的后代.son1对应的样式 */.father:hover .son1 &#123;    /* 显示元素 */    visibility: visible;&#125;\n\n元素透明度(opacity) CSS3\nopacity: 0~1之间的数值,不带px单位,允许小数值或者整数值,0代表完全透明度,1代表完全不透明;\n注意:  opacity会让整个元素内容以及子元素内容都变透明; 而rgba设置背景颜色变透明,不影响其内容以及子元素内容\n注意:  opacity设置透明度为0的时候,虽然元素看不见了,但是还占据位置\n\n.father &#123;    width: 500px;    height: 500px;    margin: 0 auto;    background: red;    /* opacity: 0.5; */    /* css中小数可以省略0 ,比如0.5=&gt;.5 */    opacity: .5;    /* opacity: 0.15; */    /* opacity: 0; */&#125;\n\n [02-元素透明度 opacity.html](....\\web\\每日代码\\09_css\\02-元素透明度 opacity.html) \n垂直对齐方式(vertical-align)\nvertical-align 不影响”块级元素”中的内容对齐，它只针对于 “行内元素”或者”行内块元素”，特别是”行内块元素”,\n通常用来控制图片img图标标签 或者  表单控件input标签与”文字的对齐方式”。\n\n当img标签设置vertical-align的取值不是baseline, 而是top,middle或者bottom的时候, 都可以解决图片底部默认产生的缝隙分析\n\n\n&lt;div&gt;默认对齐:&lt;img src=&quot;./images/2.jpg&quot; /&gt;默认文字和图片基线对齐(vertical-align:baseline)&lt;/div&gt;&lt;div&gt;基线对齐:&lt;img src=&quot;./images/2.jpg&quot; style=&quot;vertical-align: baseline;&quot; /&gt;文字和图片基线对齐(vertical-align:baseline)&lt;/div&gt;&lt;div&gt;垂直居中:&lt;img src=&quot;./images/2.jpg&quot; style=&quot;vertical-align: middle;&quot; /&gt;文字和图片中线对齐(vertical-align:middle)&lt;/div&gt;&lt;div&gt;顶部对齐:&lt;img src=&quot;./images/2.jpg&quot; style=&quot;vertical-align: top;&quot; /&gt;文字和图片行顶线对齐(vertical-align:top)&lt;/div&gt;&lt;div&gt;❤底部对齐:&lt;img src=&quot;./images/2.jpg&quot; style=&quot;vertical-align: bottom;&quot; /&gt;文字和图片行底线对齐(vertical-align:bottom)&lt;/div&gt;&lt;div&gt;数值: &lt;img src=&quot;./images/2.jpg&quot; style=&quot;vertical-align: 54px;&quot; /&gt;vertical-align的取值还可以写数值&lt;/div&gt;&lt;div&gt;百分比:&lt;img src=&quot;./images/2.jpg&quot; style=&quot;vertical-align: -73%;&quot; /&gt;vertical-align的取值还可以写百分比&lt;/div&gt;\n\n [03-垂直对齐方式vertical-align .html](....\\web\\每日代码\\09_css\\03-垂直对齐方式vertical-align .html) \n去除图片底侧空白缝隙\n去掉图片底部缝隙方式一, 设置图片的vertical-align属性\n\n.p1 img &#123;    vertical-align: bottom;&#125;\n\n\n去掉图片底部缝隙方式而, 把图片转成块级元素\n\n.p2 img &#123;    display: block;&#125;\n\n\n\n鼠标样式\n\n\n属性值\n示意图\n描述\n\n\n\nauto\n\n默认值，由浏览器根据当前上下文确定要显示的光标样式\n\n\ndefault\n\n默认光标，不考虑上下文，通常是一个箭头\n\n\nnone\n\n不显示光标\n\n\ninitial\n\n将此属性设置为其默认值\n\n\ninherit\n\n从父元素基础 cursor 属性的值\n\n\ncontext-menu\n\n表示上下文菜单可用\n\n\nhelp\n\n表示有帮助\n\n\npointer\n\n表示一个链接\n\n\nprogress\n\n进度指示器，表示程序正在执行一些处理，但是您仍然可以在该界面进行一些操作（与 wait 不同）\n\n\nwait\n\n表示程序繁忙，您应该等待程序指向完成\n\n\ncell\n\n表示可以选择一个单元格（或一组单元格）\n\n\ncrosshair\n\n一个简单的十字准线\n\n\ntext\n\n表示可以选择的文本\n\n\nvertical-text\n\n表示可以选择的垂直文本\n\n\nalias\n\n表示要创建别名或快捷方式\n\n\ncopy\n\n表示可以复制某些内容\n\n\nmove\n\n表示可以移动鼠标下方的对象\n\n\nno-drop\n\n表示所拖动的项目不能放置在当前位置\n\n\nnot-allowed\n\n表示无法完成某事\n\n\nall-scroll\n\n表示对象可以沿任何方向滚动（平移）\n\n\ncol-resize\n\n表示可以水平调整列的大小\n\n\nrow-resize\n\n表示可以垂直调整行的大小\n\n\nn-resize\n\n表示对象的边缘可以向上（向北）移动\n\n\ne-resize\n\n表示对象的边缘可以向右（向东）移动\n\n\ns-resize\n\n表示对象的边缘可以向下（向南）移动\n\n\nw-resize\n\n表示对象的边缘可以向左（向西）移动\n\n\nne-resize\n\n表示对象的边缘可以向上和向右（北&#x2F;东）移动\n\n\nnw-resize\n\n表示对象的边缘可以向上和向左（北&#x2F;西）移动\n\n\nse-resize\n\n表示对象的边缘可以向下和向右（向南&#x2F;向东）移动\n\n\nsw-resize\n\n表示对象的边缘可以向下和向左（南&#x2F;西）移动\n\n\new-resize\n\n表示可以双向调整对象大小的光标\n\n\nns-resize\n\n\n\n\nnesw-resize\n\n\n\n\nnwse-resize\n\n\n\n\nzoom-in\n\n表示可以放大某些内容\n\n\nzoom-out\n\n表示可以缩小某些内容\n\n\ngrab\n\n表示可以抓取（拖动）某些东西\n\n\ngrabbing\n\n表示已经抓取到某些东西\n\n\nurl(“”)\n\n自定义光标的样式，括号中的内容为光标图像的源文件路径\n\n\n【示例】使用 cursor 属性设置网页中光标的样式：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            height: 30px;            border: 1px solid green;            margin-top: 10px;        &#125;        .cell &#123;            cursor: cell;        &#125;        .crosshair &#123;            cursor: crosshair;        &#125;        .text &#123;            cursor: text;        &#125;        .vertical-text &#123;            cursor: vertical-text;        &#125;        .alias &#123;            cursor: alias;        &#125;        .copy &#123;            cursor: copy;        &#125;        .move &#123;            cursor: move;        &#125;        .no-drop &#123;            cursor: no-drop;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;cell&quot;&gt;cursor: cell;&lt;/div&gt;    &lt;div class=&quot;crosshair&quot;&gt;cursor: crosshair;&lt;/div&gt;    &lt;div class=&quot;text&quot;&gt;cursor: text;&lt;/div&gt;    &lt;div class=&quot;vertical-text&quot;&gt;cursor: vertical-text;&lt;/div&gt;    &lt;div class=&quot;alias&quot;&gt;cursor: alias;&lt;/div&gt;    &lt;div class=&quot;copy&quot;&gt;cursor: copy;&lt;/div&gt;    &lt;div class=&quot;move&quot;&gt;cursor: move;&lt;/div&gt;    &lt;div class=&quot;no-drop&quot;&gt;cursor: no-drop;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n提示：由于计算机系统的不同，鼠标的样式会存在一定的差异。\n\n\n参考文档:CSS cursor（鼠标样式） (biancheng.net)\n\nCSS的writing-mode属性\n介绍: writing-mode 属性定义了文本水平或垂直排布以及在块级元素中文本的行进方向。\n为整个文档设置该属性时，应在根元素上设置它（对于 HTML 文档，应该在 html 元素上设置）\n\n属性取值:\n\nhorizontal-tb 对于左对齐（ltr）文本，内容从左到右水平流动。对于右对齐（rtl）文本，内容从右到左水平流动。下一水平行位于上一行下方。\n\n❤vertical-rl 对于左对齐（ltr）文本，内容从上到下垂直流动，下一垂直行位于上一行左侧。对于右对齐（rtl）文本，内容从下到上垂直流动，下一垂直行位于上一行右侧。\n\n❤vertical-lr 对于左对齐（ltr）文本，内容从上到下垂直流动，下一垂直行位于上一行右侧。对于右对齐（rtl）文本，内容从下到上垂直流动，下一垂直行位于上一行左侧。\n\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode\n\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;style&gt;            * &#123;                margin: 0;                padding: 0;            &#125;            p &#123;                width: 300px;            &#125;            .p1 &#123;                background: pink;            &#125;            .p2 &#123;                background: skyblue;                writing-mode: horizontal-tb;            &#125;            .p3 &#123;                background: lightgreen;                writing-mode: vertical-rl;            &#125;            .p4 &#123;                background: orange;                writing-mode: vertical-lr;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p class=&quot;p1&quot;&gt;我是一段文字APP&lt;/p&gt;        &lt;p class=&quot;p2&quot;&gt;我也是一段文字APP&lt;/p&gt;        &lt;p class=&quot;p3&quot;&gt;我还是一段文字APP&lt;/p&gt;        &lt;p class=&quot;p4&quot;&gt;我也是是是一段文字APP&lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;\n\n\n\n网站小图标的使用\n通过link引入网站小图标,这个网站小图标的图片格式一般是icon,而且文件名一般为favicon.ico, 这个favicon.ico文件会放在跟网页同一级目录下\n\nvscode的快捷键link:favicon\n\n\n&lt;!-- &lt;link rel=&quot;shortcut icon&quot; href=&quot;ico图片所在路径&quot; type=&quot;image/x-icon&quot;&gt; --&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n\n\n\nResetCSS (样式重置)\n介绍：由于每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是重置默认样式（reset css）\n最简单的实现方法就是在所有CSS开始前，先把marin先把margin和padding都设为0，以防不同浏览器的显示效果不一样。\n\n但是这段代码过于简单并不能解决绝大多数开发中遇到的浏览器不兼容问题，并且使用通配符选择器影响页面性能。\n\n这里推荐使用专门的样式重置库，实现样式重置功能\n\n\nhtml, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, menu, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header, hgroup,main, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123;\tmargin: 0;\tpadding: 0;\tborder: 0;\tfont-size: 100%;\tfont: inherit;\tvertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, main, menu, nav, section &#123;\tdisplay: block;&#125;/* HTML5 hidden-attribute fix for newer browsers */*[hidden] &#123;    display: none;&#125;body &#123;\tline-height: 1;&#125;menu, ol, ul &#123;\tlist-style: none;&#125;blockquote, q &#123;\tquotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123;\tcontent: &#x27;&#x27;;\tcontent: none;&#125;table &#123;\tborder-collapse: collapse;\tborder-spacing: 0;&#125;\n\n\nreset.css \n\nCSS中的flex布局\n\n\n属性\n描述\n\n\n\ndisplay\n指定 HTML 元素的盒子类型\n\n\nflex-direction\n指定弹性盒子中子元素的排列方式\n\n\nflex-wrap\n设置当弹性盒子的子元素超出父容器时是否换行\n\n\nflex-flow\nflex-direction 和 flex-wrap 两个属性的简写\n\n\njustify-content\n设置弹性盒子中元素在主轴（横轴）方向上的对齐方式\n\n\nalign-items\n设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式\n\n\nalign-content\n修改 flex-wrap 属性的行为，类似 align-items，但不是设置子元素对齐，而是设置行对齐\n\n\norder\n设置弹性盒子中子元素的排列顺序\n\n\nalign-self\n在弹性盒子的子元素上使用，用来覆盖容器的 align-items 属性\n\n\nflex\n设置弹性盒子中子元素如何分配空间\n\n\nflex-grow\n设置弹性盒子的扩展比率\n\n\nflex-shrink\n设置弹性盒子的收缩比率\n\n\nflex-basis\n设置弹性盒子伸缩基准值\n\n\n介绍\nflex布局是一种新的布局方式\n\n传统布局和flex布局对比\n\n传统布局\n\n兼容性好\n\n布局繁琐\n\n局限性，不能再移动端很好的布局\n\n\n\nflex布局\n\n操作方便，布局极其简单，移动端使用比较广泛\n\npc端浏览器支持情况比较差\n\nIE11或更低版本不支持flex或仅支持部分\n\n\n\n\n\n布局建议\n如果是pc端页面布局，还是采用传统方式 display+float+position\n如果是移动端或者是不考虑兼容的pc则采用flex\n\n\nflex布局原理\n给ul设置display:flex,那么ul就是flex容器, ul里面的”子元素”就是flex项目\n因为flex容器有flex容器的属性,flex项目有flex项目的属性\n\n开启弹性盒子布局\n.box ul &#123;    display: flex;&#125;\n\n注意: 开启flex以后,会出现两个轴,一个是主轴,一个是侧轴, 我们的flex项目会沿着主轴方向排列\n主轴默认方向是从左到右, 侧轴默认方向是从上到下  主轴跟侧轴始终是垂直关系\n\n\n容器属性(对父元素设置)\nflex-direction：设置主轴的方向[^a1]\njustify-content：设置主轴上的子元素排列方式\nflex-wrap：设置子元素是否换行  \nalign-content：设置侧轴上的子元素的排列方式（多行）\nalign-items：设置侧轴上的子元素排列方式（单行）\nflex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap\n\nflex-direction**注：**开启弹性盒子以后, 项目会沿着主轴方向排列,默认主轴方向是从左到右,通过容器属性flex-direction改变主轴方向\n\nrow取值就是默认取值,主轴方向从左到右\n\nflex-direction: row; \n\n\nrow-reverse主轴方向从右到左\n\nflex-direction: row-reverse;\n\n\ncolumn主轴方向从上到下\n\nflex-direction: column;\n\n\ncolumn-reverse主轴方向从下到上\n\nflex-direction: column-reverse;\n\n\n[05-容器属性-flex-direction 要记 重点.html](....\\web\\每日代码\\10_flex\\05-容器属性-flex-direction 要记 重点.html) \n\njustify-content**注：**justify-content设置项目在主轴方向上排列方式;\n\ncentet项目排列在主轴中间\n\njustify-content: center;\n\n\nflex-start项目排列在主轴的开始位置\n\njustify-content: flex-start;\n\n\nflex-end项目排列在主轴的结束位置\n\njustify-content: flex-end;\n\n\nspace-between两端对齐\n\njustify-content: space-between;\n\n\nspace-around项目左右间隔相同\n\njustify-content: space-around;\n\n\nspace-evenly平分空白距离\n\njustify-content: space-evenly;\n\n\n[06-容器属性-justify-content 要记 重点.html](....\\web\\每日代码\\10_flex\\06-容器属性-justify-content 要记 重点.html) \n\nflex-wrap**注：**默认情况下,如果flex项目的总宽度超过flex容器,flex容器会强制这些flex项目一行显示,所以会对flex项目进行压缩\n​\t通过flex-wrap属性可以设置flex项目是否允许换行\n\n取值: nowrap不换行(默认取值)\n\nflex-wrap: nowrap;\n\n\nwrap换行\n\nflex-wrap: wrap;\n\n\n[07-容器属性-flex-wrap 要记.html](....\\web\\每日代码\\10_flex\\07-容器属性-flex-wrap 要记.html) \n\nalign-items**注：**align-items属性是设置单行项目,在侧轴方向的对齐方式\n\nstretch拉伸,默认取值\n\nalign-items: stretch;\n\n\ncenter侧轴的中部\n\nalign-items: center;\n\n\nflex-start侧轴的开始\n\nalign-items: flex-start;\n\n\nflext-end侧轴的结束\n\nalign-items: flex-end;\n\n\n[08-容器属性-align-items 要记 重点.html](....\\web\\每日代码\\10_flex\\08-容器属性-align-items 要记 重点.html) \n\nalign-content**注：**align-content属性是设置多行项目,在侧轴方向的对齐方式\n​\t需要设置flex-wrap:wrap才可能出现多行项目\n\nstretch拉伸,默认取值\n\nalign-content: stretch;\n\n\ncenter侧轴的中部\n\nalign-content: center;\n\n\nflex-start侧轴的开始\n\nalign-content: flex-start;\n\n\nflext-end侧轴的结束\n\nalign-content: flex-end;\n\n\nspace-between侧轴两端对齐\n\nalign-content: space-between;\n\n\nspace-around侧轴左右间隔相同\n\nalign-content: space-around;\n\n\nspace-evenly侧轴平分空白距离\n\nalign-content: space-evenly;\n\n\n[09-容器属性-align-content 要记.html](....\\web\\每日代码\\10_flex\\09-容器属性-align-content 要记.html) \n\nflex-flow**注：**flex-flow可以同时设置flex-direction以及flex-wrap属性, 没有顺序要求, 被省略的属性值将使用默认值\n.box ul &#123;    /* 开启弹性盒子布局 */    display: flex;    /* flex-direction: row-reverse;    flex-wrap: wrap; */    /* flex-flow: row-reverse wrap; */    /* flex-flow: wrap row-reverse; */    /* flex-flow: wrap; */    flex-flow: row-reverse;&#125;\n\n\n[10-容器属性-flex-flow 了解.html](....\\web\\每日代码\\10_flex\\10-容器属性-flex-flow 了解.html) \n\nflex布局子项(项目)属性\nflex-grow属性定义项目的放大比例\nflex-shrink属性定义了项目的缩小比例\nflex-basis属性定义了剩余空间分配之前元素的默认大小\nflex子项目占的份数\nalign-self控制子项自己在侧轴的排列方式\norder属性定义子项的排列顺序（前后顺序）\n\nflex-grow**注：**flex-grow定义项目的扩大比例, 当flex容器有剩余宽度的时候,定义剩余的宽度如何分配\n\nflex-grow取值是数值,不带CSS单位, 默认为0; 0表示不扩大\n\n.box ul li:nth-child(1) &#123;    flex-grow: 1;&#125;.box ul li:nth-child(2) &#123;    flex-grow: 2;&#125;\n\n\n11-项目属性-flex-grow属性.html \n\nflex-shrink**注：**当flex容器宽度不够的时候,项目如何缩小,项目的缩小比例\n​\t即1&#x2F;0大小不变，1&#x2F;1大小auto，1&#x2F;2为50%。\n\nflex-shrink取值是数值,不带css单位, 默认1;\n\n.box ul li:nth-child(1) &#123;    flex-shrink: 0;&#125;.box ul li:nth-child(2) &#123;    flex-shrink: 2;&#125;\n\n\n 12-项目属性-flex-shrink属性.html \n\nflex-basis**注：**flex-basis属性定义了剩余空间分配之前元素的默认大小，它可以是长度（例如20%, 40px, 5em等）或关键字auto。\n​\t它的默认值为auto，即”项目的本来大小”。\n.box ul li:nth-child(1) &#123;    /* 百分比是相对flex容器的 */    flex-basis: 10%;    flex-grow: 1;&#125;.box ul li:nth-child(2) &#123;    flex-basis: auto;    flex-grow: 1;&#125;.box ul li:nth-child(3) &#123;    /* 1em等于1个字体大小 */    flex-basis: 10em;    flex-grow: 0;&#125;.box ul li:nth-child(4) &#123;    flex-basis: 80px;    flex-grow: 0;&#125;\n\n\n13-项目属性-flex-basis属性.html \n\nflex属性**注：**flex属性是flex-grow, flex-shrink 和 flex-basis的简写属性，默认值为0 1 auto。\n\n参考文档:  https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex#syntax\n\n\n语法:\nflex: flex-grow flex-shrink flex-basis;\nflex: 放大比例 缩小比例 项目默认大小\n\n另外,可以使用一个，两个或三个值来指定 flex属性, 规则如下: \n\n单值语法: 值必须为以下其中之一：\n一个无单位数 (): 它会被当作 flex: 1 0; 的值被假定为 1，然后 的值被假定为0。\n一个有效的 宽度 (width) 值：它会被当作  的值。\n关键字none，auto或initial.\n\n双值语法: 第一个值必须为一个无单位数，并且它会被当作  的值。第二个值必须为以下之一：\n一个无单位数：它会被当作  的值。\n一个有效的宽度值：它会被当作  的值。\n\n三值语法：\n第一个值必须为一个无单位数，并且它会被当作  的值。\n第二个值必须为一个无单位数，并且它会被当作  的值。\n第三个值必须为一个有效的宽度值，并且它会被当作的值。\n\n\n\n\n.box ul li:nth-child(1) &#123;    /* flex: 3; */    /* 等同于    flex-grow: 3;    flex-shrink: 1;    flex-basis: 0%; */    flex: 2;    /* 等同于    flex-grow: 2;    flex-shrink: 1;    flex-basis: 0%; */&#125;.box ul li:nth-child(2) &#123;    flex: 1;    /* 等同于    flex-grow: 1;    flex-shrink: 1;    flex-basis: 0%;    */&#125;.box ul li:nth-child(3) &#123;    flex: 0 1 auto;    /* 等同于    flex-grow: 0;    flex-shrink: 1;    flex-basis: auto; */&#125;\n\n\n该属性有两个快捷值：\nflex: auto(等同于flex: 1 1 auto) \nflex: none(等用于flex: 0 0 auto)\n\n\n\n.box ul li:nth-child(1) &#123;    flex: auto;&#125;.box ul li:nth-child(2) &#123;    flex: none;&#125;\n\n\n[15-项目属性-flex属性 重点 难点.html](....\\web\\每日代码\\10_flex\\15-项目属性-flex属性 重点 难点.html) \n\nalign-self**注：**align-self设置”当前某个“项目在侧轴的对齐方式;\n.box ul li:nth-child(1) &#123;    /* align-self设置&quot;当前某个&quot;项目在侧轴的对齐方式; */    align-self: flex-start;&#125;.box ul li:nth-child(2) &#123;    align-self: flex-end;&#125;.box ul li:nth-child(3) &#123;    align-self: stretch;&#125;\n\norder**注：**order属性定义项目的排列顺序\n\norder 属性规定了弹性容器中的可伸缩项目在布局时的顺序。元素按照 order 属性的值的增序进行布局\n取值数值,不带px单位;  数值越小，排列越靠前，默认为0。\n\n.box ul li:nth-child(1) &#123;    order: 1;&#125;.box ul li:nth-child(2) &#123;    order: -2;&#125;.box ul li:nth-child(4) &#123;    order: 3;&#125;.box ul li:nth-child(5) &#123;    order: -1;&#125;\n\n\n19-项目属性-order.html \n\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"DOM,BOM 学习笔记","url":"/2023/07/06/DOM,BOM/","content":"DOM（Document Object Model——文档对象模型）DOM 介绍\n**介绍:**什么是DOM，简单的说DOM是一套对文档的内容进行抽象和概念化的方法。DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。DOM 是万维网上使用最为广泛的API之一，因为它允许运行在浏览器中的代码访问文件中的节点并与之交互。节点可以被创建，移动或修改。节点可以关联上事件处理器，一旦某一事件被触发了，那些事件处理器就会被执行。\n\nDOM主要用于操作网页的标签内容,标签样式,标签属性,以及标签(增删改查)\n\nDOM学习的最终目的 完成一些常见网页特效  轮播图 选项卡…\n\n**注意：**DOM既不是HTML的一部分,也不是JavaScript一部分,而是浏览器厂商都实现了的一些独立的规则，并允许JavaScript可以访问和操作存储在DOM中的内容（DOM 也可以使用其他的语言来实现）\n\n什么是DOM\n文档对象模型（Document Object Model，简称DOM），是 W3C 组织推荐的处理可扩展标记语言（html或者xhtml）的标准编程接口。\nW3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。\n\n\n事件基础事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。\n简单理解: 触发— 响应机制。\n\n网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。\n\n事件三要素\n事件源（谁）:触发事件的元素\n事件类型（做什么）: 例如 onclick 点击事件\n事件处理程序（怎么做）:事件触发后要执行的代码(函数形式)，事件处理函数\n\n事件的绑定方式\n事件的绑定方式有二种:动态绑定与行内绑定\n\n动态绑定事件\n说明: 在JS代码里面,动态给指定DOM元素绑定事件  \n\n动态事件绑定的步骤如下:\n第一步:获取事件源(获取DOM对象)\n第二步:注册事件(绑定事件)\n第三步:添加事件处理程序(一般是一个匿名函数)\n\n动态绑定语法\ndom对象.on事件类型 &#x3D; 匿名函数 或者 有名函数名\nbtn1.onmouseover = function () &#123;    console.log(2222);&#125;function fn() &#123;    console.log(3333);&#125;btn1.onmouseout = fn;\n\n行内绑定事件\n说明:所谓的行内绑定事件 是将事件写在HTML标签里面\nHTML标签中自带一些事件属性 比如 onclick onmouseover等\n\n\nDOM元素获取\nDOM把整个页面当做一个文档, DOM中最大的对象就是document对象\n\nconsole.log(document);\n\n\n如果想更好的查看某个对象的方法和属性, 可以使用console.dir()方法  dir是directory目录的简写\n\nconsole.dir(document);\n\n\n获取DOM元素的方法有如下:\n根据ID获取元素document.getElementById(&quot;id属性值&quot;);   返回值 单个DOM对象或者null\nvar oneDiv = document.getElementById(&quot;one&quot;);console.log(oneDiv);console.log(document.getElementById(&quot;two&quot;));\n\n根据标签名获取元素document.getElementsByTagName(&quot;标签名&quot;)  返回值是一个伪数组(类数组对象)\nvar objDivs = document.getElementsByTagName(&quot;div&quot;);console.log(objDivs);console.log(&quot;&quot;);console.log(Array.isArray(objDivs));console.log(objDivs.constructor === Array);console.log(objDivs instanceof Array);console.log(&quot;&quot;);console.log(objDivs[0]);console.log(objDivs[1]);console.log(objDivs[2]);console.log(&quot;&quot;);console.log(objDivs.length);\n\n根据标签的name属性获取元素   返回值是一个伪数组document.getElementsByName(&quot;name属性值&quot;)\nvar username = document.getElementsByName(&quot;username&quot;);console.log(username);var usersex = document.getElementsByName(&quot;usersex&quot;);console.log(usersex);\n\nH5新增获取元素方式   IE低版本浏览器不支持(IE678)\ndocument.getElementsByClassName(&quot;class属性值&quot;)   返回值是一个伪数组\nvar objTwos = document.getElementsByClassName(&quot;two&quot;);console.log(objTwos);\n\ndocument.querySelector(&quot;带符号的css选择器&quot;) 找到”第一个”符合CSS选择器的元素    🧡\nconsole.log(document.querySelector(&quot;#one&quot;));console.log(document.querySelector(&quot;.two&quot;));console.log(document.querySelector(&quot;input[name=&#x27;usersex&#x27;]&quot;));console.log(document.querySelector(&quot;div&quot;));console.log(document.querySelector(&quot;ul li&quot;));\n\ndocument.querySelectorAll(&quot;带符号css选择器&quot;) 找到”所有”符合CSS选择器的元素    🧡\nconsole.log(document.querySelectorAll(&quot;ol li&quot;));console.log(document.querySelectorAll(&quot;dl dd&quot;));console.log(document.querySelectorAll(&quot;div&quot;));console.log(document.querySelectorAll(&quot;.two&quot;));console.log(document.querySelectorAll(&quot;#one&quot;));\n\n另外, document对象可以尝试换成其他dom父对象, 表示从指定的dom父对象里面查找元素\nvar objUl = document.querySelector(&quot;ul&quot;);console.log(objUl.querySelectorAll(&quot;li&quot;));\n\n\n获取特殊元素( body,html )\n获取body标签  document.body\nconsole.log(document.body);\n\n获取html标签  document.documentElement\nconsole.log(document.documentElement);\n\n\n\n\n\n常用事件onchange事件\n概念: onchange事件当用户更改&lt;input&gt;、&lt;select&gt;和&lt;textarea&gt; 元素的值并提交这个更改时，onchange 事件在这些元素上触发。和 oninput 事件不一样，onchange 事件并不是每次元素的 value 改变时都会触发。\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/change_event\n\n// 下拉框的onchange需要给select标签绑定var select = document.querySelector(&quot;select&quot;);select.onchange = function () &#123;    console.dir(this);    console.log(this.value);    console.log(this.selectedIndex);    console.log(&quot;&quot;);&#125;\n\noninput事件\noninput 事件在用户输入时触发\n该事件在 &lt;input&gt; 或 &lt;textarea&gt; 元素的值发生改变时触发。\n\n提示： 该事件类似于 onchange 事件。不同之处在于 oninput 事件在元素值发生变化是立即触发，\n\noninput跟onchange事件的区别:\n\nonchange 在元素失去焦点时触发\n在按快捷键ctrl+v粘贴的时候,onkeyup这个事件会触发两次, 但是oninput只触发一次;  \n鼠标右键粘贴,只能触发oninput事件以及onchange事件,不能触发onkeyup事件\n\n\n\n\n参考文档:  https://www.runoob.com/jsref/event-oninput.html\n\nvar textarea = document.querySelector(&quot;textarea&quot;);textarea.oninput = function () &#123;    console.log(this.value);&#125;// 下拉框的oninput需要给select标签绑定var select = document.querySelector(&quot;select&quot;);select.oninput = function () &#123;    console.dir(this);    console.log(this.value);    console.log(this.selectedIndex);    console.log(&quot;&quot;);&#125;\n\n常用键盘事件\n键盘事件 触发条件\nonkeyup 某个键盘按键被松开时触发\nonkeydown 某个键盘按键被按下时触发\nonkeypress 某个键盘按键被按下时触发 但是它不识别功能键 比如 ctrl shift 箭头等\n\n注意:\n\nonkeypress和前面两个onkeyup跟onkeydown的区别是  onkeypress不识别功能键,比如箭头,ctrl,shift 等\n三个事件的执行顺序是:  keydown &#x3D;&gt; keypress &#x3D;&gt; keyup\n\n\n键盘事件对象\n键盘事件对象属性 说明\ne.keyCode 返回该键的ASCII值  e.keyCode只有keypress事件可以区分大小写字母\ne.key 返回用户按下的物理按键的键名\n\n\n// 获取dom对象var objInput = document.querySelector(&quot;input&quot;);// 绑定键盘事件objInput.onkeyup = function (e) &#123;    console.log(&quot;keyup&quot;);    console.log(&quot;this.value=&gt;&quot;, this.value);    console.log(&quot;键盘事件对象e=&gt;&quot;, e);    console.log(&quot;e.keyCode=&gt;&quot;, e.keyCode);    console.log(&quot;e.key=&gt;&quot;, e.key);    console.log(&quot;&quot;);&#125;;objInput.onkeydown = function (e) &#123;    console.log(&quot;keydown&quot;);    console.log(&quot;this.value=&gt;&quot;, this.value);    console.log(&quot;键盘事件对象e=&gt;&quot;, e);    console.log(&quot;e.keyCode=&gt;&quot;, e.keyCode);    console.log(&quot;e.key=&gt;&quot;, e.key);    console.log(&quot;&quot;);&#125;;objInput.onkeypress = function (e) &#123;    console.log(&quot;keypress&quot;);    console.log(&quot;this.value=&gt;&quot;, this.value);    console.log(&quot;键盘事件对象e=&gt;&quot;, e);    console.log(&quot;e.keyCode=&gt;&quot;, e.keyCode);    console.log(&quot;e.key=&gt;&quot;, e.key);    console.log(&quot;&quot;);&#125;;\n\n常用鼠标事件\n\n\n鼠标事件\n触发条件\n\n\n\nclick\n鼠标点击左键触发\n\n\ndblclick\n鼠标双击左键触发\n\n\nmouseover\n鼠标移上触发\n\n\nmouseout\n鼠标移出触发\n\n\nmouseenter\n鼠标进入触发\n\n\nmouseleave\n鼠标离开触发\n\n\nmousemove\n鼠标移动触发\n\n\nmouseup\n鼠标弹起触发\n\n\nmousedown\n鼠标按下触发\n\n\nfocus\n获取鼠标焦点触发\n\n\nblur\n失去鼠标焦点触发\n\n\nmouseenter和mouseover的区别以上两组事件,如果针对的是同一个元素,没有很大区别的\n注意: onmouseover和onmouseout会事件冒泡\n注意: onmouseenter和onmouseleave不会事件冒泡\n\n03-mouseenter和mouseover的区别.html \n\nscroll事件\nscroll事件可以给元素绑定,可以给页面绑定\n\n当元素滚动的时候,就可以触发scroll事件\nvar div1 = document.getElementById(&quot;div1&quot;);div1.onscroll = function () &#123;    console.log(&quot;div1.scrollLeft=&gt;&quot;, div1.scrollLeft);&#125;\n\n给页面绑定scroll事件, 可以给document对象, window对象或者body绑定页面滚动事件 一般给window对象绑定\n注意: 给html对象绑定scroll事件无效\n\n\n滚动窗口至文档中的特定位置\n语法:\n语法一: window.scroll(x-coord,y-coord )\n语法二: window.scroll(options)\n\noptions 是一个包含三个属性的对象:\ntop 等同于  y-coord\nleft 等同于  x-coord\nbehavior  类型String,表示滚动行为,支持参数 smooth(平滑滚动),instant(瞬间滚动),默认值auto\n\n**注意：**里面的x和y不需要带px单位 直接写数字即可\n另外,还有一个window.scrollTo函数,实际上和 window.scroll是一样的\n\n参考文档:\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Window/scroll\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo\n\n\nwindow.scrollTo( 0, 1000 );btns[0].onclick = function () &#123;    // 如果只有一个参数的时候,这个参数需要是一个对象    // window.scroll(0);// 报错    /* window.scroll(&#123;                left: 0            &#125;); */    // window.scroll(水平滚动条位置, 垂直滚动条位置);    window.scroll(0, 0);&#125;// 设置滚动行为改为平滑的滚动window.scrollTo(&#123;    top: 1000,    left: 500,    behavior: &quot;smooth&quot;&#125;);\n\nwindow对象的常见事件\n页面（窗口）加载事件（两种）\nwindow对象的load事件    🧡\n\nwindow.onload() 方法用于在网页加载完毕后立刻执行的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。\nwindow.onload() 通常用于 &lt;body&gt; 元素，在页面完全载入后(包括DOM结构, 图片、css文件等等)执行脚本代码\n\ndocument对象的 DOMContentLoaded 事件\n\n当初始HTML文档已完全加载和解析时，将触发 DOMContentLoaded 事件，而不需要等待样式表，图像和子框架页面加载（事件可以用来检测HTML页面是否完全加载完毕(fully-loaded)）。\n\n小结:\nDOMContentLoaded 事件绑定的时候, 需要使用事件监听方式绑定\nload事件需要等待HTML结构,CSS样式,图像等都加载完毕以后,再调用load的事件函数\nDOMContentLoaded 仅需要等待HTML结构加载完毕即可调用\n\n\n\n\n调整窗口大小事件window对象的resize事件  当浏览器可视区域大小发生变化的时候,就会调用resize事件\n\n\nDOM对象操作DOM对象操作双标签的标签内容操作的意思就是可以获取也可以设置\n方式一: dom对象.innerText\n\ninnerText获取标签内容的时候,只有文本内容\ninnerText设置内容的时候,无法解析HTML标签\n\nbtns[0].onclick = function () &#123;    // innerText获取标签内容的时候,只有文本内容    console.log(myDiv1.innerText);&#125;btns[2].onclick = function () &#123;    // innerText设置内容的时候,无法解析HTML标签    myDiv2.innerText = &quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;;&#125;\n\n方式二: dom对象.innerHTML\n\ninnerHTML获取标签内容的时候,会保留标签以及空格换行\ninnerHTML设置内容的时候,可以解析HTML标签\n\nbtns[1].onclick = function () &#123;    // innerHTML获取标签内容的时候,会保留标签以及空格换行    console.log(myDiv1.innerHTML);&#125;btns[3].onclick = function () &#123;    // innerHTML设置内容的时候,可以解析HTML标签    myDiv2.innerHTML = &quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;;&#125;\n\nDOM对象操作表单元素属性\n**注意:**表单元素中有一些属性如:disabled、checked、selected，元素对象的这些属性的值是”布尔型”。\n\nvar btns = document.querySelectorAll(&quot;button&quot;);var username = document.getElementById(&quot;username&quot;);var hobby = document.getElementById(&quot;hobby&quot;);btns[0].onclick = function () &#123;    console.log(username.value);&#125;;btns[1].onclick = function () &#123;    username.value = &quot;李思思&quot;;&#125;;btns[2].onclick = function () &#123;    console.log(username.disabled);&#125;;btns[3].onclick = function () &#123;    username.disabled = false;&#125;;btns[4].onclick = function () &#123;    console.log(hobby.checked);&#125;;btns[5].onclick = function () &#123;    hobby.checked = true;&#125;;btns[6].onclick = function () &#123;    hobby.checked = false;&#125;;btns[7].onclick = function () &#123;    if (hobby.checked) &#123;        hobby.checked = false;    &#125; else &#123;        hobby.checked = true;    &#125;    // hobby.checked = !hobby.checked;&#125;;\n\nDOM对象操作样式\n通过dom对象的style属性操作元素的”行内式样式”\n\n\n设置单个CSS属性样式  只会覆盖同名属性\ndom对象.style.CSS样式属性名 &#x3D; “CSS样式属性值”;\n\n同时设置多个CSS属性样式\ndom对象.style &#x3D; “css属性名1: css属性值1;css属性名2: css属性值2; css属性名3: css属性值3;…”\n注意: 该方式会清空原来的行内式样式属性值\n\n\nvar objDiv = document.querySelector(&quot;div&quot;);var btns = document.querySelectorAll(&quot;button&quot;);btns[0].onclick = function () &#123;    // 设置单个CSS属性样式  只会覆盖同名属性    // dom对象.style.CSS样式属性名 = &quot;CSS样式属性值&quot;;    objDiv.style.color = &quot;red&quot;;    // 注意: 此时, 如果CSS样式属性名多个单词组成的, 需要写成去掉短横杠以后,并且使用驼峰法 font-size =&gt; fontSize    objDiv.style.fontSize = &quot;16px&quot;;    objDiv.style.textAlign = &quot;center&quot;;    objDiv.style.width = &quot;400px&quot;;&#125;;btns[1].onclick = function () &#123;    // 同时设置多个CSS属性样式    // 注意: 该方式会清空原来的行内式样式属性值    // dom对象.style = &quot;css属性名1: css属性值1;css属性名2: css属性值2; css属性名3: css属性值3;...&quot;    objDiv.style = &quot;font-size: 40px; color:green; width: 400px&quot;;&#125;;\n\n\n通过DOM对象操作类名,从而操作标签的CSS样式\n但是又由于JS中, class是ES6的一个关键字, 所以操作类名的时候 不是使用 dom对象.class 而使用 dom对象.className\nvar objDiv = document.querySelector(&quot;div&quot;);console.log(objDiv.id);console.log(objDiv.class);console.log(objDiv.className);\n\n\n给dom对象设置类名语法  该方式会覆盖原来的类名\ndom对象.className &#x3D; “类名”;\ndom对象.className &#x3D; “类名1 类名2 类名3…”;\n\n\nbtns[1].onclick = function () &#123;    // objDiv.className = &quot;one&quot;;    // objDiv.className = &quot;one two&quot;;    // objDiv.className = &quot;myDiv one two&quot;;    objDiv.className = oldClassName + &quot; one two&quot;;&#125;;\n\n\nH5新增了一种类名操作方式, 通过dom对象的classList属性操作类名\ndom对象.classList.value 获取所有类名\ndom对象.classList.add(“指定类名”) 添加指定类名    🧡\ndom对象.classList.remove(“指定类名”) 删除指定类名    🧡\ndom对象.classList.contains(“指定类名”) 判断是否含有指定类名  返回是布尔值 \ndom对象.classList.toggle(“指定类名”) 切换指定类名 有则删 无则加\n\n\nvar btns = document.querySelectorAll(&quot;button&quot;);btns[0].onclick = function () &#123;    console.log(myDiv.classList.value);&#125;;btns[1].onclick = function () &#123;    myDiv.classList.add(&quot;two&quot;);    myDiv.classList.add(&quot;three&quot;);&#125;;btns[2].onclick = function () &#123;    myDiv.classList.remove(&quot;two&quot;);&#125;;btns[3].onclick = function () &#123;    console.log(myDiv.classList.contains(&quot;two&quot;));&#125;;btns[4].onclick = function () &#123;    myDiv.classList.toggle(&quot;two&quot;);&#125;;\n\n排他操作\n排他操作的意思就是先清除所有,再设置当前\n\nfor (var i = 0; i &lt; items.length; i++) &#123;    items[i].onclick = function () &#123;        // 绑定事件跟触发事件不是同时发生的, 我们能点击的时候, for循环已经结束了        // console.log(&quot;点击onclick里面的i=&gt;&quot;, i);        // items[i].classList.add(&quot;active&quot;);// 报错        // 排他操作的意思就是先清除所有,再设置当前        // 清除所有.item身上的.active类名        /* items[0].classList.remove(&quot;active&quot;);                items[1].classList.remove(&quot;active&quot;);                items[2].classList.remove(&quot;active&quot;);                items[3].classList.remove(&quot;active&quot;); */        for (var j = 0; j &lt; items.length; j++) &#123;            // 删除类名            items[j].classList.remove(&quot;active&quot;);        &#125;        // console.log(&quot;this=&gt;&quot;, this);        // 添加类名        this.classList.add(&quot;active&quot;);        console.log(this);    &#125;&#125;\n\n自定义属性操作\nHTML除了一些内置属性之外,程序员还可以根据需要自定义一些属性,  自定义的属性建议以data-开头\n\n获取自定义属性,也可以获取内置属性,但是获取类名的时候,需要使用class\ndom对象.getAttribute(“自定义属性名或者内置属性名”)\nbtns[2].onclick = function () &#123;    console.log(objA.getAttribute(&quot;id&quot;));    console.log(objA.getAttribute(&quot;className&quot;));    console.log(objA.getAttribute(&quot;href&quot;));    console.log(objA.getAttribute(&quot;data-index&quot;));&#125;;\n\n设置自定义属性,也可以设置内置属性,但是设置类名的时候,需要使用class\ndom对象.setAttribute(“自定义属性名或者内置属性名”, “属性值”)\nbtns[3].onclick = function () &#123;    objA.setAttribute(&quot;id&quot;, &quot;first&quot;);    objA.setAttribute(&quot;className&quot;, &quot;dier&quot;);    objA.setAttribute(&quot;href&quot;, &quot;https://www.jd.com&quot;);    objA.setAttribute(&quot;data-index&quot;, 4);&#125;;\n\n删除属性(包括删除内置属性以及删除自定义属性)\ndom对象.removeAttribute(“属性名”)\nbtns[4].onclick = function () &#123;    objA.removeAttribute(&quot;id&quot;);    objA.removeAttribute(&quot;href&quot;);    objA.removeAttribute(&quot;data-index&quot;);&#125;;\n\n操作”自定义属性”,建议使用 setAttribute,getAttribute\n操作”内置属性”,建议使用 dom对象.内置属性名\nbtns[5].onclick = function () &#123;    console.log(&quot;inputObj.checked=&gt;&quot;, inputObj.checked);    console.log(&#x27;inputObj.getAttribute(&quot;checked&quot;)=&gt;&#x27;, inputObj.getAttribute(&quot;checked&quot;));    console.log(&quot;&quot;);&#125;btns[6].onclick = function () &#123;    // inputObj.checked = false;    inputObj.setAttribute(&quot;checked&quot;, false);&#125;\n\n\n04-自定义属性操作.html \n\n节点操作(操作DOM结构,添加标签,删除标签等)节点概述\n“网页中的所有内容都是节点”（元素节点、属性节点、文本节点、注释节点等），在DOM 中，节点使用 node 来表示\nHTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。\n一般地，节点至少拥有”nodeType（节点类型）”、”nodeName（节点名称）”和”nodeValue（节点值）”这三个基本属性。\n\nnodeType节点类型常用值有以下3个:\n元素节点 nodeType为1\n属性节点 nodeType为2\n文本节点 nodeType为3\n\n补充内容:\n通过dom对象.getAttributeNode(“属性名”) 方法从当前元素中通过名称获取属性节点。\n父节点.firstChild  返回第一个子节点,找不到则返回null\n\n\n\n**参考文档：**https://www.cnblogs.com/xiaoleidiv/p/3347483.html \n\n// 获取元素节点var john = document.getElementById(&quot;john&quot;);console.log(john);console.log(john.nodeType);console.log(john.nodeName);console.log(john.nodeValue);console.log(&quot;&quot;);console.log(&quot;&quot;);// 获取属性节点var objName = john.getAttributeNode(&quot;name&quot;); // 获取john这个dom对象身上的name属性节点console.log(objName);console.log(objName.nodeType);console.log(objName.nodeName);console.log(objName.nodeValue);console.log(&quot;&quot;);console.log(&quot;&quot;);// 获取文本节点var objText = john.firstChild;console.log(objText);console.log(objText.nodeType);console.log(objText.nodeName);console.log(objText.nodeValue);\n\n\n07-节点概述.html \n\n节点操作父级节点\t🧡节点.parentNode\n\n子节点\t🧡获取所有子节点  了解\n父节点.childNodes     返回包含指定节点的子节点的集合\n\n获取子元素节点\t🧡父节点.children\n\n获取第1个子节点父节点.firstChild 返回第一个子节点,找不到则返回null  \n包含所有的节点,不管是文本节点还是元素节点\n\n获取最后1个子节点父节点.lastChild 返回最后一个子节点,找不到则返回null  \n包含所有的节点,不管是文本节点还是元素节点\n\n获取第1个子元素节点\t🧡父节点.firstElementChild 返回第一个子元素节点,找不到则返回null\n\n获取最后1个子元素节点\t🧡父节点.lastElementChild 返回最后一个子元素节点,找不到则返回null\n\n\n兄弟节点\n下一个兄弟节点当前元素.nextSibling 返回当前元素的下一个兄弟节点, 找不到返回null 包含元素节点或者 文本节点等等\n\n上一个兄弟节点当前元素.previousSibling 返回当前元素的上一个兄弟节点, 找不到返回null 包含元素节点或者 文本节点等等\n\n下一个兄弟元素节点（有兼容性问题） IE9以上才支持当前元素.nextElementSibling 返回当前元素的下一个兄弟元素节点, 找不到返回null\n\n上一个兄弟元素节点（有兼容性问题） IE9以上才支持当前元素.previousElementSibling 返回当前元素上一个兄弟元素节点, 找不到返回null\n\n\n\n02-节点操作补充-兄弟节点.html \n\n创建节点\t🧡document.createElement(“标签名”)  注意: 该方法会返回一个新的”dom对象”\n添加节点\t🧡父节点.appendChild(指定节点) 方法将一个节点添加到指定父节点的子节点列表末尾\n父节点.insertBefore(节点,指定元素)   方法将一个节点添加到父节点的指定子元素前面\n删除节点\t🧡父节点.removeChild(节点)   从父节点中删除一个子节点,返回值是被删除的节点\n或者\n指定节点.remove();  删除指定节点\nbtns[7].onclick = function () &#123;    // 需要先创建节点,才能添加节点    // 创建节点的语法    // document.createElement(&quot;标签名&quot;)    // 注意: document.createElement(&quot;标签名&quot;)会返回一个新的dom对象dom对象dom对象    var newLi = document.createElement(&quot;li&quot;);    newLi.innerText = &quot;小猪佩奇&quot;;    newLi.style.color = &quot;red&quot;;    newLi.onclick = function () &#123;        alert(&quot;大家好, 我是佩奇,我有个弟弟, 叫乔治&quot;);    &#125;    // 添加节点到子元素列表最后    // 父节点对象.appendChild( 被添加的子节点 )    objUl.appendChild(newLi);&#125;;btns[8].onclick = function () &#123;    var newLi = document.createElement(&quot;li&quot;);    newLi.innerText = &quot;喜羊羊&quot;;    newLi.style.color = &quot;blue&quot;;    console.log(objUl);    console.log(objUl.children);    console.log(objUl.children[1]);    console.log(&quot;&quot;);    // 添加节点到指定节点的前面    // 父节点对象.insertBefore(被添加节点, 哪个节点)    objUl.insertBefore(newLi, objUl.children[1]);&#125;;btns[9].onclick = function () &#123;    // 删除节点(删除标签)    // 方式一  父节点.removeChild( 子节点或者子元素节点 )    console.log(objUl.firstElementChild);    objUl.removeChild(objUl.firstElementChild);&#125;;btns[10].onclick = function () &#123;    // 删除节点(删除标签)    // 方式二  指点节点.remove()    console.log(objUl.lastElementChild);    objUl.lastElementChild.remove();&#125;;\n\n\n08-节点操作.html \n\n复制（克隆）节点\n节点.cloneNode( [布尔值] )  克隆节点&#x2F;拷贝节点  返回值是节点的一个副本\n\n注意:\n\n如果括号参数为空或者false,则是浅拷贝节点,即只克隆复制节点本身,不克隆里面的子节点\n如果括号参数为true,则是深度拷贝节点,会复制节点本身以及里面所有的子节点\n\n\n\nvar btns = document.querySelectorAll(&quot;button&quot;);var objUl = document.querySelector(&quot;ul&quot;);btns[0].onclick = function () &#123;    // var cloneLi = objUl.firstElementChild.cloneNode();    var cloneLi = objUl.firstElementChild.cloneNode(false);    console.log(cloneLi);    objUl.appendChild(cloneLi);&#125;btns[1].onclick = function () &#123;    var cloneLi = objUl.firstElementChild.cloneNode(true);    console.log(cloneLi);    objUl.appendChild(cloneLi);&#125;\n\n\n03-节点操作补充-复制（克隆）节点.html \n\njs动态创建元素的三种方式\ndocument.write()\nelement.innerHTML\ndocument.createElement()\n\n区别:\n\ndocument.write是直接将内容写入页面的内容流,但是文档流已经执行完毕,则它会导致页面全部重绘\ninnerHTML是将内容写入某个DOM节点,不会导致页面全部重绘\ninnerHTML创建多个元素效率更好(可以拼接字符串,也可以采取数组形式拼接),结构稍微复杂\ncreateElement()创建多个元素效率稍低一点点,但是结构更清晰\n\n// 举例: 使用三种不同方式创建100个a标签var btns = document.querySelectorAll(&quot;button&quot;);var content = document.querySelector(&quot;.content&quot;);btns[0].onclick = function () &#123;    for (var i = 1; i &lt;= 100; i++) &#123;        document.write(&quot;&lt;a href=&#x27;https://www.taobao.com&#x27;&gt;淘宝&quot; + i + &quot;&lt;/a&gt;&quot;);    &#125;&#125;;btns[1].onclick = function () &#123;    // 数组    var arr = [&#123;        href: &quot;https://www.baidu.com&quot;,        name: &quot;百度&quot;    &#125;, &#123;        href: &quot;https://www.jd.com&quot;,        name: &quot;京东&quot;    &#125;, &#123;        href: &quot;https://www.taobao.com&quot;,        name: &quot;淘宝&quot;    &#125;];    content.innerHTML = arr.map(function (item) &#123;        return &quot;&lt;a href=&#x27;&quot; + item.href + &quot;&#x27;&gt;&quot; + item.name + &quot;&lt;/a&gt;&quot;;    &#125;).join(&quot;&quot;);&#125;;btns[2].onclick = function () &#123;    for (var i = 1; i &lt;= 100; i++) &#123;        // 创建a标签        var newA = document.createElement(&quot;a&quot;);        // 设置a标签的标签内容        newA.innerHTML = &quot;拼多多&quot; + i;        // 设置a标签的href属性        newA.href = &quot;https://www.pinduoduo.com/&quot;;        // 添加到content层中        content.appendChild(newA);    &#125;&#125;;\n\n\n04-js动态创建元素的三种方式.html \n\n根据数据动态生成表格// 数组var datas = [&#123;    name: &#x27;小龙女&#x27;,    subject: &#x27;JavaScript&#x27;,    score: 100&#125;, &#123;    name: &#x27;杨过&#x27;,    subject: &#x27;HTML&#x27;,    score: 98&#125;, &#123;    name: &#x27;陆无双&#x27;,    subject: &#x27;CSS&#x27;,    score: 99&#125;, &#123;    name: &#x27;郭靖&#x27;,    subject: &#x27;Java&#x27;,    score: 88&#125;, &#123;    name: &#x27;黄蓉&#x27;,    subject: &#x27;PHP&#x27;,    score: 20&#125;];// 获取tbody标签对象var tbody = document.querySelector(&quot;tbody&quot;);// 使用数组的map方法var newArr = datas.map(function (item) &#123;    // 定义字符串    var str = &quot;&quot;;    // 拼接    str += &#x27;&lt;tr&gt;&#x27;;    // for...in遍历对象    for (var attr in item) &#123;        str += &#x27;&lt;td&gt;&#x27; + item[attr] + &#x27;&lt;/td&gt;&#x27;;    &#125;    // 拼接    str += &#x27;&lt;td&gt;&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;this.parentNode.parentNode.remove()&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;;    str += &#x27;&lt;/tr&gt;&#x27;;    // 返回str字符串    return str;&#125;);console.log(newArr);// 设置tbody的标签内容tbody.innerHTML = newArr.join(&quot;&quot;);\n\n\n07-课堂练习-根据数据动态生成表格.html \n\n\n08-课堂练习-根据数据动态生成表格.html \n\n事件高级传统注册方式(传统绑定方式)\n传统绑定语法语法dom对象.on事件类型 &#x3D; 匿名函数 或者 有名函数名\n\n传统绑定方式特点\n同一个DOM对象绑定同一个类型事件多次, 后面绑定的事件驱动函数会覆盖前面绑定的\n没有兼容性问题\n事件驱动函数里面this指向绑定事件的那个DOM对象\n\n\n\nvar div1 = document.getElementById(&quot;div1&quot;);div1.onclick = function () &#123;    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;window=&gt;&quot;, window);    console.log(&quot;window === this&quot;, window === this);    console.log(&quot;div1的click事件111111&quot;);    console.log(&quot;&quot;);&#125;function abc() &#123;    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;window=&gt;&quot;, window);    console.log(&quot;window === this&quot;, window === this);    console.log(&quot;div2的click事件&quot;);    console.log(&quot;&quot;);&#125;div1.onclick = abc;\n\n事件监听方式\n语法\ndom对象.addEventListener(“不带on的事件类型” , 匿名函数 或者 有名函数名 );\n\n特点\n\n同一个DOM对象绑定同一个类型事件多次, 会绑定顺序叠加触发事件驱动函数\n有兼容性问题, IE9以及IE9以后的主流浏览器才可以使用该addEventListener监听方式\n在事件驱动函数中,this指向绑定这个事件的DOM对象\n\n\n\nvar div1 = document.getElementById(&quot;div1&quot;);div1.addEventListener(&quot;click&quot;, function () &#123;    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;window=&gt;&quot;, window);    console.log(&quot;window === this =&gt;&quot;, window === this);    console.log(&quot;div1的click事件11111&quot;);    console.log(&quot;&quot;);&#125;);function fn() &#123;    console.log(&quot;我是fn函数&quot;);    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;window=&gt;&quot;, window);    console.log(&quot;window === this =&gt;&quot;, window === this);    console.log(&quot;div2的click&quot;);    console.log(&quot;&quot;);&#125;div2.addEventListener(&quot;click&quot;, fn);\n\nIE9之前事件监听方式  了解\n语法dom对象.attachEvent(“带on的事件类型”, 匿名函数 或者 有名函数名 )\n\n特点\n同一个DOM对象绑定同一个事件多次, 按绑定顺序的倒序叠加执行事件驱动程序\n有兼容问题,需要低版本的IE浏览器才可以使用该绑定方式(IE 5 6 7 8 9 10)\n事件驱动程序中this指向window对象\n\n\n\nvar div1 = document.getElementById(&quot;div1&quot;);div1.attachEvent(&quot;onclick&quot;, function () &#123;    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;window=&gt;&quot;, window);    console.log(&quot;window === this =&gt;&quot;, window === this);    console.log(&quot;div1的click事件11111&quot;);    console.log(&quot;&quot;);&#125;);function fn() &#123;    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;window=&gt;&quot;, window);    console.log(&quot;window === this =&gt;&quot;, window === this);    console.log(&quot;div1的mouseover&quot;);    console.log(&quot;&quot;);&#125;div1.attachEvent(&quot;onmouseover&quot;, fn);\n\n删除事件（解绑事件）\n解绑传统绑定的事件语法\ndom对象.on事件类型 &#x3D; null;\ndiv1.onclick = null;\n\n解绑addEventListener绑定的事件语法\ndom对象.removeEventListener(“不带on事件类型”, 有名函数名 )\ndiv2.removeEventListener(&quot;click&quot;, fn);\n\n解绑attachEvent绑定的事件语法\ndom对象.detachEvent(“带on事件类型”, 有名函数名 )\ndiv3.detachEvent(&quot;onclick&quot;, fn4);\n\n手动触发指定DOM对象的指定事件\n语法一 手动触发传统绑定方式   要记\ndom对象.on事件类型()  可以手动触发传统绑定的事件\n比如: \ndom对象.onclick();\n\n\nvar objDiv = document.querySelector(&quot;div&quot;);objDiv.onclick = function () &#123;    this.innerText = &quot;div被点击了&quot;    this.style.backgroundColor = &quot;skyblue&quot;;&#125;var btns = document.querySelectorAll(&quot;button&quot;);btns[0].onclick = function () &#123;    objDiv.onclick();&#125;\n\n事件模型(DOM事件流)\n事件\n事件是HTML和Javascript交互的驱动器, 事件是文档或者浏览器窗口中发生的， 特定的交互瞬间。\n事件是用户或浏览器自身执行的某种动作， 如 click, load 和 mouseover 都是事件的名字。\n事件是 javaScript 和 DOM 之间交互的桥梁。\n\n\n事件流事件流, 即是一个事件发生的流程或者说流转, 从开始到结束, 都发生了什么\n事件发生时会在元素节点之间按照特定的顺序传播, 这个传播过程, 我们就称之为DOM事件流.\n\n事件流有三个阶段\n捕获阶段 Capture Phase; 从上到下, 层层传递, 直到目标接收\n目标阶段 Target Phase; 确认目标, 进行处理\n冒泡阶段 Bubbling Phase; 处理结束, 往上传递.\n\n\n先捕获阶段&#x3D;&gt;目标阶段&#x3D;&gt;冒泡阶段\n注意: 监听绑定方式addEventListener()方法中第三个参数可以控制是在冒泡阶段触发还是在捕获阶段触发\n\n注意:\nJS代码建议执行捕获或者冒泡两个阶段中的其中一个阶段\n传统绑定事件方式跟attachEvent绑定事件的方式只能得到”冒泡阶段”\naddEventListener(type,listener,[,useCapture])第三个参数如果是true,表示在事件捕获阶段调用事件处理程序;  如果是false(默认不写就是false),表示事件冒泡阶段调用事件处理程序.\n实际开发中我们很少使用事件捕获,我们更关注事件冒泡.\n另外需要注意, 不是所有事件都会冒泡的, 有些事件是没有冒泡的,比如onmouseenter,onmouseleave\n事件冒泡有时候会带来麻烦,有时候又会帮助我们很巧妙的做某些事件,我们会学习事件委托,事件委托(事件代理)的原理就是事件冒泡\n\n\n冒泡阶段触发,需要HTML标签是”嵌套关系(父子关系)”, 而且需要都绑定事件, 接着,触发子元素事件(子元素事件不触发也可以)的时候,  会逐级向上传播, 把父辈元素相同的事件也会触发\n\n\n\n01-事件模型(DOM事件流)介绍以及冒泡阶段.html \n02-捕获阶段.html \n03-IE低版本浏览器绑定方式的事件流.html \n\n逻辑与&amp;&amp; 以及 逻辑或|| 的高级用法\n逻辑或 以及 逻辑与 的高级用法( 主要看&amp;&amp; || 前面第一个值转成布尔以后 是真值还是假值 )\n\n&amp;&amp;逻辑与的高级用法  逻辑与,假前真后只要”&amp;&amp;”前面类型转换以后的值为false，无论”&amp;&amp;”后面是true还是false，结果都将返”&amp;&amp;”前面的值;\n只要”&amp;&amp;”前面类型转换以后的值为true，无论”&amp;&amp;”后面是true还是false，结果都将返”&amp;&amp;”后面的值;\nconsole.log(10 &amp;&amp; &quot;abc&quot;);   //abcconsole.log(undefined &amp;&amp; &quot;abc&quot;);    //undefinedconsole.log(-5 &amp;&amp; 6);   //6\n\n||逻辑或的高级用法\t逻辑或, 真前假后只要”||”前面类型转换以后的值为false, 不管”||”后面是true 还是 false，都返回 “||” 后面的值。\n只要”||”前面类型转换以后的值为true,  不管“||”后面是true 还是 false，都返回 “||” 前面的值。\nconsole.log(undefined || 123); // 123console.log(&quot;&quot; || 123); // 123console.log(&quot; &quot; || 123); // &quot; &quot;console.log(true || 123); // trueconsole.log(false || 123); // 123console.log(&quot;abc&quot; || 123); // &quot;abc&quot;console.log(NaN || 456); // 456\n\n事件对象的属性和方法\n\n\n属性&#x2F;方法\n描述\n\n\n\ne.target\n返回触发事件的对象。标准属性。 🧡\n\n\ne.srcElement\n返回触发事件的对象。非标准属性，IE6~8使用。\n\n\ne.type\n返回事件的类型字符串，例如 “click”、”mouseover”，不包含”on”前缀。\n\n\ne.stopPropagation()\n阻止事件冒泡的方法。标准方法。 🧡\n\n\ne.cancelBubble &#x3D; true\n阻止事件冒泡的属性，非标准属性，IE6~8使用。\n\n\ne.preventDefault()\n阻止默认事件（默认行为）的方法。标准方法，例如阻止链接跳转。 🧡\n\n\ne.returnValue &#x3D; false\n阻止默认事件（默认行为）的属性，非标准属性，IE6~8使用。\n\n\nevent(事件对象)详解参考  https://www.cnblogs.com/websmile/p/8807334.html\n阻止事件冒泡// 阻止事件冒泡兼容写法if (e.stopPropagation) &#123;    e.stopPropagation();&#125; else &#123;    e.cancelBubble = true;&#125;\n\n\n07-阻止事件冒泡.html \n\n阻止默认行为默认行为的意思就是浏览器对于某些标签本身会有一些行为,比如a标签, 设置了href属性以后,点击a标签会跳转\nvar myLink = document.getElementById(&quot;myLink&quot;);myLink.onclick = function (e) &#123;    console.log(&quot;hello&quot;);    e = e || window.event;    // 阻止默认行为    // console.log(&quot;e.preventDefault=&gt;&quot;, e.preventDefault);    // e.preventDefault();    // e.returnValue = false;    // 阻止默认行为    if (e.preventDefault) &#123;        // IE9以及IE9以上浏览器阻止默认行为        e.preventDefault();    &#125; else &#123;        // IE9以下浏览器阻止默认行为        e.returnValue = false;    &#125;&#125;\n\n事件委托\n什么是事件委托(事件代理), 就是本身要给子元素绑定的事件, 不给子元素绑定,  而是给父辈元素绑定\n\n事件委托的原理: 冒泡\n\n事件委托的作用: 可以给动态新增的元素绑定事件\n\n\nobjUl.onclick = function (e) &#123;    /* console.log(&quot;ul的click事件&quot;);            console.log(&quot;this=&gt;&quot;, this);            console.log(&quot;e.target=&gt;&quot;, e.target);            // nodeName获取节点名称            console.log(&quot;e.target.nodeName=&gt;&quot;, e.target.nodeName);            // tagName获取标签名称            console.log(&quot;e.target.tagName=&gt;&quot;, e.target.tagName);            e.target.style.color = &quot;red&quot;;            console.log(&quot;&quot;); */    if (e.target.nodeName === &quot;LI&quot;) &#123;        for (var i = 0; i &lt; this.children.length; i++) &#123;            this.children[i].style.color = &quot;black&quot;;            this.children[i].style.fontSize = &quot;16px&quot;;        &#125;        e.target.style.color = &quot;red&quot;;        e.target.style.fontSize = &quot;30px&quot;;    &#125;&#125;\n\n\n09-事件委托(事件代理).html \n\njs三大家族属性三大系列属性,这三个系列属性可以获取宽度高度以及相应的距离\n注意: 三大系列属性返回值都是’数值’,不带单位, 只能”获取”,不能”设置”\n元素可视区 client\n\n\n属性\n描述\n\n\n\ndom对象.clientWidth\nwidth + 左padding + 右padding\n\n\ndom对象.clientHeight\nheight + 上padding + 下padding\n\n\ndom对象.clientLeft\n左边框的大小\n\n\ndom对象.clientTop\n上边框的大小\n\n\n\n[05-js三大家族-元素可视区 client.html](....\\web\\每日代码\\25_DOM\\05-js三大家族-元素可视区 client.html) \n\n元素偏移量 offset\n\n\n属性\n描述\n\n\n\ndom对象.offsetWidth\n返回自身包括padding、边框、内容区的总宽度，返回数值不带单位，其实就是盒子的真实宽度\n\n\ndom对象.offsetHeight\n返回自身包括padding、边框、内容区的总高度，返回数值不带单位，其实就是盒子的真实高度\n\n\ndom对象.offsetParent\n返回作为该元素带有”非静态定位最近”的父辈元素，如果父辈元素都没有非静态定位则返回”body”元素\n\n\ndom对象.offsetLeft\n返回元素相对带有”非静态定位最近”的父辈元素左方的偏移量，如果父辈都没有定位则返回相对”body”的”左”方偏移量\n\n\ndom对象.offsetTop\n返回元素相对带有”非静态定位最近”的父辈元素上方的偏移量，如果父辈都没有定位则返回相对”body”的”上方”偏移量\n\n\n\n06-js三大家族-元素偏移量offset.html \n\n元素滚动 scroll\n\n\n属性\n描述\n\n\n\ndom对象.scrollWidth\n返回自身实际的宽度,不含边框,返回数值不带单位\n\n\ndom对象.scrollHeight\n返回自身实际的高度,不含边框,返回数值不带单位\n\n\ndom对象.scrollLeft\n返回被卷去的左侧距离,返回数值不带单位\n\n\ndom对象.scrollTop\n返回被卷去的顶部距离,返回数值不带单位\n\n\nwindow.pageXOffset\nhtml对象获取水平滚动条距离 IE9以及IE9以上主流浏览器可以使用\n\n\nwindow.pageYOffset\nhtml对象获取垂直滚动条距离 IE9以及IE9以上主流浏览器可以使用\n\n\n\nbody对象获取垂直滚动条距离\nconsole.log(&quot;body对象获取垂直滚动条距离:&quot; + document.body.scrollTop);\n\nbody对象获取水平滚动条距离\nconsole.log(&quot;body对象获取水平滚动条距离:&quot; + document.body.scrollLeft);\n\nhtml对象获取垂直滚动条距离\nconsole.log(&quot;html对象获取垂直滚动条距离:&quot; + document.documentElement.scrollTop);\n\nhtml对象获取水平滚动条距离\nconsole.log(&quot;html对象获取水平滚动条距离:&quot; + document.documentElement.scrollLeft);\n\n封装一个兼容写法 获取页面滚动的距离\nfunction getScroll() &#123;    return &#123;        x: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft,        y: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop    &#125;&#125;\n\n\n[10-js三大家族-元素滚动 scroll.html](....\\web\\每日代码\\25_DOM\\10-js三大家族-元素滚动 scroll.html) \n\n鼠标事件对象鼠标事件中常用的属性及其描述：\n\n\n\n属性\n描述\n\n\n\ne.clientX\n返回鼠标相对于浏览器窗口可视区（不包括滚动条距离）的X坐标\n\n\ne.clientY\n返回鼠标相对于浏览器窗口可视区（不包括滚动条距离）的Y坐标\n\n\ne.pageX\n返回鼠标相对于文档页面（包括滚动条距离）的X坐标，IE9+支持\n\n\ne.pageY\n返回鼠标相对于文档页面（包括滚动条距离）的Y坐标，IE9+支持\n\n\ne.offsetX\n返回鼠标指针相对于目标节点内边（元素内）位置的X坐标\n\n\ne.offsetY\n返回鼠标指针相对于目标节点内边（元素内）位置的Y坐标\n\n\ne.screenX\n返回鼠标相对于电脑屏幕的X坐标\n\n\ne.screenY\n返回鼠标相对于电脑屏幕的Y坐标\n\n\n注意:  e.pageX&#x2F;e.pageY 鼠标在页面中的位置 有兼容性问题 从IE9以后才支持\n参考文档:  https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent\n**扩展:**IE无法兼容pageX&#x2F;pageY解决参考:  https://www.cnblogs.com/mushuizzz/p/11847172.html\n获取鼠标在盒子内的坐标var objDiv = document.querySelector(&quot;div&quot;);// 给div绑定鼠标移动事件objDiv.onmousemove = function (e) &#123;    // console.log(e.offsetX, e.offsetY);    // console.log(e.clientX - objDiv.offsetLeft, e.clientY - objDiv.offsetTop);    // console.log(e.pageX - objDiv.offsetLeft, e.pageY - objDiv.offsetTop);        // this.innerText = &quot;x坐标是&quot; + (e.clientX - objDiv.offsetLeft) + &quot; y坐标是 &quot; + (e.clientY - objDiv.offsetTop);    this.innerText = &quot;x坐标是&quot; + e.offsetX + &quot; y坐标是 &quot; + e.offsetY;&#125;\n\n获取计算以后样式属性值 window.getComputedStyle\n通过 dom对象.style.css属性名 的方法获取的样式只能是行内式样式属性值  内嵌式和外链式样式都无法获取\n\n获取计算以后样式属性值 window.getComputedStyle( element, [pseudoElt] )  该方法返回一个对象\n\n参数说明\n\nelement 用于获取计算样式的Element, 就是DOM对象\npseudoElt 可选 指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle\n\n\nconsole.log(window.getComputedStyle(myDiv));console.log(window.getComputedStyle(myDiv)[&quot;color&quot;]);console.log(window.getComputedStyle(myDiv).color);console.log(window.getComputedStyle(myDiv, null).color);console.log(window.getComputedStyle(myDiv, &quot;::after&quot;).color);\n\n\n[02-获取计算以后样式属性值 window.getComputedStyle.html](....\\web\\每日代码\\26_DOM\\02-获取计算以后样式属性值 window.getComputedStyle.html) \n\n延时器和定时器\n延时器和定时器的方法都属于window对象\n参数说明\nfunction 是你想要在到期时间 (delay毫秒) 之后执行的函数。\ndelay 延迟的毫秒数, 取值数值, 单位是毫秒  一秒等于 1000 毫秒\n\n\n延时器, 延迟多久以后, “仅执行一次”指定的代码块全局的 setTimeout() 方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。\n\n开启延时器语法window.setTimeout( function, delay )\n返回值timeoutID是一个正整数，表示延时器的编号。这个值可以传递给clearTimeout()来取消该延时器。\n\n清除延时器语法clearTimeout( timeoutID ) 方法取消了先前通过调用setTimeout()建立的定时器。\n参数说明: timeoutID 您要取消定时器的标识符。该 ID 由相应的setTimeout()调用返回。\n\n\nvar btns = document.querySelectorAll(&quot;button&quot;);function fn1() &#123;    console.log(&quot;我是fn1函数~~~&quot;);&#125;var timeoutID1 = null;var timeoutID2 = null;btns[0].onclick = function () &#123;    if (timeoutID1 === null) &#123;        // 匿名函数        timeoutID1 = window.setTimeout(function () &#123;            console.log(&quot;hello&quot;);        &#125;, 3000);    &#125;    if (timeoutID2 === null) &#123;        // 有名函数        timeoutID4 = window.setTimeout(fn1, 2000);    &#125;&#125;;btns[1].onclick = function () &#123;    window.clearTimeout(timeoutID1);    window.clearTimeout(timeoutID2);&#125;;\n\n\n03-延时器.html \n\n\n定时器, 每隔指定时间, 就执行一次指定的代码块 不断重复执行setInterval() 方法重复调用一个函数或执行一个代码片段，在每次调用之间具有固定的时间间隔。\n\n开启定时器语法window.setInterval(function, delay);\n返回值一个 interval ID，该 ID 唯一地标识时间间隔，因此你可以稍后通过调用 clearInterval() 来移除定时器。\n\n清除定时器语法window.clearInterval(intervalID);\n\n\nfunction fn() &#123;    console.log(&quot;fn函数&quot;);&#125;var intervalID1 = null;var intervalID2 = null;var btns = document.querySelectorAll(&quot;button&quot;);btns[0].onclick = function () &#123;    if (intervalID1 === null) &#123;        intervalID1 = window.setInterval(function () &#123;            console.log(&quot;hello&quot;);        &#125;, 500);    &#125;    if (intervalID2 === null) &#123;        intervalID2 = window.setInterval(fn, 2000);    &#125;&#125;btns[1].onclick = function () &#123;    window.clearInterval(intervalID1);    window.clearInterval(intervalID2);    intervalID1 = null;    intervalID2 = null;&#125;\n\n\n04-定时器.html \n\n顶级对象windowwindow对象是浏览器的顶级对象,它具有双重角色.\n\n它是JS访问浏览器窗口的一个接口.\n它是一个全局对象. 定义在全局作用域中的变量、函数会变成window对象的属性和方法\n在调用的时候可以省略window, 比如我们前面学习alert(),prompt()都属于window对象的方法\n**注意:**window对象下有一个特殊属性window.name,  window.name的属性值是一个字符串\nwindow.top属性也是window对象中一个内置属性, 它的属性值是指向回window对象自身  top属性值修改不了\n\n\n避免使用name和top作为变量名name作为变量名的时候, name的值一定会被改成字符串类型\nvar name = 123;console.log(name, typeof name);var name = true;console.log(name, typeof name);console.log(&quot;&quot;);console.log(&quot;&quot;);\n\ntop变量名的值会一直指向window对象自身 修改不了\nconsole.log(&quot;top=&gt;&quot;, top);console.log(&quot;top === window =&gt;&quot;, top === window);var top = 10;console.log(&quot;top=&gt;&quot;, top);var top = false;console.log(&quot;top=&gt;&quot;, top);console.log(&quot;&quot;);console.log(&quot;&quot;);\n\nwindow对象的属性\n\n\n属性\n功能\n\n\n\nwindow.innerWidth\n获取浏览器内部的宽度，不包含浏览器的左右两边边框。\n\n\nwindow.innerHeight\n获取浏览器内部的高度，不包含浏览器的菜单栏、地址栏以及上下的边框。\n\n\nwindow.outerWidth\n获取整个浏览器的宽度，包括浏览器的边框。\n\n\nwindow.outerHeight\n获取整个浏览器的高度，包括浏览器的边框。\n\n\n确认框window.confirm(&quot;提示信息&quot;);\n\n封装缓动框架// 封装一个获取计算以后样式属性值的方法function getStyle(dom, attr) &#123;    return window.getComputedStyle(dom)[attr];&#125;// 版本三: 封装缓动框架(添加回调函数)/** * 封装元素js缓慢动画框架 * 参数1 &#123;object&#125; dom  要做动画的dom对象 * 参数2 &#123;object&#125; obj 要做动画的一对或者多对CSS属性名和目标值 组成的对象 * 参数3 可选参数 &#123;function&#125; callback  动画完成以后,要调用的函数  回调函数就是满足一定条件才调用的函数 */function animate(dom, obj, callback) &#123;    // 清除之前的定时器    clearInterval(dom.intervalId);    // 开启定时器    dom.intervalId = setInterval(function () &#123;        // 在定时器内部定义一个变量, 保存是否所有CSS属性都达到了目标值        var flag = true; // 假设所有属性已经达到了目标        // for...in遍历obj对象    attr就是css属性名        for (var attr in obj) &#123;            // opacity属性特殊处理            if (attr == &quot;opacity&quot;) &#123;                // 获取目标值                var target = obj[attr] * 100;                // 获取当前dom的attr对应的属性值                var curVal = parseFloat(getStyle(dom, attr)) * 100;                // 判断是否达到目标值                if (curVal != target) &#123; // 如果没有达到                    // 修改flag变量的值                    flag = false;                &#125;                // 缓慢动画的意思就是速度由快变慢, 运动速度越来越慢                // 缓慢动画公式:  速度 = ( 目标值 - 当前值 ) / 10;                var speed = (target - curVal) / 10;                // 因为速度有可能得到小数, 小数会导致我们无法达到目标值, 所以需要对速度进行取整                speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);                // 设置dom对象对应的attr属性值                dom.style[attr] = (curVal + speed) / 100;            &#125; else if (attr == &quot;z-index&quot; || attr == &quot;zIndex&quot;) &#123;                //  z-index或者zIndex属性特殊处理                dom.style[attr] = obj[attr];            &#125; else &#123;                // 获取目标值                var target = obj[attr];                // 获取当前dom的attr对应的属性值                var curVal = parseFloat(getStyle(dom, attr));                // 判断是否达到目标值                if (curVal != target) &#123; // 如果没有达到                    // 修改flag变量的值                    flag = false;                &#125;                // 缓慢动画的意思就是速度由快变慢, 运动速度越来越慢                // 缓慢动画公式:  速度 = ( 目标值 - 当前值 ) / 10;                var speed = (target - curVal) / 10;                // 因为速度有可能得到小数, 小数会导致我们无法达到目标值, 所以需要对速度进行取整                speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed);                // 设置dom对象对应的attr属性值                dom.style[attr] = curVal + speed + &quot;px&quot;;            &#125;        &#125;        // for...in结束,就表示所有属性都遍历完毕了        if (flag) &#123; // 判断flag的值            // 清除定时器            clearInterval(dom.intervalId);            // 动画完成了,所以我们可以调用回调函数, 前提是存在回调函数            if (callback !== undefined &amp;&amp; typeof callback === &quot;function&quot;) &#123;                callback();            &#125;        &#125;    &#125;, 15);&#125;\n\nJSON数据格式\n什么是JSON数据格式JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。由于其利于阅读和编写、同时也方便机器进行解析和生成。这使得JSON成为最理想的数据交换语言。\n\nJSON数据格式的应用场景JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。由于其利于阅读和编写、同时也方便机器进行解析和生成。这使得JSON成为最理想的数据交换语言。\n\nJSON格式的定义语法(定义JSON对象)&#123;  &quot;name&quot;:&quot;Mark&quot;,  &quot;age&quot;:18,  &quot;mobile&quot;:&quot;13586007445&quot;&#125;\n\nJSON对象与JS对象的区别\nJSON格式的数据，其键名必须使用”双引号”引起来\n\nJSON格式的数据，”不能出现成员方法，只能是成员属性”\n\nJSON格式的数据, 最后一个逗号不能写\n\n\n\n**注意：**访问JSON对象的属性, 跟访问JS对象的属性方式一样\n​      遍历JSON对象的属性, 跟遍历JS对象的属性方式一样\n// 访问json对象属性console.log(obj.id);console.log(obj.name);console.log(obj.age);console.log(obj[&quot;id&quot;]);console.log(obj[&quot;name&quot;]);console.log(obj[&quot;age&quot;]);console.log(&quot;&quot;);console.log(&quot;&quot;);// 遍历json对象属性for (var attr in obj) &#123;    console.log(&quot;attr=&gt;&quot;, attr);    console.log(&quot;obj[attr]=&gt;&quot;, obj[attr]);    console.log(&quot;&quot;);&#125;\n\nJSON数组JSON数组意思就是把JSON对象放在一个数组里面\n\nJSON格式的字符串与JS对象的转换\t🧡json对象转成json字符串   JSON.stringify(json对象)\nvar jsonStr = JSON.stringify(obj);console.log(jsonStr, typeof jsonStr);\n\njson字符串转成json对象    JSON.parse(json字符串)\nvar obj2 = JSON.parse(jsonStr);console.log(obj2, typeof obj2);\n\nBOM（Browser object model 浏览器对象模型）BOM 介绍\nBOM( Browser object model 浏览器对象模型) 提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window对象。\nBOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。\nBOM的构成; BOM 比 DOM 更大，因为它包含 DOM。\nBOM的核心对象是window, window包含document,location,navigator,screen,history\n\nBOM中的location对象\n什么是location对象window对象给我们提供了一个location属性用于”获取”或”设置”浏览器的URL(网址),并且可以用于解析URL.因为这个属性返回的是一个对象,所以我们将这个属性也称为location对象\n\nURL介绍  了解统一资源定位符(Uniform Resource Locaotr,URL) 是互联网上标准资源的地址. 互联网上的每个文件都有一个唯一的URL,它包含的信息指出文件的位置以及浏览器应该怎么处理它.(url可以简单理解为是某个网址)\n\nURL的一般语法格式如下:protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment\n**例：**https://www.mi.com/shop/buy/detail?product_id=10000203&amp;selected=10000203#bottom\n\n一个URL由以下几部分组成:\n\n\n\n组成部分\n说明\n\n\n\nprotocol\n通信协议，常见的有http://、https://、ftp://等\n\n\nhost\n主机(域名)，例如：www.mi.com\n\n\nport\n端口号，可选，省略时会使用默认端口，比如http协议默认端口为80;  https协议默认端口为443\n\n\npath\n路径，由零个或多个/符号隔开的字符串，一般用来表示主机上的一个目录或者文件地址 比如”&#x2F;shop&#x2F;buy&#x2F;detail”\n\n\nquery\n参数，以键值对的形式通过 &amp; 符号分隔开\n\n\nfragment\n片段，以 # 后面的内容为标识，常见于链接的锚点\n\n\n\n\nlocation对象的属性\n\n\n属性\n返回值\n\n\n\nlocation.href\n获取或设置URL\t🧡\n\n\nlocation.protocol\n获取通信协议，常见的有http:、https:等\n\n\nlocation.host\n返回主机(域名)\n\n\nlocation.port\n返回端口号，如果没有写则返回空字符串\n\n\nlocation.pathname\n返回路径\n\n\nlocation.search\n返回参数\t🧡\n\n\nlocation.hash\n返回片段(#)后面的内容，常见于链接的锚点\n\n\nlocation对象的常见方法\n\n\n方法\n返回值\n\n\n\nlocation.assign(网址)\n跳转页面并记录浏览历史，可实现后退功能\n\n\nlocation.replace(网址)\n替换当前页面，不记录浏览历史，无法后退\n\n\nlocation.reload()\n重新加载页面，相当于刷新，返回值为undefined\n\n\nlocation.reload(true)\n强制重新加载页面，无视缓存，返回值为undefined\n\n\nBOM中的history对象\nwindow对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。\n注意:  如果想要使用history对象,那么浏览器必须有历史记录\n\n\nhistory对象方法\n\n\n方法\n功能\n\n\n\nhistory.back()\n后退到上一个页面\n\n\nhistory.forward()\n前进到下一个页面\n\n\nhistory.go(n)\n前进或后退n个页面，其中n为正值表示前进，n为负值表示后退\n\n\n例：history.go(1)代表前进一个页面; history.go(-1)代表后退一个页面;\t🧡\n注意:\nhistory.go(1)  等价于  history.forward()\nhistory.go(-1) 等价于  history.back()\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/API/History\n\nBOM中的navigator对象navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 navigator.userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。(也就是返回当前浏览器的用户代理。)\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator\nBOM中的screen对象参考文档:  https://developer.mozilla.org/zh-CN/docs/Web/API/Screen\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"CSS3 学习笔记","url":"/2023/07/06/CSS3/","content":"\n参考文档:CSS教程（精讲版） (biancheng.net)\n单位绝对长度单位以下都是绝对长度单位——它们与其他任何东西都没有关系，通常被认为总是相同的大小。\n\n\n\n单位\n名称\n等价换算\n\n\n\ncm\n厘米\n1cm &#x3D; 37.8px &#x3D; 25.2&#x2F;64in\n\n\nmm\n毫米\n1mm &#x3D; 1&#x2F;10th of 1cm\n\n\nQ\n四分之一毫米\n1Q &#x3D; 1&#x2F;40th of 1cm\n\n\nin\n英寸\n1in &#x3D; 2.54cm &#x3D; 96px\n\n\npc\n派卡\n1pc &#x3D; 1&#x2F;6th of 1in\n\n\npt\n点\n1pt &#x3D; 1&#x2F;72th of 1in\n\n\npx\n像素\n1px &#x3D; 1&#x2F;96th of 1in\n\n\n相对长度单位相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，你可以使文本或其他元素的大小与页面上的其他内容相对应。下表列出了 web 开发中一些最有用的单位。\n\n\n\n单位\n相对于\n\n\n\nem\n在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。\n\n\nex\n字符“x”的高度。\n\n\nch\n数字“0”的宽度。\n\n\nrem\n根元素的字体大小。\n\n\nlh\n元素的行高。\n\n\nrlh\n根元素的行高。当用于根元素的 font-size 或 line-height 属性时，它指的是这些属性的初始值。\n\n\nvw\n视口宽度的 1%。\n\n\nvh\n视口高度的 1%。\n\n\nvmin\n视口较小尺寸的 1%。\n\n\nvmax\n视口大尺寸的 1%。\n\n\nvb\n在根元素的块向上，初始包含块的尺寸的 1%。\n\n\nvi\n在根元素的行向上，初始包含块的尺寸的 1%。\n\n\nsvw、svh\n分别为视口较小尺寸的宽度和高度的 1%。\n\n\nlvw、lvh\n分别为视口大尺寸的宽度和高度的 1%。\n\n\ndvw、dvh\n分别为动态视口的宽度和高度的 1%。\n\n\n\n参考文档:CSS 的值与单位 - 学习 Web 开发 | MDN (mozilla.org)\n\n&lt;angle&gt; (角的大小)CSS 数据类型 &lt;angle&gt; 用于表示角的大小，单位为度（degrees）、百分度（gradians）、弧度（radians）或圈数（turns）。在 gradient 和 transform 的某些方法等场景中有所应用。\n\n单位\ndeg\n度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。\n\ngrad\n百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。\n\nrad\n弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180&#x2F;π 度。例：0rad，1.0708rad，6.2832rad。\n\nturn\n圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。\n\n示例\n\n\n\n\n\n\n\n直角：90deg = 100grad = 0.25turn ≈ 1.5708rad\n\n\n\n\n平角：180deg = 200grad = 0.5turn ≈ 3.1416rad\n\n\n\n直角（逆时针）：-90deg = -100grad = -0.25turn ≈ -1.5708rad\n\n\n\n零角：0 = 0deg = 0grad = 0turn = 0rad\n\n\n\n参考文档: - CSS：层叠样式表 | MDN (mozilla.org)\n\n媒体查询1. 媒体类型媒体类型用来表示设备的类别，CSS 中提供了一些关键字来表示不同的媒体类型，如下表所示：\n\n\n\n媒体类型\n描述\n\n\n\nall\n表示所有的媒体设备\n\n\naural\n表示语音和音频合成器（听觉设备）\n\n\nbraille\n表示盲人用点字法触觉回馈设备\n\n\nembossed\n表示盲人用点字法打印机\n\n\nhandheld\n表示小型手持设备，如手机、平板电脑\n\n\nprint\n表示打印机\n\n\nprojection\n表示投影设备\n\n\nscreen\n表示电脑显示器\n\n\ntty\n表示使用固定密度字母栅格的媒体，比如打字机或终端设备\n\n\ntv\n表示电视机类型的设备\n\n\n2. 媒体特性除了具体的类型外，还可以通过一些属性来描述设备的具体特征，例如宽度、高度、分辨率等，如下表所示：\nCSS媒体查询（@media）全面解析 (biancheng.net)\n\n\n\n值\n描述\n\n\n\naspect-ratio\n输出设备页面可见区域的宽高比\n\n\ncolor\n输出设备每个像素的比特值，常见的有 8、16、32 位。如果设备不支持输出彩色，则该值为 0\n\n\ncolor-index\n输出设备的颜色查询表中的条目数量。如果没有使用颜色查询表，则该值等于 0\n\n\ndevice-aspect-ratio\n输出设备的宽高比\n\n\ndevice-height\n输出设备屏幕的可见高度\n\n\ndevice-width\n输出设备屏幕的可见宽度\n\n\ngrid\n查询输出设备使用的是网格屏幕还是点阵屏幕\n\n\nheight\n页面可见区域的高度\n\n\nmax-aspect-ratio\n输出设备屏幕可见区域宽度与高度的最大比率\n\n\nmax-color\n输出设备每个像素比特值的最大值\n\n\nmax-color-index\n输出设备的颜色查询表中的最大条目数\n\n\nmax-device-aspect-ratio\n输出设备屏幕可见区域宽度与高度的最大比率\n\n\nmax-device-height\n输出设备屏幕可见区域的最大高度\n\n\nmax-device-width\n输出设备屏幕的最大可见宽度\n\n\nmax-height\n页面可见区域的最大高度\n\n\nmax-monochrome\n输出设备单色帧缓冲区中每个像素的最大位深度。如果设备并非黑白屏幕，则该值为 0\n\n\nmax-resolution\n设备的最大分辨率\n\n\nmax-width\n页面可见区域的最大宽度\n\n\nmin-aspect-ratio\n输出设备屏幕可见区域宽度与高度的最小比率\n\n\nmin-color\n输出设备每个像素比特值的最小值\n\n\nmin-color-index\n输出设备的颜色查询表中的最小条目数\n\n\nmin-device-aspect-ratio\n输出设备的屏幕可见区域宽度与高度的最小比率\n\n\nmin-device-width\n输出设备的屏幕的最小可见宽度\n\n\nmin-device-height\n输出设备的屏幕的最小可见高度\n\n\nmin-height\n页面可见区域的最小高度\n\n\nmin-monochrome\n输出设备单色帧缓冲区中每个像素的最小位深度。如果设备并非黑白屏幕，则该值为 0\n\n\nmin-resolution\n设备的最小分辨率\n\n\nmin-width\n页面可见区域的最小宽度\n\n\nmonochrome\n输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为 0\n\n\norientation\n页面可见区域的旋转方向\n\n\nresolution\n设备的分辨率。如：96dpi、300dpi、118dpcm\n\n\nscan\n电视类设备的扫描工序\n\n\nwidth\n页面可见区域的宽度\n\n\n3. 逻辑操作符逻辑操作符包含 not、and 和 only 三个，通过逻辑操作符可以构建复杂的媒体查询，您还可以通过逗号来分隔多个媒体查询，将它们组合为一个规则。\n\n\n\n值\n描述\n\n\n\nand\n规定一个 AND 运算符。\n\n\nnot\n规定一个 NOT 运算符。\n\n\n,\n规定一个 OR 运算符。\n\n\nonly\nonly关键字可防止不支持带有媒体功能的媒体查询的旧版浏览器应用给定的样式。提升老版本浏览器兼容性,它对现代浏览器没有影响。\n\n\n4. 定义媒体查询目前您可以通过以下两种方式来定义媒体查询：\n\n使用 @media 或 @import 规则在样式表中指定对应的设备类型；\n用 media 属性在 &lt;style&gt;、&lt;link&gt;、&lt;source&gt; 或其他 HTML 元素中指定特定的设备类型。\n\n@media在《CSS @规则》一节中我们已经简单了解 @media，使用 @media 您可以指定一组媒体查询和一个 CSS 样式块，当且仅当媒体查询与正在使用的设备匹配时，指定的 CSS 样式才会应用于文档。示例代码如下：\n/* 在小于或等于 992 像素的屏幕上，将背景色设置为蓝色 */@media screen and (max-width: 992px) &#123;    body &#123;        background-color: blue;    &#125;&#125;/* 在 600 像素或更小的屏幕上，将背景色设置为橄榄色 */@media screen and (max-width: 600px) &#123;    body &#123;        background-color: olive;    &#125;&#125;\n\n媒体查询 4 级规范对语法进行了一些改进，以使用具有“范围”类型（例如宽度或高度，减少冗余）的功能进行媒体查询。\n@media (max-width: 30em) &#123; ... &#125;\n\n在媒体查询 4 级规范可以这样写：\n@media (width &lt;= 30em) &#123; ... &#125;\n\n使用min-和max-可以测试一个在两个值之间的宽度\n@media (min-width: 30em) and (max-width: 50em) &#123; ... &#125;\n\n用 4 级语法书写如下\n@media (30em &lt;= width &lt;= 50em ) &#123; ... &#125;\n\n例子\n@media screen and (500px &lt; width &lt; 1200px) and (200px&lt; height&lt;400px) &#123;    body &#123;        background-color: black;    &#125;&#125;\n\n\n**参考文档:**https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries\n\n@import@import 用来导入指定的外部样式文件并指定目标的媒体类型，示例代码如下：\n@import url(&quot;css/screen.css&quot;) screen;   /* 引入外部样式，该样式仅会应用于电脑显示器 */@import url(&quot;css/print.css&quot;) print;     /* 引入外部样式，该样式仅会应用于打印设备 */body &#123;    background: #f5f5f5;    line-height: 1.2;&#125;\n\n注意：所有 @import 语句都必须出现在样式表的开头，而且在样式表中定义的样式会覆盖导入的外部样式表中冲突的样式。\nlink中的media 属性您还可以在 &lt;style&gt;、&lt;link&gt;、&lt;source&gt; 等标签的 media 属性中来定义媒体查询，示例代码如下：\n/* 当页面宽度大于等于 900 像素时应用该样式 */&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (min-width: 900px)&quot; href=&quot;widescreen.css&quot;&gt;/* 当页面宽度小于等于 600 像素时应用该样式 */&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-width: 600px)&quot; href=&quot;smallscreen.css&quot;&gt;\n\n\n\ncurrentColor概念：currentColor 关键字代表元素文本颜色 color属性的属性值。它还用于为接受颜色值的任何其他属性提供潜在的默认值（currentColor）。\n\n注意：如果在“color”属性本身上设置了“currentColor”关键字，则它将被视为“color:inherit”。\n\n&lt;div style=&quot;color:blue;background-color: red; border: 1px dashed currentcolor;&quot;&gt;    The color of this text is blue.    &lt;div style=&quot;background:currentcolor; height:9px;&quot;&gt;&lt;/div&gt;    This block is surrounded by a blue border.&lt;/div&gt;\n\n\n\n圆角边框在制作网页的过程中，有时我们可能需要实现圆角的效果，以前的做法是通过切图（将设计稿切成便于制作成页面的图片），使用多个背景图像来实现圆角。在 CSS3 出现之后就不需要这么麻烦了，CSS3 中提供了一系列属性来设置元素的圆角效果，如下所示：\n\nborder-top-left-radius：为元素左上角设置圆角效果；\nborder-top-right-radius：为元素右上角设置圆角效果；\nborder-bottom-right-radius：为元素右下角设置圆角效果；\nborder-bottom-left-radius：为元素左下角设置圆角效果；\nborder-radius：上面四个属性的简写形式，可以同时为元素的四个角设置圆角效果。\n\n上述函数的可选值如下表所示：\n\n\n\n值\n描述\n\n\n\nlength\n通过数值加单位的形式定义圆角的形状\n\n\npercentage\n以百分比的形式定义圆角的形状\n\n\nborder-*-radius通过上面的介绍我们知道，通过 border-*-radius 系列函数能够分别为元素的四个角设置圆角效果，函数的语法格式如下：\nborder-*-radius：[  |  ]{1,2}\n语法的含义为，需要为 border-*-radius 属性提供 1~2 个参数，参数之间使用空格进行分隔。其中第一个参数表示圆角水平方向的半径或半轴，第二个参数表示圆角垂直方向的半径或半轴，如果省略第二个参数，那么该参数将直接沿用第一个参数的值。\n图：元素四角\n【示例】使用四个 border-*-radius 属性为元素设置圆角效果：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 350px;            height: 100px;            padding: 15px 0px 0px 25px;        &#125;        .one &#123;            border-top-left-radius: 2em 0.5em;            border-top-right-radius: 1em 3em;            border-bottom-right-radius: 4em 0.5em;            border-bottom-left-radius: 1em 3em;            background-color: #CCC;            margin-bottom: 10px;        &#125;        .two &#123;            border-top-left-radius:2em;            border-top-right-radius:2em;            border-bottom-right-radius:2em;            border-bottom-left-radius:2em;            background-color: #888;        &#125;    &lt;/style&gt;   &lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;        border-top-left-radius: 2em 0.5em;&lt;br&gt;        border-top-right-radius: 1em 3em;&lt;br&gt;        border-bottom-right-radius: 4em 0.5em;&lt;br&gt;        border-bottom-left-radius: 1em 3em;    &lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;        border-top-left-radius:2em;&lt;br&gt;        border-top-right-radius:2em;&lt;br&gt;        border-bottom-right-radius:2em;&lt;br&gt;        border-bottom-left-radius:2em;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-*-radius 属性演示\nborder-radiusborder-radius 属性是 border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius 四个属性的简写形式，使用 border-radius 可以同时设置四个 border-*-radius 属性。border-radius 属性的格式如下：\nborder-radius：[ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ &#x2F; [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]?\n语法说明如下：\n\nborder-radius 属性可以接收两组参数，参数之间使用斜杠 / 进行分隔，每组参数都允许设置 1~4 个参数值，其中第一组参数代表圆角水平方向上的半径或半轴，第二组参数代表圆角垂直方向上的半径或半轴，如果省略第二组参数的值，那么该组参数将直接沿用第一组参数的值。\n第一组参数中，如果提供全部的四个参数，那么将按照上左 top-left、上右 top-right、下右 bottom-right、下左 bottom-left 的顺序作用于元素的四个角；如果提供三个参数，那么第一个参数将作用于元素的左上角 top-left，第二个参数将作用于元素的右上角 top-right 和左下角 bottom-left，第三个参数将作用于元素的右下角 bottom-right；如果提供两个参数，那么第一个参数将作用于元素的左上角 top-left 和右下角 bottom-right，第二个参数将作用于元素的右上角 top-right 和左下角 bottom-left；如果只提供一个参数，那么该参数将同时作用于元素的四个角。\n第二组参数同样遵循第一组参数的规律，只是作用的方向不同。\n\n【示例】使用 border-radius 属性为元素设置圆角效果：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;    ul &#123;        margin: 0;        padding: 0;    &#125;    li &#123;        list-style: none;        margin: 10px 0 0 10px;        padding: 10px;        width: 200px;        float: left;        background: #bbb;    &#125;    h2 &#123;        clear: left;    &#125;    .test .one &#123;        border-radius: 10px;    &#125;    .test .two &#123;        border-radius: 10px 20px;    &#125;    .test .three &#123;        border-radius: 10px 20px 30px;    &#125;    .test .four &#123;        border-radius: 10px 20px 30px 40px;    &#125;    .test2 .one &#123;        border-radius: 10px/5px;    &#125;    .test2 .two &#123;        border-radius: 10px 20px/5px 10px;    &#125;    .test2 .three &#123;        border-radius: 10px 20px 30px/5px 10px 15px;    &#125;    .test2 .four &#123;        border-radius: 10px 20px 30px 40px/5px 10px 15px 20px;    &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;水平与垂直半径相同时：&lt;/h2&gt;    &lt;ul class=&quot;test&quot;&gt;        &lt;li class=&quot;one&quot;&gt;提供1个参数&lt;br&gt;border-radius:10px;&lt;/li&gt;        &lt;li class=&quot;two&quot;&gt;提供2个参数&lt;br&gt;border-radius:10px 20px;&lt;/li&gt;        &lt;li class=&quot;three&quot;&gt;提供3个参数&lt;br&gt;border-radius:10px 20px 30px;&lt;/li&gt;        &lt;li class=&quot;four&quot;&gt;提供4个参数&lt;br&gt;border-radius:10px 20px 30px 40px;&lt;/li&gt;    &lt;/ul&gt;    &lt;h2&gt;水平与垂直半径不同时：&lt;/h2&gt;    &lt;ul class=&quot;test2&quot;&gt;        &lt;li class=&quot;one&quot;&gt;提供1个参数&lt;br&gt;border-radius:10px/5px;&lt;/li&gt;        &lt;li class=&quot;two&quot;&gt;提供2个参数&lt;br&gt;border-radius:10px 20px/5px 10px;&lt;/li&gt;        &lt;li class=&quot;three&quot;&gt;提供3个参数&lt;br&gt;border-radius:10px 20px 30px/5px 10px 15px;&lt;/li&gt;        &lt;li class=&quot;four&quot;&gt;提供4个参数&lt;br&gt;border-radius:10px 20px 30px 40px/5px 10px 15px 20px;&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-radius 属性演示\n边框图片对于元素的边框我们除了可以使用《CSS 边框》一节中介绍的一些默认样式外，还可以通过 CSS3 中的 border-image 属性使用图像来作为元素的边框，以创建出丰富多彩边框效果。\nborder-image 属性可以通过一些简单的规则，将一副图像划分为 9 个单独的部分，浏览器会自动使用相应的部分来替换边框的默认样式。border-image 属性是五个 border-image-* 属性的简写，其语法格式如下：\nborder-image：border-image-source || border-image-slice [&#x2F; border-image-width | &#x2F; border-image-width ? &#x2F; border-image-outset]? || border-image-repeat\n通过语法可以看出 border-image 是 border-image-source、border-image-slice、border-image-width、border-image-outset 和 border-image-repeat 属性的简写，其中：\n\n\n\n属性\n说明\n\n\n\nborder-image-source\n定义边框图像的路径。\n\n\nborder-image-slice\n定义边框图像从什么位置开始分割。\n\n\nborder-image-width\n定义边框图像的厚度（宽度）。\n\n\nborder-image-outset\n定义边框图像的外延尺寸（边框图像区域超出边框的量）。\n\n\nborder-image-repeat\n定义边框图像的平铺方式。\n\n\n接下来我们通过如下所示的图片来演示一下 border-image-source、border-image-slice、border-image-width、border-image-outset 和 border-image-repeat 几个属性的使用。\n图：边框图片\nborder-image-sourceborder-image-source 属性用来定义边框要使用的图像，通过该属性可以指定一个图像来替换边框的默认样式，当 border-image-source 属性的值为 none 或者指定的图像不可用时，则会显示边框默认的样式。\n另外，border-image-source 属性除了可以使用图像来替换边框的默认样式外，您还可以使用渐变来定义边框样式，属性的语法格式如下：\nborder-image-source：none | &lt;image&gt;\n其中，none 为 border-image-source 属性的默认值，表示不使用图像来替换边框的默认样式；&lt;image&gt; 为使用 url() 函数指定的图像路径或者使用 linear-gradient() 函数定义的渐变色，用来替换默认的边框样式。\n【示例】通过 border-image-source 属性使用图像来替换默认的边框样式：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            border: 27px solid;            padding: 10px;            border-image-source: url(./border.png);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;使用图片替换默认边框&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-image-source 属性演示\n通过运行结果可以看出，仅仅借助 border-image-source 属性并不能达到我们想要的效果，我们再来看一下其它几个函数。\nborder-image-sliceborder-image-slice 属性用来分割通过 border-image-source 属性加载的图像，属性的语法格式如下：\nborder-image-slice：[&lt;number&gt; | &lt;percentage&gt; ]{1,4} &amp;&amp; fill?\nborder-image-slice 属性可以接收三种类型的值：\n\n&lt;number&gt;：数值，用具体数值指定图像分割的位置，数值代表图像的像素位置或向量坐标，不允许负值；\n&lt;percentage&gt;：百分比，相对于图像尺寸的百分比，图像的宽度影响水平方向，高度影响垂直方向；\nfill：保留边框图像的中间部分。\n\nborder-image-slice 属性可以指定上、下、左、右四个方位来分割图像，并将图像分成 4 个角、4 条边和中间区域等 9 个部份，中间区域始终是透明的（即没图像填充），除非加上关键字 fill，如下图所示：\n\n除 fill 关键字外，border-image-slice 属性可以接受 1~4 个参数值：\n\n如果提供全部四个参数值，那么将按上、右、下、左的顺序对图像进行分割；\n如果提供三个参数，那么第一个参数用于上方，第二个参数用于左、右两侧，第三个参数用于下方；\n如果提供两个参数，那么第一个参数用于上方和下方，第二个参数用于左、右两个；\n如果只提供一个参数，那么上、右、下、左都将使用该值进行分割。\n\n【示例】使用 border-image-slice 属性用来分割通过 border-image-source 属性加载的图像：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            border: 27px solid;            padding: 10px;            border-image-source: url(./border.png);            border-image-slice: 27;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;使用图片替换默认边框&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-image-slice 属性演示\nborder-image-widthborder-image-width 属性用来设置通过 border-image-source 属性加载的图像厚度（宽度），属性的语法格式如下：\nborder-image-width：[&lt;length&gt; | &lt;percentage&gt; | &lt;number&gt; | auto ]{1,4}\n语法说明如下：\n\n&lt;length&gt;：使用数值加单位的形式指定图像边框的宽度，不允许为负值；\n&lt;percentage&gt;：用百分比的形式指定图像边框的宽度，参照图像边框区域的宽和高进行换算，不允许负值；\n&lt;number&gt;：使用浮点数指定图像边框的宽度，该值对应 border-width 的倍数，例如值为 2，则参数的实际值为 2 * border-width，不允许负值；\nauto：由浏览器自动设定，当 border-image-width 设置为 auto 时，它的实际值与 border-image-slice 相同的值。\n\n提示：border-image-width 属性的默认值为 1，也就是说当我们省略 border-image-width 属性的值时，该属性的值会被设置为 1 * border-width，相当于会直接使用 border-width 的值。\nborder-image-width 属性同样可以接受 1~4 个参数值：\n\n如果提供全部四个参数值，那么将按照上、右、下、左的顺序设置图像边框四个方向上的宽度；\n如果提供三个参数，那么第一个参数用于上边框，第二个参数用于左、右两个边框，第三个参数用于下边框；\n如果提供两个参数，那么第一个参数用于上、下两个边框，第二个参数用于左、右两个边框；\n如果只提供一个参数，那么上、右、下、左都将使用该值设置图像边框的宽度。\n\n【示例】使用 border-image-width 属性设置图像边框的宽度：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            border: 27px solid;            padding: 10px;            border-image-source: url(./border.png);            border-image-slice: 27;            border-image-width: 10px 1 0.5 15px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;使用图片替换默认边框&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-image-width 属性演示\nborder-image-outsetborder-image-outset 属性用来定义图像边框相对于边框边界向外偏移的距离（使图像边框延伸到盒子模型以外），该属性的语法格式如下：\nborder-image-outset：[&lt;length&gt; | &lt;number&gt; ]{1,4}\n语法说明如下：\n\n&lt;length&gt;：用具体的数值加单位的形式指定图像边框向外偏移的距离，不允许为负值；\n&lt;number&gt;：用浮点数指定图像边框向外偏移的距离，该值表示 border-width 的倍数，例如值为 2，则表示偏移量为 2 * border-width，不允许为负值。\n\nborder-image-outset 属性同样可以接受 1~4 个参数值：\n\n如果提供全部四个参数值，那么将按上、右、下、左的顺序作用于四边；\n如果提供三个参数值，那么第一个参数将用于上边框，第二个参数将用于左、右两个边框，第三个参数将用于下边框；\n如果提供两个参数，那么第一个参数将用于上、下两个边框，第二个参数将用于左、右两个边框；\n如果只提供一个参数，那么该参数将同时作用于四边。\n\n【示例】使用 border-image-outset 属性设置图像边框相对于边框边界向外的偏移量：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            border: 27px solid;            padding: 10px;            margin: 30px 0px 0px 30px;            border-image-source: url(./border.png);            border-image-slice: 27;            border-image-outset: 25px;            background-color: #CCC;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;使用图片替换默认边框&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-image-outset 属性演示\nborder-image-repeatborder-image-repeat 属性用来设置如何填充使用 border-image-slice 属性分割的图像边框，例如平铺、拉伸等等，该属性的语法格式如下：\nborder-image-repeat：[stretch | repeat | round | space]{1,2}\n语法说明如下：\n\nstretch：将被分割的图像使用拉伸的方式来填充满边框区域；\nrepeat：将被分割的图像使用重复平铺的方式来填充满边框区域，当图像碰到边界时，超出的部分会被截断；\nround：与 repeat 关键字类似，不同之处在于，当背景图像不能以整数次平铺时，会根据情况缩放图像；\nspace：与 repeat 关键字类似，不同之处在于，当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。\n\nborder-image-repeat 属性能够接受 1~2 个参数值：\n\n如果提供两个参数，那么第一个参数将用于水平方向，第二个将用于垂直方向；\n如果只提供一个参数，那么将在水平和垂直方向都应用该值。\n\n【示例】使用 border-image-repeat 属性设置图像边框的填充方式：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            border: 27px solid;            padding: 10px;            border-image-source: url(./border.png);            border-image-slice: 27;            border-image-repeat: round repeat;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;使用图片替换默认边框&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-image-repeat 属性演示\nborder-image了解完 border-image-source、border-image-slice、border-image-width、border-image-outset 和 border-image-repeat 这几个属性，我们回头再来看看 border-image 属性。border-image 属性是五个 border-image-* 属性的简写，通过 border-image 属性可以同时设置五个 border-image-* 属性。\n【示例】使用 border-image 属性设置图片边框：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            border: 27px solid;            padding: 10px;            border-image: url(./border.png) 27 round;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;使用图片替换默认边框&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：border-image 属性演示\nbox-sizing：改变盒子模型默认情况下，网页中元素的实际宽度或高度取决于元素内容区的宽度或高度、内边距以及边框属性的大小，因此我们在为元素布局时还需要考虑元素的内边距和边框属性所占的页面空间，这一点我们已经在《CSS 盒子模型》中进行了讲解。\n正是由于上述原因，当您为页面元素设置宽度和高度时，元素的实际大小往往比您设置的要大。为此 CSS3 中添加了 box-sizing 属性来改变默认的盒子模型，通过 box-sizing 属性可以将元素的内边距和外边距在元素内容区内绘制，以使元素呈现的宽度和高度与设置的宽度和高度相同。\nbox-sizing 属性的可选值如下：\n\n\n\n值\n描述\n\n\n\ncontent-box\n默认值，元素的实际宽度或高度等于元素内容区的宽度或高度、内边距和边框的和\n\n\nborder-box\n在元素的内容区内绘制内边距或边框，内边距或边框不会影响元素的实际宽度或高度\n\n\ninherit\n从父元素继承 box-sizing 属性的值。\n\n\n【示例】下面通过一个示例来演示 box-sizing 属性的使用：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 300px;            height: 50px;            margin-top: 5px;            border: 10px solid red;            padding: 5px;        &#125;        .two &#123;            box-sizing: content-box;        &#125;        .three &#123;            box-sizing: border-box;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;默认情况&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;box-sizing: content-box;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;box-sizing: border-box;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n \n图：box-sizing 属性演示\n提示：当为元素定义 box-sizing: border-box; 属性时，元素内容区的实际宽度和高度是 width 和 height 属性中减去各边的边框和内边距的宽度。\ngradient (颜色渐变)\nCSS 中的渐变指的是两种或多种颜色之间的平滑过渡，以前我们必须使用事先定义好的图像来实现渐变效果，在 CSS3 出现以后则简单了很多，CSS3 为实现渐变效果提供了一种灵活的解决方案。\n\n通过 CSS3 您可以定义三种类型的渐变，分别为线性渐变（通过 linear-gradient() 函数创建）、径向渐变（通过 radial-gradient() 函数创建）和圆锥渐变（通过 conic-gradient() 函数创建）。\n另外，您还可以使用 repeating-linear-gradient()、repeating-radial-gradient() 和 repeating-conic-gradient() 函数来创建重复渐变。\n\n通过 CSS 创建的渐变不仅简单灵活，而且还省去了使用图像时所需的加载过程，节省了网页的加载时间。另外，通过 CSS 创建的渐变元素可以按任意比例放大或缩小，而且不会降低质量。\n\n\nlinear (线性渐变)线性渐变指的是颜色沿一条直线进行渐变（例如右上到下，从左到右等），要创建线性渐变，您至少需要定义两个色标（色标指的是想要平滑过渡的颜色），若要创建更加复杂的渐变效果，则需要定义更多的色标。创建线性渐变的基本语法如下：\nlinear-gradient(direction, color-stop1, color-stop2, …);\n参数说明如下：\n\ndirection 可选值，定义渐变的方向（例如从左到右，从上到下），可以是具体角度（例如 90deg），也可以通过 to 加 left、right、top、bottom 等关键字来表示渐变方向，例如：\nto left：表示从右到左，相当于 270deg；\nto right：表示从左到右，相当于 90deg；\nto top：表示从下到上，相当于 0deg；\nto bottom：默认值，表示从上到下，相当于 180deg；\nto right bottom：表示从左上到右下；\nto right top：表示从左下到右上；\nto left bottom：表示从右上到左下；\nto left top：表示从右下到左上。\n\n\ncolor-stop1、color-stop2、…：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过数值加单位或者百分比的形式定义颜色的起止位置。\n\n【示例】使用 linear-gradient() 函数定义线性渐变：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 210px;            height: 50px;            float: left;            margin: 10px;        &#125;        .one &#123;            background: linear-gradient(to right bottom, red, blue 70px);        &#125;        .two &#123;            background: linear-gradient(190deg, #000, #FFF);        &#125;        .three &#123;            background: linear-gradient(red, green, blue);        &#125;        .four &#123;            background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：linear-gradient() 函数演示\n\nradial (径向渐变)径向渐变与线性渐变类型，不同之处在于径向渐变是由中心向外延申的渐变，您可以指定中心点的位置，也可以设置渐变的形状。定义径向渐变的基本语法如下所示：\nradial-gradient(shape size at position, color-stop1, color-stop2, …);\n参数说明如下：\n\nat：一个关键字，需要放置在参数 position 的前面；\nposition：指定渐变起点的坐标，您可以使用数值加单位、百分比或者关键字（例如 left、bottom 等）等形式指定渐变起点的坐标，如果提供 2 个参数，那么第一个参数用来表示横坐标，第二个参数用来表示纵坐标，如果只提供一个参数，那么第二个参数将被默认设置为 50%，即 center；\nshape：指定渐变的形状，可选值为 circle（圆形）、ellipse（椭圆）；\nsize：指定渐变形状的大小，除了可以使用具体的数值来指定 circle、ellipse 的半径外，还可以使用下面所示的关键字来指定渐变形状的大小：\nclosest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边；\nclosest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角；\nfarthest-side：默认值，指定径向渐变的半径长度为从圆心到离圆心最远的边；\nfarthest-corner：指定径向渐变的半径长度为从圆心到离圆心最远的角。\n\n\ncolor-stop1、color-stop2、…：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过数值加单位或者百分比的形式定义颜色的起止位置。\n\n【示例】使用 radial-gradient() 函数定义径向渐变：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 210px;            height: 100px;            float: left;            margin: 10px;            border: 1px solid black;        &#125;        .one &#123;            background: radial-gradient(circle at 50%, red, yellow, lime);        &#125;        .two &#123;            background: radial-gradient(ellipse 100px 30px at 30%, red, yellow, lime);        &#125;        .three &#123;            background: radial-gradient(circle 100px at 50%, red 10%, yellow 50%, lime 100px);        &#125;        .four &#123;            background: radial-gradient(circle closest-corner at 50px 30px, red, yellow, lime);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：radial-gradient() 函数演示\n\nconic (圆锥渐变)圆锥渐变类似于径向渐变，两者都有一个中心点作为色标的源点，不同的是圆锥渐变是围绕中心点旋转（而不是从中心点向往辐射），定义圆锥渐变的基本语法如下：\nconic-gradient(from angle at position, start-color, …, last-color);\n语法说明如下：\n\nfrom：一个关键字，需要放置在参数 angle 之前；\nangle：定义圆锥渐变的起始角度，可以为空，默认值为 0deg；\nat：一个关键字，需要放置在参数 position 之前；\nposition：定义圆锥渐变锥心的坐标，您可以使用数值加单位、百分比或者关键字（例如 left、bottom 等）等形式指定锥心的坐标，如果提供 2 个参数，那么第一个参数用来表示横坐标，第二个参数用来表示纵坐标，如果只提供一个参数，那么第二个参数将被默认设置为 50%，即 center（居中）；\nstart-color、…、last-color：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过百分比或者角度来定义颜色的起始位置。\n\n【示例】使用 conic-gradient() 定义圆锥渐变：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 210px;            height: 100px;            float: left;            margin: 10px;            border: 1px solid black;        &#125;        .one &#123;            background: conic-gradient(at 50%, red, orange, yellow, green, blue, indigo, violet, red);        &#125;       .two &#123;            background: conic-gradient(red 0deg 30deg, orange 30deg 50deg, yellow 50deg 200deg, green 200deg 300deg, blue 300deg 360deg);        &#125;        .three &#123;            background: conic-gradient(from 90deg, red 0% 55%, yellow 55% 90%, lime 90% 100%);        &#125;        .four &#123;            background: conic-gradient(#fff 0.25turn, #000 0.25turn 0.5turn, #fff 0.5turn 0.75turn, #000 0.75turn);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：conic-gradient() 函数演示\n\nrepeating (重复渐变)在 CSS 中，您还可以使用 ()、repeating-radial-gradient() 和 repeating-conic-gradient() 等函数来分别创建线性渐变、径向渐变和圆锥渐变的重复渐变，所谓重复渐变就是指将渐变的过程重复多次，以铺满整个元素。\n提示： repeating-linear-gradient()、repeating-radial-gradient() 和 repeating-conic-gradient() 函数的语法分别与 linear-gradient()、radial-gradient() 和 conic-gradient() 函数的语法相同。\n【示例】使用 repeating-linear-gradient()、repeating-radial-gradient() 和 repeating-conic-gradient() 三个函数定义重复渐变：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 210px;            height: 100px;            float: left;            margin: 10px;            border: 1px solid black;        &#125;        /* 0~10px为黑色,10~20px为白色,未重复10px~盒子边界为白色          0~10px为黑色,10~30为渐变距离,30~50px为白色,未重复10px~盒子边界为白色         */        .one &#123;            background: repeating-linear-gradient(190deg, #000 0px 10px, #FFF 10px 20px);            /* background: repeating-linear-gradient(190deg, #000 0px 10px, #FFF 30px 50px); */        &#125;       .two &#123;            background: repeating-radial-gradient(circle 100px at 50%, red 0% 10%, yellow 10% 30%, lime 30% 40%);        &#125;        .three &#123;            background: repeating-conic-gradient(#69f 0 36deg, #fd44ff 36deg 72deg);        &#125;        .four &#123;            background: conic-gradient(#fff 0.25turn, #000 0.25turn 0.5turn, #fff 0.5turn 0.75turn, #000 0.75turn) top left / 25% 25% repeat;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：重复渐变演示\nshadow (阴影效果)在网页设计中常常要使用到阴影效果，通过阴影效果可以很好的突出一个元素，在 CSS3 出现之前，我们想要为文本或者元素添加阴影效果需要借助图像才能实现，很不方便。而 CSS3 出现之后，我们通过 text-shadow 和 box-shadow 两个属性就可以为文本或元素添加阴影效果，不需要借助任何图像。\ntext-shadow\n使用 CSS 的 text-shadow 属性我们可以为文本设置阴影效果，属性的语法格式如下：\ntext-shadow: offset-x offset-y blur color;\n\n语法说明如下：\n\noffset-x：必填参数，设置阴影的水平偏移量，可以为负值；\n\noffset-y：必填参数，设置阴影的垂直偏移量，可以为负值；\n\nblur：可选参数，设置模糊的半径，值越大，模糊越大，阴影的边缘越模糊，不允许使用负值；\n\ncolor：可选参数，设置阴影的颜色，如果省略或未指定该值，则采用 color 属性的值。\n\n\n\n**提示：**使用 text-shadow 属性可以同时设定多组阴影效果，每组之间使用逗号分隔，定义的多组阴影效果会按照定义顺序依次罗列，第一个阴影在最上面，以此类推。另外，若要取消文本的阴影效果则可以将 text-shadow 属性的值设置为 none。\n\n\n【示例】使用 text-shadow 属性为文本添加阴影效果：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        p.one &#123;            text-shadow: 3px 5px 5px #FF0000;        &#125;        p.two &#123;            color: white;            text-shadow: 1px 1px 2px black,                         0 0 25px blue,                         0 0 5px darkblue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class=&quot;one&quot;&gt;文本阴影效果&lt;/p&gt;    &lt;p class=&quot;two&quot;&gt;文本阴影效果&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行效果如下图所示：\n  \n图：text-shadow 属性演示\nbox-shadow\n使用 CSS 的 box-shadow 属性我们可以为 HTML 元素设置阴影效果，属性的语法格式如下：\nbox-shadow: h-shadow v-shadow blur spread color inset;\n\n语法说明如下：\n\nh-shadow：必填参数，设置阴影水平方向的偏移量，可以为负值；\n\nv-shadow：必填参数，设置阴影垂直方向的偏移量，可以为负值；\n\nblur：可选参数，设置模糊的半径，值越大，模糊越大，阴影的边缘越模糊，不允许使用负值；\n\nspread：可选参数，设置阴影的尺寸；\n\ncolor：可选参数，设置阴影的颜色；\n\ninset：可选参数，将默认的外部阴影 (outset) 改为内部阴影。\n\n\n\n*提示：*与 text-shadow 属性相似，box-shadow 属性也可以同时设定多组阴影效果，每组之间使用逗号分隔，定义的多组阴影效果会按照定义顺序依次罗列，第一个*阴影在最上面*，以此类推。\n\n\n【示例】使用 box-shadow 属性为文本添加阴影效果：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border-radius: 10px;            background-color: #CCC;            float: left;            margin: 5px;        &#125;        div.one &#123;            box-shadow: 2px 2px 5px #000;        &#125;        div.two &#123;            box-shadow: 2px 2px 5px #000 inset;        &#125;        div.three &#123;            margin-left: 10px;            box-shadow: 0px 0px 0px 3px #bb0a0a,                        0px 0px 0px 6px #2e56bf,                        0px 0px 0px 9px #ea982e;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行效果如下图所示：\n图：box-shadow 属性演示\ntransform-origin介绍： 该属性CSS属性可以更改一个元素变形的原点。语法：transform-origin: offsetX[,offsetY [, offsetZ]]\n\n**参考文档:**https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin\n\ntransform (2D转换)CSS 中的 2D 转换允许我们在二维空间中执行一些基本的变换操作，例如移动、旋转、缩放或扭曲等，变换后的元素与绝对定位的元素类似，不会影响周围的元素，但可以和周围的元素重叠，不同的是，转换后的元素在页面中任然会占用为转换之前的空间。\n借助 CSS 中的 transform 属性以及下列转换函数就可以实现 2D 转换：\n\n\n\n函数\n说明\n\n\n\nmatrix()\n以一个包含六个值（a, b, c, d, e, f）的变换矩阵的形式指定一个 2D 变换，相当于直接应用一个 [a, b, c, d, e, f] 的变换矩阵。\n\n\ntranslate()\n将对象沿 X 轴和 Y 轴平移，该函数需要提供 1~2 个参数，第一个参数对应 X 轴，第二个参数对应 Y 轴，如果未提供第二个参数，则默认值为 0。\n\n\ntranslatex()\n将对象沿 X 轴（水平方向）的平移。\n\n\ntranslatey()\n将对象沿 Y 轴（垂直方向）的平移。\n\n\nrotate()\n旋转指定对象，在函数的参数中可以指定旋转的角度。\n\n\nscale()\n将对象进行缩放，该函数需要提供 1~2 个参数，第一个参数对应 X 轴，第二个参数对应 Y 轴，如果未提供第二个参数，则默认取第一个参数的值。\n\n\nscalex()\n将对象进行缩放（改变元素的宽度）。\n\n\nscaley()\n将对象进行缩放（改变元素的高度）。\n\n\nskew()\n将对象沿 X 轴和 Y 轴方向进行倾斜扭曲，该函数需要提供 1~2 个参数，第一个参数对应 X 轴，第二个参数对应 Y 轴。如果未提供第二个参数，则默认值为 0。\n\n\nskewx()\n将对象沿 X 轴的（水平方向）扭曲。\n\n\nskewy()\n将对象沿 Y 轴的（垂直方向）扭曲。\n\n\ntranslate()translate() 函数用来根据指定的参数将元素沿水平（X 轴）或垂直（Y 轴）方向移动，函数的语法格式如下：\ntranslate(tx, ty)\n其中 tx 对应元素在水平（X 轴）方向的移动距离，ty 对应元素在垂直（Y 轴）方向的移动距离，参数 ty 可以忽略（默认为 0），两个参数均可以为负值。\n【示例】使用 translate() 函数来移动指定的元素：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            background-color: #CCC;            transform: translate(100px, 10px);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：translate() 函数演示\n如果只是将元素水平移动或者只是将元素垂直移动，也可以使用 translateX()（将元素水平移动）或 translateY()（将元素垂直移动），translateX() 和 translateY() 函数均只需要提供一个参数即可，例如：\ntranslateX(100px);      /* 等同于 translate(100px, 0px); */  translateY(10px);        /* 等同于 translate(0px, 10px); */\n\nrotate()rotate() 函数用来按照给定的角度来旋转元素，函数的语法格式如下：\nrotate(a)\n其中参数 a 表示元素要旋转的角度，若 a 为正值则表示顺时针旋转，若 a 为负值则表示逆时针旋转。\n【示例】使用 rotate() 函数来旋转元素：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            background-color: #CCC;            margin: 20px 0px 0px 20px;            transform: rotate(45deg);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：rotate() 函数演示\nscale()scale() 函数用来缩放（放大或缩小）指定的元素，函数的语法格式如下：\nscale(sx, sy)\n其中 sx 表示水平方向的缩放比例，sy 表示垂直方向的缩放比例。另外，参数 sy 可以省略，它的默认值等于 sx。\n【示例】使用 scale() 函数缩放指定元素：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            background-color: #CCC;            transform: scale(0.7);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：scale() 函数演示\n提示：当 scale() 中，给定的参数值在 -11 范围之外时，元素将被放大；当在参数值在 -11 范围之内时，元素将被缩小。\n与 translate() 函数类似，如果是仅在水平方向或者仅在垂直方向上缩放元素大小，也可以使用 scaleX()（在水平方向缩放元素）和 scaleY()（在垂直方向缩放元素）函数。scaleX() 和 scaleY() 函数仅需要提供一个参数即可，例如：\nscaleX(0.5);    /* 等同于 scale(0.5, 1); */  scaleY(0.5);    /* 等同于 scale(1, 0.5); */\n\nskew()skew() 函数用来将元素沿水平方向（X 轴）和垂直方向（Y 轴）倾斜扭曲，函数的语法格式如下：\nskew(ax, ay)\n其中，参数 ax 表示元素水平方向的扭曲角度，参数 ay 表示元素垂直方向的扭曲角度。另外，参数 ay 可以省略，若省略参数 ay，则其默认值为 0。\n【示例】使用 skew() 函数来扭曲指定元素：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            background-color: #CCC;            margin: 20px 0px 0px 10px;            transform: skew(-15deg, 20deg);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：skew() 函数演示\n另外，如果是仅在水平方向或者仅在垂直方向上对元素进行扭曲，也可以使用 skewX()（在水平方向缩放元素）和 skewY()（在垂直方向缩放元素）函数来完成。skewX() 和 skewY() 函数仅需要提供一个参数即可，例如：\nskewX(15deg);    /* 等同于 skew(15deg, 0deg); */  skewY(15deg);    /* 等同于 skew(0deg, 15deg); */\n\nmatrix()matrix() 函数可以看作是 skew()、scale()、rotate() 和 translate() 几个函数的缩写形式，通过 matrix() 函数可以同时定义所有 2D 转换操作，函数的语法格式如下：\nmatrix(a, b, c, d, tx, ty)\nmatrix() 函数中的 6 个参数分别对应 scaleX()、skewY()、skewX()、scaleY()、translateX()、translateY() 几个函数，您可以使用 matrix() 来实现各种 2D 转换操作，例如：\n\ntranslate(tx, ty) = matrix(1, 0, 0, 1, tx, ty); ：其中 tx 和 ty 是水平和垂直平移值；\nrotate(a) = matrix(cos(a), sin(a), -sin(a), cos(a), 0, 0); ：其中，a 是度数的值。您可以交换 sin(a) 和 -sin(a) 值来进行反向旋转；\nscale(sx, sy) = matrix(sx, 0, 0, sy, 0 ,0); ：其中 sx 和 sy 是水平和垂直缩放比例值；\nskew(ax, ay) = matrix(1, tan(ay), tan(ay), 1, 0 ,0); ：其中 ax 和 ay 是以 deg 为单位的水平和垂直值。\n\n【示例】使用 matrix() 函数对元素进行 2D 转换操作：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            background-color: #CCC;            margin: 20px 0px 0px 10px;            float: left;        &#125;        .one &#123;            transform: matrix(0.866, 0.5, -0.5, 0.866, 0, 0);        &#125;        .two &#123;            margin-left: 35px;            transform: matrix(0.586, 0.8, -0.8, 0.686, 0, 0);        &#125;        .three &#123;            margin-left: 40px;            margin-top: 25px;            transform: matrix(0.586, 0.8, -0.8, 0.866, 0, 0);        &#125;        .four &#123;            transform: matrix(0.586, 0.8, -0.8, 0.586, 40, 30);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;four&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：matrix() 函数演示\ntransform (3D转换)在 CSS 中，除了可以对页面中的元素进行 2D 转换外，您也可以对象元素进行 3D 转换（将页面看作是一个三维空间来对页面中的元素进行移动、旋转、缩放和倾斜等操作）。与 2D 转换相同，3D 转换同样不会影响周围的元素，而且可以与其它元素重叠。但是，变换后的元素任然会占用其默认位置（未变换前）的空间。\n3D 转换同样需要使用 transform 属性以及一些函数来实现，例如：\n\n\n\n函数\n说明\n\n\n\nmatrix3d()\n以一个 4x4 矩阵的形式指定一个 3D 转换。\n\n\ntranslate3d()\n指定对象的 3D 位移，第 1 个参数对应 X 轴，第 2 个参数对应 Y 轴，第 3 个参数对应 Z 轴，参数不允许省略。\n\n\ntranslateZ()\n指定对象在 Z 轴的平移。\n\n\nrotate3d()\n指定对象的 3D 旋转角度，其中前 3 个参数分别表示旋转的方向 X、Y、Z，第 4 个参数表示旋转的角度，参数不允许省略。\n\n\nrotateX()\n指定对象在 X 轴上的旋转角度。\n\n\nrotateY()\n指定对象在 Y 轴上的旋转角度。\n\n\nrotateZ()\n指定对象在 Z 轴上的旋转角度。\n\n\nscale3d()\n指定对象的 3D 缩放，第 1 个参数对应 X 轴，第 2 个参数对应 Y 轴，第 3 个参数对应 Z 轴，参数不允许省略。\n\n\nscaleZ()\n指定对象的 Z 轴缩放。\n\n\nperspective()\n指定透视距离。\n\n\ntranslate3d()translate3d() 函数用于移动元素在 3D 空间中的位置，这种变换的特点是通过三维矢量坐标来定义元素在每个方向上（X 轴、Y 轴、Z 轴）的偏移量。函数的语法格式如下：\ntranslate3d(tx, ty, tz)\n参数说明如下：\n\ntx：表示元素在水平方向（X 轴）移动的距离；\nty：表示元素的垂直方向（Z 轴）移动的距离；\ntz：表示元素在 Z 轴移动的距离，该参数不能使用百分比值。\n\n【示例】使用 translate3d() 函数设置元素在三维空间中的位置：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            background-color: #CCC;        &#125;        p &#123;            transform: translate3d(25px, 25px, 50px);            border: 1px solid red;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;p&gt;translate3d(25px, 25px, 50px);&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：translate3d() 函数演示\n3D 转换使用的是三维坐标系，但是沿 Z 轴方向的移动并不能很明显的显现出来，因为我们往往会将网页看作是一个二维的平面，并没有深度。您可以使用 perspective 和 perspective-origin 属性来为元素添加深度感，即 Z 轴越高的元素显示的越大，反之则越小。\ntranslateZ()函数 translateZ() 用来沿三维坐标系的 Z 轴来移动元素，函数的语法格式如下：\ntranslateZ(tz);\n其中参数 tz 用来设置元素在 Z 轴上移动的距离。\n提示：translateZ(tz); 相当于 translate3d(0, 0, tz); 的简写形式。\n【示例】使用 translateZ() 属性设置元素沿 Z 轴移动的距离：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            perspective:150;            perspective-origin: 10% 10%;            -webkit-perspective:150;/*兼容 Safari and Chrome */            -webkit-perspective-origin: 10% 10%;/*兼容 Safari and Chrome */            background-color: #CCC;        &#125;        p &#123;            transform: translateZ(30px);            border: 1px solid red;            background-color: yellow;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;p&gt;translateZ(30px);&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：translateZ() 函数演示\nrotate3d()rotate3d() 函数用来设置元素沿 X 轴、Y 轴或 Z 轴方向旋转的角度，该函数只会使元素按照固定的轴旋转，不会使元素变形。rotate3d() 函数的语法格式如下：\nrotate3d(x, y, z, a)\n参数说明如下：\n\nx：设置旋转轴的 X 轴坐标；\ny：设置旋转轴的 Y 轴坐标；\nz：设置旋转轴的 Z 轴坐标；\na：设置元素旋转的角度，正角度表示顺时针旋转，负角度表示逆时针旋转。\n\n【示例】使用 rotate3d() 函数来旋转元素：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            perspective:150;            perspective-origin: 10% 10%;            -webkit-perspective:150;            -webkit-perspective-origin: 10% 10%;            border: 3px solid black;            margin: 10px 0px 0px 10px;        &#125;        .transform &#123;            background-color: red;            border: none;            transform: rotate3d(0, 1, 2, 40deg);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;div class=&quot;transform&quot;&gt;rotate3d(0, 1, 2, 40deg);&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：rotate3d() 函数演示\n除了 rotate3d() 函数外，CSS 中还提供了 rotateX()（沿 X 轴旋转元素）、rotateY() （沿 Y 轴旋转元素）和 rotateZ()（沿 Z 轴旋转元素）三个函数来按照不同的坐标轴旋转元素。rotateX()、rotateY()、rotateZ() 函数的语法格式如下：\nrotateX(a) /* 等同于 rotate3D(1, 0, 0, a); */  rotateY(a) /* 等同于 rotate3D(0, 1, 0, a); */  rotateZ(a) /* 等同于 rotate3D(0, 0, 1, a); */\n\nscale3d()scale3d() 函数可以改变元素的大小（缩放），函数的语法格式如下：\nscale3d(sx, sy, sz)\n参数说明如下：\n\nsx：表示元素在 X 轴方向的缩放比例；\nsy：表示元素在 Y 轴方向的缩放比例；\nsz：表示元素在 Z 轴方向的缩放比例。\n\n【示例】使用 scale3d() 函数来缩放指定元素：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            perspective:150;            perspective-origin: 10% 10%;            -webkit-perspective:150;            -webkit-perspective-origin: 10% 10%;            border: 3px solid black;            margin: 10px 0px 0px 10px;        &#125;        .transform &#123;            background-color: red;            border: none;            transform: scale3d(1, 1, 1.5) rotate3d(1, 0, 0, 60deg);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;div class=&quot;transform&quot;&gt;scale3d(1, 1, 1.5) rotate3d(1, 0, 0, 60deg);&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：scale3d() 函数演示\n提示：当 scale3d() 函数的参数数值超出 [-1，1] 范围时，将在对应的方向上放大元素；当参数值在 [-1，1] 范围内时，将在当前方向上缩小元素；当参数值等于 1 时，则不会改变元素的大小。\n除了 scale3d() 函数外，CSS 中还提供了 scaleX()（沿 X 轴缩放元素）、scaleY() （沿 Y 轴缩放元素）和 scaleZ()（沿 Z 轴缩放元素）三个函数来按照不同的坐标轴缩放元素。scaleX()、scaleY()、scaleZ() 函数的语法格式如下：\nscaleX(sx) /* 等同于 scale(sx, 1); 和 scale3d(sx, 1, 1); */  scaleY(sy) /* 等同于 scale(1, sy); 和 scale3d(1, sy, 1); */  scaleZ(sz) /* 等同于 scale3d(1, 1, sz); */\n\nmatrix3d()matrix3d() 函数与前面我们学习的 matrix() 函数非常相似，不过 matrix3d() 函数可以使用一个 4 × 4 的矩阵来描述一个三维（3D）转换。通过 matrix3d() 函数可以一次执行所有的 3D 转换操作，函数的语法格式如下：\nmatrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)\n参数说明如下：\n\na1、b1、c1、d1、a2、b2、c2、d2、a3、b3、c3、d3、d4：用来描述各种 3D 转换；\na4、b4、c4：表示元素变换的量。\n\n【示例】使用 matrix3d() 函数来定义 3D 转换：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            perspective:150;            perspective-origin: 10% 10%;            -webkit-perspective:150;            -webkit-perspective-origin: 10% 10%;            border: 3px solid black;            margin: 10px 0px 0px 10px;        &#125;        .transform &#123;            background-color: red;            border: none;            transform: matrix3d(0.359127, -0.469472, 0.806613, 0, 0.190951, 0.882948, 0.428884, 0, -0.913545, 0, 0.406737, 0, 0, 0, 0, 1);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;div class=&quot;transform&quot;&gt;matrix3d()&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：matrix3d() 函数演示\ntransition (过渡效果)通常当 CSS 的属性值更改后，浏览器会立即更新相应的样式，例如当鼠标悬停在元素上时，通过 :hover 选择器定义的样式会立即应用在元素上。在 CSS3 中加入了一项过渡功能，通过该功能您可以将元素从一种样式在指定时间内平滑的过渡到另一种样式，类似于简单的动画，但无需借助 flash 或 JavaScript。\nCSS 中提供了 5 个有关过渡的属性，如下所示：\n\n\n\n属性\n说明\n\n\n\ntransition-property\n设置元素中参与过渡的属性。\n\n\ntransition-duration\n设置元素过渡的持续时间。\n\n\ntransition-timing-function\n设置元素过渡的动画类型。\n\n\ntransition-delay\n设置过渡效果延迟的时间，默认为 0。\n\n\ntransition\n简写属性，用于同时设置上面的四个过渡属性。\n\n\n要成功实现过渡效果，必须定义以下两项内容：\n\n元素中参数与过渡效果的属性；\n过渡效果持续的时间。\n\n提示：过渡效果通常会在鼠标悬停在元素上时发生，如果未设置过渡持续的时间，则过渡效果不会生效，因为过渡时间的默认值为 0。\ntransition-propertytransition-property 属性用来设置元素中参与过渡的属性名称，语法格式如下：\ntransition-property: none | all | property;\n参数说明如下：\n\nnone：表示没有属性参与过渡效果；\nall：表示所有属性都参与过渡效果；\nproperty：定义应用过渡效果的 CSS 属性名称列表，多个属性名称之间使用逗号,进行分隔。\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border: 3px solid black;            margin: 10px 0px 0px 10px;            transition-property: width, background;        &#125;        div:hover &#123;            width: 200px;            background-color: blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\ntransition-durationtransition-duration 属性用来设置过渡需要花费的时间（单位为秒或者毫秒），语法格式如下：\ntransition-duration: time;\n其中，time 为完成过渡效果需要花费的时间（单位为秒或毫秒），默认值为 0，意味着不会有效果。\n如果有多个参与过渡的属性，也可以依次为这些属性设置过渡需要的时间，多个属性之间使用逗号进行分隔，例如 transition-duration: 1s, 2s, 3s;。除此之外，也可以使用一个时间来为所有参与过渡的属性设置过渡所需的时间。示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border: 3px solid black;            margin: 10px 0px 0px 10px;            transition-property: width, background;            transition-duration: .25s, 1s;        &#125;        div:hover &#123;            width: 200px;            background-color: blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行效果如下图所示：\n图：transition-duration 属性演示\ntransition-timing-functiontransition-timing-function 属性用来设置过渡动画的类型，属性的可选值如下：\n\n\n\n值\n描述\n\n\n\nlinear\n以始终相同的速度完成整个过渡过程，等同于 cubic-bezier(0,0,1,1)\n\n\nease\n以慢速开始，然后变快，然后慢速结束的顺序来完成过渡过程，等同于 cubic-bezier(0.25,0.1,0.25,1)\n\n\nease-in\n以慢速开始过渡的过程，等同于 cubic-bezier(0.42,0,1,1)\n\n\nease-out\n以慢速结束过渡的过程，等同于 cubic-bezier(0,0,0.58,1)\n\n\nease-in-out\n以慢速开始，并以慢速结束的过渡效果，等同于 cubic-bezier(0.42,0,0.58,1)\n\n\ncubic-bezier(n, n, n, n)\n使用 cubic-bezier() 函数来定义自己的值，每个参数的取值范围在 0 到 1 之间\n\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border: 3px solid black;            margin: 10px 0px 0px 10px;            transition-property: width, background;            transition-duration: .25s, 1s;            transition-timing-function: ease;        &#125;        div:hover &#123;            width: 200px;            background-color: blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\ntransition-delaytransition-delay 属性用来设置过渡效果何时开始，属性的语法格式如下：\ntransition-delay: time;\n其中，参数 time 用来设置在过渡效果开始之前需要等待的时间，单位为秒或毫秒。\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border: 3px solid black;            margin: 10px 0px 0px 10px;            transition-property: width, background;            transition-duration: .25s, 1s;            transition-delay: 3s;        &#125;        div:hover &#123;            width: 200px;            background-color: blue;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行效果如下图所示：\n图：transition-delay 属性演示\ntransitiontransition 属性是上面四个属性的简写形式，通过该属性可以同时设置上面的四个属性，属性的语法格式如下：\ntransition: transition-property transition-duration transition-timing-function transition-delay;\ntransition 属性中，transition-property 和 transition-duration 为必填参数，transition-timing-function 和 transition-delay 为选填参数，如非必要可以省略不写。另外，通过 transition 属性也可以设置多组过渡效果，每组之间使用逗号进行分隔，示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border: 3px solid black;            margin: 10px 0px 0px 10px;            transition: width .25s linear 1.9s, background 1s 2s, transform 2s;        &#125;        div:hover &#123;            width: 200px;            background-color: blue;            transform: rotate(180deg);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行效果如下图所示：\n图：transition 属性演示\n上面的代码也可以写成如下所示的样子：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 100px;            height: 100px;            border: 3px solid black;            margin: 10px 0px 0px 10px;            transition-property: width, background, transform;            transition-duration: .25s, 1s, 2s;            transition-timing-function: linear, ease, ease;            transition-delay: 1.9s, 2s, 0s;        &#125;        div:hover &#123;            width: 200px;            background-color: blue;            transform: rotate(180deg);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\ntransitionend 事件介绍：该事件会在DOM元素 CSS transition 结束后触发。 如在transition完成前设置 display 为”none”，事件不会被触发。\n/* * 在指定的元素上监听transitionend事件, 例如#slidingMenu * 然后指定一个函数, 例如 showMessage() */function showMessage() &#123;    console.log(&#x27;Transition 已完成&#x27;);&#125;var element = document.getElementById(&quot;slidingMenu&quot;);element.addEventListener(&quot;transitionend&quot;, showMessage, false);\n\nanimation (动画)通过《CSS 过渡》一节的学习我们知道，利用 transition 属性可以实现简单的过渡动画，但过渡动画仅能指定开始和结束两个状态，整个过程都是由特定的函数来控制的，不是很灵活。本节我们再来介绍一种更为复杂的动画 —— animation。CSS 中的动画类似于 flash 中的逐帧动画，表现细腻并且非常灵活，使用 CSS 中的动画可以取代许多网页中的动态图像、Flash 动画或者 JavaScript 实现的特殊效果。  \n@keyframes 规则要创建 CSS 动画，您首先需要了解 @keyframes 规则，@keyframes 规则用来定义动画各个阶段的属性值，类似于 flash 动画中的关键帧，语法格式如下：  \n@keyframes animationName &#123;    from &#123;        properties: value;    &#125;    percentage &#123;        properties: value;    &#125;    to &#123;        properties: value;    &#125;&#125;// 或者@keyframes animationName &#123;    0% &#123;        properties: value;    &#125;    percentage &#123;        properties: value;    &#125;    100% &#123;        properties: value;    &#125;&#125;\n\n语法说明如下：  \n\nanimationName：表示动画的名称；\nfrom：定义动画的开头，相当于 0%；\npercentage：定义动画的各个阶段，为百分比值，可以添加多个；\nto：定义动画的结尾，相当于 100%；\nproperties：不同的样式属性名称，例如 color、left、width 等等。\n\n下面我们来看一个简单的 @keyframes 规则示例：  \n@keyframes ball &#123;    0% &#123; top: 0px; left: 0px;&#125;    25% &#123; top: 0px; left: 350px;&#125;    50% &#123; top: 200px; left: 350px;&#125;    75% &#123; top: 200px; left: 0px;&#125;    100% &#123; top: 0px; left: 0px;&#125; &#125;\n\n动画创建好后，还需要将动画应用到指定的 HTML 元素。要将动画应用到指定的 HTML 元素需要借助 CSS 属性，CSS 中提供了如下所示的动画属性：\n\n\n\n属性\n说明\n\n\n\nanimation-name\n设置需要绑定到元素的动画名称。\n\n\nanimation-duration\n设置完成动画所需要花费的时间，单位为秒或毫秒，默认为 0。\n\n\nanimation-timing-function\n设置动画的速度曲线，默认为 ease。\n\n\nanimation-fill-mode\n设置当动画不播放时（动画播放完或延迟播放时）的状态。\n\n\nanimation-delay\n设置动画开始之前的延迟时间，默认为 0。\n\n\nanimation-iteration-count\n设置动画被播放的次数，默认为 1。\n\n\nanimation-direction\n设置是否在下一周期逆向播放动画，默认为 normal。\n\n\nanimation-play-state\n设置动画是正在运行还是暂停，默认是 running。\n\n\nanimation\n所有动画属性的简写属性。\n\n\nanimation-nameanimation-name 属性用来将动画绑定到指定的 HTML 元素，属性的可选值如下：  \n值描述keyframename要绑定到 HTML 元素的动画名称，可以同时绑定多个动画，动画名称之间使用逗号进行分隔none表示无动画效果，  \n\n示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes ball &#123;            0% &#123; top: 0px; left: 0px;&#125;            25% &#123; top: 0px; left: 350px;&#125;            50% &#123; top: 200px; left: 350px;&#125;            75% &#123; top: 200px; left: 0px;&#125;            100% &#123; top: 0px; left: 0px;&#125;         &#125;        div &#123;            width: 100px;            height: 100px;            border-radius: 50%;            border: 3px solid black;            position: relative;            animation-name: ball;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n**注意：**要想让动画成功播放，您还需要定义 animation-duration 属性，否则会因为 animation-duration 属性的默认值为 0，导致动画并不会播放。\n\nanimation-durationanimation-duration 属性用来设置动画完成一个周期所需要花费的时间，单位为秒或者毫秒。示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes ball &#123;            0% &#123; top: 0px; left: 0px;&#125;            25% &#123; top: 0px; left: 350px;&#125;            50% &#123; top: 200px; left: 350px;&#125;            75% &#123; top: 200px; left: 0px;&#125;            100% &#123; top: 0px; left: 0px;&#125;         &#125;        div &#123;            width: 100px;            height: 100px;            border-radius: 50%;            border: 3px solid black;            position: relative;            animation-name: ball;            animation-duration: 2s;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation-duration 属性演示\n\n提示：动画若想成功播放，必须要定义 animation-name 和 animation-duration 属性。\n\nanimation-timing-functionanimation-timing-function 属性用来设置动画播放的速度曲线，通过速度曲线的设置可以使动画播放的更为平滑。animation-timing-function 属性的可选值如下表所示：  \n\n\n\n值\n描述\n\n\n\nlinear\n动画从开始到结束的速度是相同的\n\n\nease\n默认值，动画以低速开始，然后加快，在结束前变慢\n\n\nease-in\n动画以低速开始\n\n\nease-out\n动画以低速结束\n\n\nease-in-out\n动画以低速开始，并以低速结束\n\n\ncubic-bezier(n, n, n, n)\n使用 cubic-bezier() 函数来定义动画的播放速度，参数的取值范围为 0 到 1 之间的数值\n\n\n示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes ball &#123;            0% &#123;left: 0px;&#125;            50% &#123;left: 350px;&#125;            100% &#123;left: 0px;&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            border-radius: 50%;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation-name: ball;            animation-duration: 2s;        &#125;        .one &#123;            animation-timing-function: ease;        &#125;        .two &#123;            animation-timing-function: ease-in;        &#125;        .three &#123;            animation-timing-function: ease-out;        &#125;        .four &#123;            animation-timing-function: ease-in-out;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;ease&lt;/div&gt;    &lt;div&gt;ease-in&lt;/div&gt;    &lt;div&gt;ease-out&lt;/div&gt;    &lt;div&gt;ease-in-out&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation-timing-function 属性演示\nanimation-delayanimation-delay 属性用来定义动画开始播放前的延迟时间，单位为秒或者毫秒，属性的语法格式如下：  \nanimation-delay: time;\n其中参数 time 就是动画播放前的延迟时间，参数 time 既可以为正值也可以为负值。参数值为正时，表示延迟指定时间开始播放；参数为负时，表示跳过指定时间，并立即播放动画。示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes ball &#123;            0% &#123;left: 0px;&#125;            50% &#123;left: 350px;&#125;            100% &#123;left: 0px;&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            border-radius: 50%;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation-name: ball;            animation-duration: 2s;        &#125;        .one &#123;            animation-delay: 0.5s;        &#125;        .two &#123;            animation-delay: -0.5s;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;0.5s&lt;/div&gt;    &lt;div&gt;-0.5s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation-delay 属性演示\nanimation-iteration-countanimation-iteration-count 属性用来定义动画播放的次数，属性的可选值如下：  \n\n\n\n值\n描述\n\n\n\nn\n使用具体数值定义动画播放的次数，默认值为 1\n\n\ninfinite\n表示动画无限次播放\n\n\n示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes box &#123;            0% &#123;transform: rotate(0);&#125;            50% &#123;transform: rotate(0.5turn);&#125;            100% &#123;transform: rotate(1turn);&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            float: left;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation-name: box;            animation-duration: 2s;        &#125;        .one &#123;            animation-iteration-count: 1;        &#125;        .two &#123;            margin-left: 50px;            animation-iteration-count: infinite;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;1&lt;/div&gt;    &lt;div&gt;infinite&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation-iteration-count 属性演示\nanimation-directionanimation-direction 属性用来设置是否轮流反向播放动画，属性的可选值如下：  \n\n\n\n值\n描述\n\n\n\nnormal\n以正常的方式播放动画\n\n\nreverse\n以相反的方向播放动画\n\n\nalternate\n播放动画时，奇数次（1、3、5 等）正常播放，偶数次（2、4、6 等）反向播放\n\n\nalternate-reverse\n播放动画时，奇数次（1、3、5 等）反向播放，偶数次（2、4、6 等）正常播放\n\n\n示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes box &#123;            0% &#123;transform: rotate(0);&#125;            50% &#123;transform: rotate(0.5turn);&#125;            100% &#123;transform: rotate(1turn);&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            float: left;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation-name: box;            animation-duration: 2s;            animation-iteration-count: infinite;        &#125;        .one &#123;            animation-direction: reverse;        &#125;        .two &#123;            margin-left: 50px;            animation-direction: alternate;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;reverse&lt;/div&gt;    &lt;div&gt;alternate&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation-direction 属性演示\nanimation-fill-modeanimation-fill-mode 属性用来设置当动画不播放时（开始播放之前或播放结束之后）动画的状态（样式），属性的可选值如下：  \n\n\n\n值\n描述\n\n\n\nnone\n不改变动画的默认行为\n\n\nforwards\n当动画播放完成后，保持动画最后一个关键帧中的样式\n\n\nbackwards\n在 animation-delay 所指定的时间段内，应用动画第一个关键帧中的样式\n\n\nboth\n同时遵循 forwards 和 backwards 的规则\n\n\n示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes box &#123;            0% &#123;transform: rotate(0);&#125;            50% &#123;transform: rotate(0.5turn);&#125;            100% &#123;transform: rotate(1turn);&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            border-radius: 50%;            float: left;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation-name: box;            animation-duration: 2s;            animation-iteration-count: 1;            animation-fill-mode: forwards;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;forwards&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\nanimation-play-stateanimation-play-state 属性用来设置动画是播放还是暂停，属性的可选值如下：  \n\n\n\n值\n描述\n\n\n\npaused\n暂停动画的播放\n\n\nrunning\n正常播放动画\n\n\n示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes box &#123;            0% &#123;transform: rotate(0);&#125;            50% &#123;transform: rotate(0.5turn);&#125;            100% &#123;transform: rotate(1turn);&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            float: left;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation-name: box;            animation-duration: 2s;            animation-iteration-count: infinite;        &#125;        .one &#123;            animation-play-state: running;        &#125;        .two &#123;            margin-left: 50px;            animation-play-state: paused;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;running&lt;/div&gt;    &lt;div&gt;paused&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation-play-state 属性演示\nanimationanimation 属性是 animation-name、animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction、animation-fill-mode、animation-play-state 几个属性的简写形式，通过 animation 属性可以同时定义上述的多个属性，语法格式如下：  \nanimation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-fill-mode animation-play-state;\n其中每个参数分别对应上面介绍的各个属性，如果省略其中的某个或多个值，则将使用该属性对应的默认值。示例代码如下：  \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        @keyframes box &#123;            0% &#123;transform: rotate(0);&#125;            50% &#123;transform: rotate(0.5turn);&#125;            100% &#123;transform: rotate(1turn);&#125;        &#125;        div &#123;            width: 100px;            height: 100px;            border-radius: 50%;            float: left;            border: 3px solid black;            text-align: center;            line-height: 100px;            position: relative;            animation: box 2s linear 0s infinite alternate;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;animation&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：图：animation 属性演示\nfilter（滤镜）说起滤镜可能大家首先想到的就是 PhotoShop 之类的制图软件，通过此类软件的滤镜可以对图片进行美化。而在 CSS 中，我们无需借助任何软件也可以实现很多种滤镜效果，例如模糊效果、透明效果、色彩反差调整、色彩反相等等。另外，通过 CSS 中的滤镜还能对网页中的元素或者视频进行处理。本节我们就来学习一下 CSS 中滤镜的使用。\nCSS 中实现滤镜效果需要通过 filter 属性并配合一些函数来实现，如下所示：\n\n\n\n滤镜\n描述\n\n\n\nnone\n默认值，表示没有效果\n\n\nblur(px)\n为图像设置高斯模糊，默认值为 0，单位为像素，值较大越模糊\n\n\nbrightness(%)\n调整图像的亮度，默认值为 100％，代表原始图像；0％ 表示没有亮度，图像将完全变黑；当值超过 100％ 时图像将变得更亮\n\n\ncontrast(%)\n调整图像的对比度，默认值为 100％，代表原始图像；0％ 将使图像完全变黑；当值超过 100％ 时图像将获得更高的对比度\n\n\ndrop-shadow(h-shadow v-shadow blur spread color)\n为图像添加阴影效果，参数说明如下：h-shadow：必填值，指定水平方向阴影的像素值，若值为负，则阴影会出现在图像的左侧；v-shadow：必填值，指定垂直方向阴影的像素值，若值为负，则阴影会出现在图像的上方；blur：可选值，为阴影添加模糊效果，默认值为 0，单位为像素，值越大创建的模糊就越多（阴影会变得更大更亮），不允许使用负值；spread：可选值，默认值为 0，单位为像素。若值为正，则阴影将会扩展并增大；若值为负，则阴影会缩小；color：可选值，为阴影添加颜色，如未指定，则由浏览器来绝对，通常为黑色。注意：Chrome、Safari 和 Opera 等浏览器不支持第 4 个参数，如果添加，则不会有任何效果\n\n\ngrayscale(%)\n将图像转换为灰度图像，默认值为 0%，表示原始图像；100％ 表示将图像完全变成灰度图像（即黑白图像），不允许为负值\n\n\nhue-rotate(deg)\n给图像应用色相旋转，该值用来定义色环的度数，默认值为 0deg，代表原始图像，最大值为 360deg\n\n\ninvert(%)\n反转图像，默认值为 0%，表示原始图像；100% 则表示完全反转，不允许使用负值\n\n\nopacity(%)\n设置图像的不透明度，默认值为 100%，表示原始图像；0% 表示完全透明，不允许使用负值\n\n\nsaturate(%)\n设置图像的饱和度，默认值为 100%，表示原始图像；0% 表示图像完全不饱和，不允许使用负值\n\n\nsepia(%)\n将图像转换为棕褐色，默认值为 0%，表示原始图像；100% 表示图像完全变成棕褐色，不允许使用负值\n\n\nurl()\nurl() 函数用来指定一个 XML 文件，文件中设置了一个 SVG 滤镜，并且可以包含一个锚点来指定具体的滤镜元素\n\n\ninitial\n将属性设置为其默认值\n\n\ninherit\n从父元素继承此属性的值\n\n\n提示：这些 CSS 函数的参数值基本上都在 01（0%100%）之间，但也有几个例外，比如 blur() 函数的参数值以像素为单位，而 hue-rotate() 函数的参数值则是以 “deg” 为单位。\n【示例】下面通过一个示例来演示 CSS 中滤镜的使用：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 200px;            height: 200px;            float: left;            position: relative;        &#125;        div span &#123;            position: absolute;            top: 50%;            left: 50%;            transform: translate(-50%, -50%);            color: white;            text-shadow: 1px 1px 2px black;        &#125;        img &#123;            width: 100%;        &#125;        div img.blur &#123;            filter: blur(4px);        &#125;        div img.brightness &#123;            filter: brightness(250%);        &#125;        div img.contrast &#123;            filter: contrast(180%);        &#125;        div img.grayscale &#123;            filter: grayscale(100%);        &#125;        div img.huerotate &#123;            filter: hue-rotate(180deg);        &#125;        div img.invert &#123;            filter: invert(100%);        &#125;        div img.opacity &#123;            filter: opacity(50%);        &#125;        div img.saturate &#123;            filter: saturate(7);        &#125;        div img.sepia &#123;            filter: sepia(100%);        &#125;        div img.shadow &#123;            filter: drop-shadow(8px 8px 10px green);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;img src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;                   &lt;span&gt;原始图像&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;blur&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;      &lt;span&gt;blur(4px)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;brightness&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;&lt;span&gt;brightness(250%)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;contrast&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;  &lt;span&gt;contrast(180%)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;grayscale&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt; &lt;span&gt;grayscale(100%)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;huerotate&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt; &lt;span&gt;hue-rotate(180deg)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;invert&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;    &lt;span&gt;invert(100%)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;opacity&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;   &lt;span&gt;opacity(50%)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;saturate&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;  &lt;span&gt;saturate(7)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;sepia&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;     &lt;span&gt;sepia(100%)&lt;/span&gt;&lt;/div&gt;    &lt;div&gt;&lt;img class=&quot;shadow&quot; src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;    &lt;span&gt;drop-shadow(8px 8px 10px green)&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n  \n另外，您也可以为同一个元素使用多个滤镜效果，只需要将每个滤镜函数使用空格分隔，示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            width: 300px;            height: 300px;            position: relative;        &#125;        div span &#123;            position: absolute;            top: 50%;            left: 50%;            transform: translate(-50%, -50%);            color: white;            text-shadow: 1px 1px 2px black;        &#125;        img &#123;            width: 100%;            filter: sepia(90%) saturate(400%) brightness(150%);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;img src=&quot;./tulip.jpg&quot; alt=&quot;tulip&quot;&gt;&lt;span&gt;sepia(90%) saturate(400%) brightness(150%)&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：滤镜的组合使用\n注意：在组合使用多个滤镜效果时，要特别注意使用的顺序，否则会产生意料之外的效果，例如在使用 grayscale() 之后再使用 sepia() 将产生一个完整的灰度图片。\n不仅仅是图像，任何 HTML 元素都可以使用滤镜效果，例如文本、视频等都可以使用滤镜来美化，示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            filter: blur(2px) contrast(50%) brightness(80%);        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;说起滤镜可能大家首先想到的就是 PhotoShop 之类的制图软件，通过此类软件的滤镜可以对图片进行美化。而在 CSS 中，我们无需借助任何软件也可以实现很多种滤镜效果，例如模糊效果、透明效果、色彩反差调整、色彩反相等等。另外，通过 CSS 中的滤镜还能对网页中的元素或者视频进行处理。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下图所示：\n图：为页面中的其它元素设置滤镜效果\n提示：IE 浏览器不支持 filter 属性\ncolumn（多列布局）当需要在页面中展示大量文本时，如果每段的文本都很长，阅读起来就会非常麻烦，有可能读错行或读串行。为了提高阅读的舒适性，CSS3 中引入了多列布局模块，用于以简单有效的方式创建多列布局。所谓多列布局指的就是您可以将文本内容分成多块，然后让这些块并列显示，类似于报纸、杂志那样的排版形式，如下图所示：\n图：多列布局演示\nCSS3 中提供了一系列实现多列布局的属性，如下表所示：\n\n\n\n属性\n说明\n\n\n\ncolumn-count\n指定元素应该分为几列\n\n\ncolumn-fill\n指定如何填充每个列\n\n\ncolumn-gap\n指定列与列之间的间隙\n\n\ncolumn-rule\n所有 column-rule-* 属性的简写形式\n\n\ncolumn-rule-color\n指定列与列之间边框的颜色\n\n\ncolumn-rule-style\n指定列与列之间边框的样式\n\n\ncolumn-rule-width\n指定列与列之间边框的宽度\n\n\ncolumn-span\n指定元素应该横跨多少列\n\n\ncolumn-width\n指定列的宽度\n\n\ncolumns\ncolumn-width 与 column-count 属性的简写属性\n\n\ncolumn-countcolumn-count 属性用来设置将元素分为几列，属性的可选值如下：\n\n\n\n值\n描述\n\n\n\nnumber\n使用具体数值将元素划分为指定的列数\n\n\nauto\n默认值，由其他属性决定具体的列数，比如 column-width\n\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            column-count: 4;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。&lt;br&gt;    CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下：\n图：column-count 属性演示\ncolumn-fillcolumn-fill 属性用来设置如何填充每个列，属性的语法格式如下：\n\n\n\n值\n描述\n\n\n\nbalance\n默认值，根据其他列属性值使列的高度尽可能平衡\n\n\nauto\n按顺序对每个列进行填充，列的高度会各有不同\n\n\ncolumn-gapcolumn-gap 属性用来设置列与列之间的间隙，属性的可选值如下：\n\n\n\n值\n描述\n\n\n\nlength\n将列与列之间的间隔设置为指定的宽度\n\n\nnormal\n将列与列之间的间隔设置为与 font-size 属性相同的大小，即 1em\n\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            column-count: 3;            column-gap: 10px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。&lt;br&gt;    CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下：\n图：column-gap 属性演示\ncolumn-rulecolumn-rule 属性是一个简写属性，它与 border 属性非常相似，用来设置列与列之间边框的宽度、样式和颜色。 column-rule 属性的语法格式如下：\ncolumn-rule: column-rule-width column-rule-style column-rule-color;\n其中 column-rule-width 表示边框的宽度；column-rule-style 表示边框的样式，下表中列举了一些样式的可选值；column-rule-color 表示边框的颜色。\n\n\n\n值\n描述\n\n\n\nnone\n不定义边框样式\n\n\nhidden\n隐藏边框样式\n\n\ndotted\n定义点状边框\n\n\ndashed\n定义虚线边框\n\n\nsolid\n定义实线边框\n\n\ndouble\n定义双实线边框\n\n\ngroove\n定义 3D grooved 边框，边框效果取决于宽度和颜色值\n\n\nridge\n定义 3D ridged 边框，边框效果取决于宽度和颜色值\n\n\ninset\n定义 3D inset 边框，边框效果取决于宽度和颜色值\n\n\noutset\n定义 3D outset 边框，边框效果取决于宽度和颜色值\n\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            column-count: 3;            column-gap: 10px;            column-rule: 5px solid #090;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。&lt;br&gt;    CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下：\n图：column-rule 属性演示\n另外，您也可以直接使用 column-rule-width、column-rule-style、column-rule-color 三个属性来分别设置列与列之间边框的样式，如下所示：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            column-count: 3;            column-gap: 10px;            column-rule-width: 5px;            column-rule-style: solid;            column-rule-color: #090;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。&lt;br&gt;    CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\ncolumn-spancolumn-span 属性用来设置元素应该跨越多少列，属性的可选值如下：\n\n\n\n值\n描述\n\n\n\nnone\n默认值，表示元素不跨越列\n\n\nall\n表示元素横跨所有列\n\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            column-count: 3;            column-gap: 10px;            column-rule: 5px solid #090;        &#125;        h1 &#123;            column-span: none;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;    &lt;h1&gt;CSS是什么？&lt;/h1&gt;        CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。        CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下：\n图：column-span 属性演示   \ncolumn-widthcolumn-width 属性用来设置每个列的宽度，属性的可选值如下：\n\n\n\n值\n描述\n\n\n\nauto\n由浏览器决定列的宽度\n\n\nlength\n为每个列指定具体的宽度\n\n\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            column-gap: 10px;            column-rule: 5px solid #090;            column-width: 200px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。        CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下：\n图：column-width 属性演示\ncolumnscolumns 属性是一个简写属性，用来同时设置列的宽度和列的数量，语法格式如下：\ncolumns: column-width column-count;\n其中 column-width 表示每个列的宽度，column-count 则表示列的数量。\n示例代码如下：\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        div &#123;            columns: 100px 4;            column-rule: 5px solid #090;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        CSS 是“Cascading Style Sheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。        CSS 的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n运行结果如下：\n图：columns 属性演示\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"Next.js","url":"/1970/01/01/Next-js/","content":"哥们还没学过，因为logo可爱所以就放上来了😄\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"Node.js","url":"/1970/01/01/Node-js/","content":"哥们还没学过，因为logo可爱所以就放上来了😄\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"HTML 学习笔记","url":"/2023/07/06/HTML/","content":"介绍HTML(hypertext markup langage)超文本标记语言 主要用于描述网页的结构和内容\n学习HTML主要学习HTML标签以及标签对应的属性, 标签就是一些特殊的符号\n  比如 \n  img图片标签(属性src,width,height,alt,tilte),在网页中显示图片\n  a超链接标签(属性href, target ), 实现网页的跳转\n  html文件名后缀名是.html , 使用浏览器可以直接解析html文件,因为浏览器里面有一个渲染引擎\n基本结构&lt;!DOCTYPE html&gt;&lt;!-- 文档类型 doc=&gt;document文档 type类型的意思   就是告诉别人,我这个文档是html --&gt;&lt;html&gt;    &lt;!-- head头部标签,这标签里面放的是,修饰网页的东西 比如引入样式表,引入js脚本文件,设置字符集,设置页面标题 --&gt;    &lt;head&gt;        &lt;!-- title标签设置的是网页的标题 --&gt;        &lt;title&gt;我是网页标题&lt;/title&gt;        &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;/head&gt;    &lt;!-- body身体主体标签,这标签里面就是网页的内容 --&gt;    &lt;body&gt;        hello world!!!你好,html    &lt;/body&gt;&lt;/html&gt;\n\n标签分类&lt;!--     HTML标签分类会分成两大类    第一大类 单标签(只有结束标签)     语法:    &lt;标签名 /&gt; 或者 &lt;标签名/&gt; 或者 &lt;标签名&gt;    比如:    &lt;br /&gt;    &lt;hr /&gt;    &lt;input /&gt;    &lt;img /&gt;    第二大类 双标签(有开始标签,也有结束标签)    语法:    &lt;标签名&gt;标签内容&lt;/标签名&gt;    比如:     &lt;div&gt;div的内容&lt;/div&gt;    &lt;span&gt;span的内容&lt;/span&gt;    &lt;p&gt;p段落的内容&lt;/p&gt;    &lt;a&gt;链接内容&lt;/a&gt;     --&gt;    &lt;!-- 另外,在HTML标签不区分大小写,但是建议&quot;小写&quot; --&gt;\n\n文本修饰标签&lt;!-- 加粗 b(bold) 与 strong(强壮)--&gt;    &lt;b&gt;内容&lt;/b&gt;    &lt;strong&gt;内容&lt;/strong&gt;    &lt;br /&gt;    &lt;!-- 倾斜,斜体 i(italic) 与 em --&gt;    &lt;i&gt;内容&lt;/i&gt;    &lt;em&gt;内容&lt;/em&gt;    &lt;br /&gt;    &lt;!-- 下划线 u(underline) 与 ins --&gt;    &lt;u&gt;内容&lt;/u&gt;    &lt;ins&gt;内容&lt;/ins&gt;    &lt;br /&gt;    &lt;!-- 删除线 s 与 del --&gt;    &lt;s&gt;内容&lt;/s&gt;    &lt;del&gt;内容&lt;/del&gt;    &lt;br /&gt;    &lt;!-- 可以嵌套使用 --&gt;    &lt;u&gt;&lt;i&gt;&lt;b&gt;内容&lt;/b&gt;&lt;/i&gt;&lt;/u&gt;    &lt;br /&gt;    &lt;!-- 其中strong,ins,em,del是HTML5新增的语义化标签!更利于SEO优化,结构更清晰!  推荐使用使用语义化标签! --&gt;    &lt;!-- 上标 sup --&gt;    &lt;!-- 下标 sub --&gt;    a2 + b2    &lt;br/&gt;    a&lt;sup&gt;2&lt;/sup&gt; + b&lt;sub&gt;2&lt;/sub&gt;\n\nimg标签img标签常用属性\n\nsrc是source单词的简写, 设置图片文件所在路径\nborder设置图片的边框 默认图片边框大小为0 0代表没有边框 属性取值可以写数值\nwidth设置图片的宽度, 默认不设置width,将使用图片默认的宽度  该属性取值可以写数值或者百分比,百分比会相对父元素\nheight设置图片的高度, 默认不设置height,将使用图片默认的高度  该属性取值可以写数值或者百分比,百分比会相对父元素  注意: 如果只设置width或者height其中一个, 另一个会跟随图片原始宽度高度比例,进行等比例缩小放大\ntitle设置鼠标悬停在图片元素上显示的文本内容信息\nalt设置图片无法正常显示时,显示在图片元素上的替换信息\nalign设置图片元素”周围文字”的对齐方式 取值 left center right\n\n路径问题路径就是文件的存放位置经过的路线为什么需要路径? 因为我们引入图片,引入外链式样式css文件,引入外链式脚本js文件以及超链接跳转到本地某个文件的时候,都需要通过路径找到对应的文件\n路径主要又分为两种\n\n第一种: 绝对路径, 以盘符开始的路径 , 比如 g:&#x2F;abc&#x2F;1.txt, 绝对路径移植性差,需要保证同样的盘符下有同样的文件\n\n&lt;!-- \\反斜杠  /正斜杠 在window系统下, 正斜杠和反斜杠都可以识别, 但是在linux下只能使用正斜杠 而且linux系统下没有盘符的概念--&gt;&lt;h2&gt;绝对路径演示&lt;/h2&gt;&lt;img src=&quot;E:\\GZ2279\\①HTMLCSS\\02-HTML\\4-代码\\images\\01.jpg&quot; width=&quot;150&quot; /&gt;&lt;img src=&quot;E:/GZ2279/①HTMLCSS/02-HTML/4-代码/images/01.jpg&quot; width=&quot;150&quot; /&gt;&lt;!-- 有些浏览器,对绝对路径支持不是很友好, 需要添加file:/// 前缀 --&gt;&lt;img src=&quot;file:///E:\\GZ2279\\①HTMLCSS\\02-HTML\\4-代码\\images\\01.jpg&quot; width=&quot;150&quot; /&gt;&lt;img src=&quot;file:///E:/GZ2279/①HTMLCSS/02-HTML/4-代码/images/01.jpg&quot; width=&quot;150&quot; /&gt;&lt;h2&gt;互联网的路径(直接使用网上的路径, 这种路径一般是https://或者http://开头的 前提是电脑需要连接互联网)&lt;/h2&gt;&lt;img src=&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot; /&gt;\n\n\n❤第二种: 相对路径, 相对路径就是会根据一个参考物,进行参考,这个参考物一般是”当前文件”\n\n&lt;h1&gt;相对路径又有三种常见关系&lt;/h1&gt;&lt;h2&gt;第一种: 同级关系 目标文件在当前路径下 ./就可以代表当前路径&lt;/h2&gt;&lt;img src=&quot;./P_007.jpg&quot; /&gt;&lt;h2&gt;❤第二种: 下一级关系 目标文件在当前路径的某个目录下 需要告诉文件夹名称&lt;/h2&gt;&lt;img src=&quot;./images/P_057.jpg&quot; /&gt;&lt;img src=&quot;./images/a/b/c/P_033.jpg&quot; /&gt;&lt;h2&gt;第三种: 上一级关系 目标文件在当前路径的上一级路径下 ../代表上一级&lt;/h2&gt;&lt;img src=&quot;../P_089.jpg&quot; /&gt;&lt;img src=&quot;../../P_069.jpg&quot; /&gt;\n\n超链接a标签超链接是用于实现网页之间跳转的标签语法：&lt;a href=&quot;跳转目标地址&quot; target=&quot;目标地址打开方式&quot;&gt;超链接的标签内容&lt;/a&gt;\n\n❤外部链接 跳转到互联网的某个地址 一般是https:&#x2F;&#x2F;或者http:&#x2F;&#x2F;开头的\n❤内部链接 跳转到本地文件 如果浏览器可以打开的文件,浏览器会帮我们打开 浏览器无法打开的文件,浏览器会提示我们下载\n❤空链接 要记 就是点击以后,不会跳转的链接 空链接主要用于书写css样式或者触发js事件的时候使用\n❤图片链接 要记 就是点击图片以后,会跳转到某个链接 使用a标签包括img图片标签\n链接到本页的某个部分(锚点)\n\n 08-超链接(a链接,a标签).html \n阻止默认事件\nonclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。\n\n&lt;a href=&quot;javascript:void(0);&quot;  οnclick= &quot;myjs( )&quot;&gt;  Click Me  &lt;/a&gt;\n\n和void(0)一样，都返回”undefined”\n&lt;a href=&quot;javascript:;&quot; &gt;  Click Me  &lt;/a&gt;\n\n\n是网上很常见的代码，#是标签内置的一个方法，用这种方法点击后网页后返回到页面的最顶端所以又有了“##”“#!”等,尽管解决了返回顶部的问题但仍存在其他缺陷\n\n&lt;a href=&quot;#&quot;&gt;  Click Me  &lt;/a&gt;\n\n\n事件处理函数的工作机制中，在给某元素添加事件处理函数后，一旦事件发生，相应JavaScript代码就会执行，所调用的JavaScript代码的返回值被传递给事件处理函数。当我们给a标签添加onclick事件处理函数并点击a触发其后，如果相应JavaScript代码返回true，onclick事件处理函数就会认为这个链接呗点击了，同样的若返回false即会认为链接未被点击\n当点击a标签时，JavaScript代码返回值为false，故此链接默认行为未被触发。\n\n\n&lt;a href=&quot;http://www.baidu.com&quot; οnclick=&quot; myjs(); return false; &quot;&gt;   Click Me   &lt;/a&gt;  &lt;a href=&quot;http://www.baidu.com&quot; οnclick=&quot; return false; &quot;&gt;  Click Me  &lt;/a&gt;\n\n\npreventDefault()阻止事件的默认行为但不支持IE，所以在IE中使用returnValue阻止事件默认行为\n\nvar test = document.getElementByTagName(&#x27;a&#x27;); function stopDefault( e )&#123;    if ( e &amp;&amp; e.preventDefault )       e.preventDefault();      else         window.event.returnValue = false;  &#125; test.onclick = function(e) &#123;      stopDefault(e); &#125; \n\n\n\n\ndownload属性(HTML 5 新增)： 接受一个 filename (文件名) 作为属性值或不设置任何属性，此属性指示浏览器下载 URL 而不是导航到它，因此将提示用户将其保存为本地文件。\n\n&lt;h2&gt;不添加download属性 直接在浏览器中打开图片&lt;/h2&gt;&lt;a href=&quot;./images/btn.png&quot;&gt;图片&lt;/a&gt;&lt;h2&gt;添加download属性,download需要使用http://协议或者https://协议才可以生效&lt;/h2&gt;&lt;!-- 我们可以在vscode中安装一个live server插件,使用这个插件打开的网页,就是一个本地服务器的网页 ,http协议开头的,  live server实时刷新的功能  --&gt;&lt;a href=&quot;./images/btn.png&quot; download&gt;下载图片&lt;/a&gt;&lt;h2&gt;download设置属性值, 这个属性值将作为下载的文件名&lt;/h2&gt;&lt;a href=&quot;./images/btn.png&quot; download=&quot;美女&quot;&gt;下载图片&lt;/a&gt;&lt;h2&gt;download设置属性值, 这个属性值将作为下载的文件名, 如果指定的download属性值中有\\ /的话,会被转成下划线&lt;/h2&gt;&lt;a href=&quot;./images/btn.png&quot; download=&quot;性感\\美女/01&quot;&gt;下载图片&lt;/a&gt;\n\n 01-超链接补充属性download.html \n\n基准参考点base标签 单标签 可以设置所有超链接的href属性以及target属性,base标签只能出现一次!!!\n\n&lt;base href=&quot;https://ent.163.com&quot; target=&quot;_blank&quot; /&gt;\n\n 02-基准参考点base标签.html \n表格基本使用以及表格属性\ntable表示表格\ntr表示表格的行\ntd或者th表格的列(单元格) th包括的内容会进行加粗并水平居中显示\ncaption设置表格的标题\n\ntable标签的属性:\n❤border设置表格的边框:\n表格边框合并:border&#x3D;”1”\n\nbordercolor设置表格颜色\n\n❤width设置表格的宽度 数值或者百分比\n\nheight设置表格的高度 数值或者百分比\n\n❤align设置整个表格的水平对齐方式 left center right\n\nbgcolor设置背景颜色\n\nbackground设置背景图片, 背景图片会覆盖背景颜色\n\n❤cellpadding设置单元格内容到边框的距离\n\n❤cellspacing设置单元格与单元格之间的距离\n\n❤rules&#x3D;”all”合并边框线\n\n\n 09-表格基本使用以及表格属性.html \ntr的属性:\n​    tr的align,bgcolor,background属性同table属性\n​    align属性是设置tr中所有单元格内容水平对齐方式,取值:left(左 默认),center(居中),right(右)\n​    还有一个valign属性是设置单元格内容垂直对齐方式,取值:top(上),middle(默认,垂直居中),bottom(下)\n\n小结:\n\ntr的align是设置单元格内容的水平对齐方式\n\n如果tr跟table都设置的bgcolor跟background属性,以tr设置的为准,”靠近原则”\n\n\n 10-tr的属性.html \nth,td单元格的属性\n​    th跟td都是单元格标签,但是th包裹的内容会加粗并且水平居中显示\n​    width,height,align,valign,bgcolor,background属性跟tr设置的时候,效果是一样的\n\n 11-th,td单元格的属性.html \n合并单元格两个th,td单元格比较重要的属性:\n\nrowspan row行的意思,跨行合并单元格,垂直(上下)方向合并几个单元格 取值数值\ncolspan column列的意思,跨列合并单元格,水平(左右)方向合并几个单元格 取值数值\n\n合并单元格的步骤\n1.先找到你要合并的单元格,随便改成相同的内容\n2.确定左右合并单元格,还是上下合并单元格,再决定使用对应colspan或者rowspan,要几个单元格合成1个单元格\n3.删除多余的单元格\n 12-合并单元格.html \nthead,tbody,tfoot表格结构化标签\n没有被thead,tbody,tfoot这三个结构化标签包裹的内容,默认会把内容都放在一个tbody中\nthead表示表格的头部\ntbody表示表格的身体\ntfoot表示表格的底部\n\nthead,tbody,tfoot都有align跟valign属性; 设置align跟valign属性的时候优先级:靠近原则\n 13-thead,tbody,tfoot表格结构化标签.html \n表单表单介绍\n表单是什么,就是一些可以让你填写或者选择的东西 \n表单作用是什么,收集用户所填写或者选择信息\n表单组成有哪些, 有三部分 :\n\n\n表单域(容器,存放表单的地方)\n提示信息(告诉用户需要填写的信息是什么)\n表单控件(收集用户信息的东西, 比如文本框,  单选按钮等 )\n\nform标签表示表单域\nform标签的action属性,表示数据提交到哪里去, 取值是一个url\n\nform标签的method属性,表示数据提交的方式 get(默认)或者post\n\nget提交的数据会拼接到url(url是统一资源定位符,简单理解就是网址)地址栏中, 拼接形式是 url?键名1&#x3D;键值1&amp;键名2&#x3D;键值2…\n\npost提交的数据不会出现在url中\n\n注意: 表单控件需要设置name属性, 这样提交数据的时候,才是有效提交 并且后端才可以通过name属性区分是哪个控件提交过去的数据\n\n注意: 某些控件需要设置value属性,value属性才是真正提交到后端的数据\n\n\n&lt;!-- &lt;form action=&quot;https://www.baidu.com&quot; method=&quot;get&quot;&gt; --&gt;&lt;!-- &lt;form action=&quot;abc.html&quot; method=&quot;post&quot;&gt; --&gt;&lt;form action=&quot;abc.html&quot; method=&quot;get&quot;&gt;        &lt;!-- 表单控件分类有input标签,button标签,textarea标签以及select标签 --&gt;        &lt;!-- 网页中表单控件有很多种类, 但是HTML作者又不想每个种类都设计一个标签,所以设计了一个input标签,使用&quot;type属性&quot;去区分他们 --&gt;        &lt;!-- input是单标签 --&gt;        &lt;p&gt;文本框:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;/p&gt;        &lt;p&gt;密码框:&lt;input type=&quot;password&quot; name=&quot;userpass&quot; /&gt;&lt;/p&gt;        &lt;p&gt;            单选按钮(只能选择一个):            &lt;!-- 设置checked属性,就可以表示选中 --&gt;            &lt;!-- 想要实现单选功能, 需要把多个radio设置相同的name属性 设置相同name属性值以后,就会认为他们是一组单选按钮,那么只能选中其中一个了--&gt;            &lt;input type=&quot;radio&quot; checked name=&quot;sex&quot; value=&quot;man&quot; /&gt;男            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;woman&quot; /&gt;女        &lt;/p&gt;        &lt;p&gt;            复选框(可以多选):            &lt;!-- 设置checked属性,就可以表示选中 --&gt;            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;eat&quot; /&gt;吃饭            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; checked value=&quot;sleep&quot; /&gt;睡觉            &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;dadoudou&quot; /&gt;打豆豆        &lt;/p&gt;        &lt;p&gt;            上传文本框:            &lt;input type=&quot;file&quot; name=&quot;myfile&quot; /&gt;        &lt;/p&gt;        &lt;p&gt;            隐藏域(专门用于提交一些不想被用户看到的信息):            &lt;input type=&quot;hidden&quot; name=&quot;rsv_iqid&quot; value=&quot;0xb7cfebb10007ffd7&quot;&gt;        &lt;/p&gt;        &lt;!-- 通过value属性可以设置按钮等内容 --&gt;        &lt;p&gt;            &lt;!-- 普通按钮,不能提交数据,也不会重置数据 --&gt;            普通按钮:&lt;input type=&quot;button&quot; value=&quot;我是普通按钮&quot; /&gt;        &lt;/p&gt;        &lt;p&gt;            提交按钮:&lt;input type=&quot;submit&quot; value=&quot;提交数据&quot; /&gt;        &lt;/p&gt;        &lt;p&gt;            重置按钮:&lt;input type=&quot;reset&quot; value=&quot;重新填写&quot; /&gt;        &lt;/p&gt;        &lt;p&gt;            图片按钮:            &lt;!-- 通过src属性设置图片按钮的路径 --&gt;            &lt;!-- 图片按钮也有提交数据的功能 --&gt;            &lt;input type=&quot;image&quot; src=&quot;./images/btn.png&quot; /&gt;        &lt;/p&gt;    &lt;/form&gt;\n\n 04-表单控件-input标签.html \nbutton按钮&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;get&quot;&gt;       &lt;p&gt;           用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;       &lt;/p&gt;       &lt;p&gt;           &lt;button&gt;不设置type属性的按钮, 默认是提交按钮&lt;/button&gt;       &lt;/p&gt;       &lt;p&gt;           &lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt;       &lt;/p&gt;       &lt;p&gt;           &lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt;       &lt;/p&gt;       &lt;p&gt;           &lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt;       &lt;/p&gt;   &lt;/form&gt;\n\n项目标题标签label​     元素（描述标签）表示用户界面中某个元素的说明。\n​    lablel标签主要目的是为了提高用户体验。 为用户提高最优质的服务。\n\n​    概念：label 标签为 input 元素定义标注（标签）。\n​    作用：用于绑定一个表单控件, 当点击label标签的时候, 被绑定的表单控件就会获得输入焦点。\n\n​    如何绑定元素呢？\n​    第一种用法:使用label标签包裹要设置的内容和表单元素\n​    第二种用法:使用label中的for属性  for&#x3D;”id名” 表单元素需要设置一个id属性\n&lt;p&gt;       &lt;!-- 第一种用法:使用label标签包裹要设置的内容和表单元素 --&gt;       &lt;label&gt;用户名:&lt;input type=&quot;text&quot; /&gt;&lt;/label&gt;   &lt;/p&gt;   &lt;p&gt;       &lt;!-- 第二种用法:使用label中的for属性 for=&quot;id名&quot; 表单元素需要设置一个id属性 --&gt;       &lt;label for=&quot;myPass&quot;&gt;密码:&lt;/label&gt;       &lt;input type=&quot;password&quot; id=&quot;myPass&quot; /&gt;   &lt;/p&gt;   &lt;p&gt;       &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男&lt;/label&gt;        &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女&lt;/label&gt;   &lt;/p&gt;\n\n 06-项目标题标签label.html \nplaceholder属性\nplaceholder属性,占位符,当某些表单控件value值为空的时候,placeholder属性设置的值才会显示出来\nplaceholder属性,当input元素type为password, search, tel, text, url时，当表单控件为空时，控件中显示的内容\n\n&lt;p&gt;       &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; /&gt;   &lt;/p&gt;   &lt;p&gt;       &lt;!-- 通过value属性也可以设置表单控件默认显示的内容 --&gt;       &lt;input type=&quot;text&quot; value=&quot;zhangsan&quot; placeholder=&quot;请输入用户名&quot;&gt;   &lt;/p&gt;\n\n 07-placeholder属性.html \n多行文本框(文本域):&lt;!-- 通过rows设置高度 --&gt;&lt;!-- 通过cols设置宽度 --&gt;&lt;textarea rows=&quot;5&quot; cols=&quot;30&quot; placeholder=&quot;请进行一个简短的自我介绍~&quot;&gt;我是张三&lt;/textarea&gt;\n\n\n防止拖拽文本域resize\n\ntextarea &#123;    resize: none;    width: 300px;    height: 200px;&#125;\n\nselect下拉框\n通过option设置选项, 默认下拉框会选中第一项, 默认下拉框的宽度由最宽的选项内容决定\n给option选项设置selected属性,可以指定选中选中项\n如果option没有设置value属性,那么value属性值将使用option的标签内容 提交数据的时候,会提交选中项的value属性值\n\n&lt;select name=&quot;province&quot;&gt;\t&lt;option value=&quot;guangdong&quot;&gt;广东省&lt;/option&gt;\t&lt;option value=&quot;hunan&quot; selected&gt;湖南省&lt;/option&gt;\t&lt;option value=&quot;hubei&quot;&gt;湖北省&lt;/option&gt;\t&lt;option value=&quot;sichuan&quot;&gt;四川省&lt;/option&gt;\t&lt;option value=&quot;guangxi&quot;&gt;广西壮族自治区&lt;/option&gt;&lt;/select&gt;\n\n\nselect标签可以设置size属性,表示显示多少个选项\nselect标签可以设置multiple属性, 表示允许多选 可以按ctrl或者shift键\n使用optgroup标签,可以对选项进行分组\n\n&lt;select size=&quot;5&quot; multiple&gt;    &lt;!-- 使用optgroup标签,可以对选项进行分组 --&gt;    &lt;optgroup label=&quot;省份&quot;&gt;        &lt;option value=&quot;guangdong&quot;&gt;广东省&lt;/option&gt;        &lt;option value=&quot;hunan&quot; selected&gt;湖南省&lt;/option&gt;        &lt;option value=&quot;hubei&quot;&gt;湖北省&lt;/option&gt;        &lt;option value=&quot;sichuan&quot;&gt;四川省&lt;/option&gt;        &lt;option value=&quot;jiangxi&quot;&gt;江西省&lt;/option&gt;    &lt;/optgroup&gt;    &lt;optgroup label=&quot;自治区&quot;&gt;        &lt;option value=&quot;guangxi&quot;&gt;广西壮族自治区&lt;/option&gt;        &lt;option value=&quot;ningxia&quot;&gt;宁夏回族自治区&lt;/option&gt;    &lt;/optgroup&gt;    &lt;optgroup label=&quot;直辖市&quot;&gt;        &lt;option value=&quot;chongqing&quot;&gt;重庆市&lt;/option&gt;        &lt;option value=&quot;shanghai&quot;&gt;上海市&lt;/option&gt;        &lt;option value=&quot;beijing&quot;&gt;北京市&lt;/option&gt;        &lt;option value=&quot;tianjin&quot;&gt;天津市&lt;/option&gt;    &lt;/optgroup&gt;&lt;/select&gt;\n\n\nmultiple除了可以让下拉框可以选择多个选项,还可以让file上传框允许选择多个文件\n\n&lt;input type=&quot;file&quot; multiple /&gt;\n\n 10-表单控件-select（下拉框）.html \n表单控件常用属性\n通过src属性可以设置图片按钮的图片, 通过width属性设置宽度, 通过height属性设置高度\n\n&lt;input type=&quot;image&quot; src=&quot;./images/btn_reg.png&quot; width=&quot;300&quot; /&gt;\n\n\ndisabled禁用控件,不能修改值也不能输入值 数据不会提交\n\n&lt;input type=&quot;text&quot; name=&quot;username2&quot; disabled value=&quot;zhangsan2&quot;&gt;\n\n\nreadonly只读 内容不允许修改, 但是数据还可以提交\n\n&lt;input type=&quot;text&quot; name=&quot;username3&quot; readonly value=&quot;zhangsan3&quot;&gt;\n\n\nautofocus自动获取焦点,仅第一个使用的表单控件可以生效\n\n&lt;input type=&quot;text&quot; autofocus /&gt;\n\n\nautocomplete：所有input元素，用于表单的自动填充功能       取值 off关闭自动填充 或者 on(默认,开启自动填充)\n\n注意：想要使用autocomplete属性触发表单自动填充功能, 前提是这个表单控件需要有一个name属性, 并且成功提交过数据,才会把之前成功提交的数据记录下来 \n&lt;input type=&quot;text&quot; name=&quot;myAge&quot; placeholder=&quot;请输入年龄&quot; autocomplete=&quot;off&quot;/&gt;&lt;input type=&quot;text&quot; name=&quot;myAge&quot; placeholder=&quot;请输入年龄&quot; autocomplete=&quot;on&quot; /&gt;\n\n\nrequired：绝大部分input元素,表示此值为必填项\nmaxlength：当input元素type为password, search, tel, text, url时，value 的最大长度（最多字符数目）\nsize：当input元素email, password, tel, text时,控件的大小 , 取值数值, 默认20\n\n&lt;input type=&quot;text&quot; required maxlength=&quot;6&quot; size=&quot;30&quot; /&gt;\n\n 11-表单控件常用属性.html \nH5新增表单输入类型\nnumber：只能输入数字的输入框。\nmax属性设置最大值\nmin属性设置最小值\nstep设置步长值\n\n\n\n&lt;p&gt;\t数字的输入框: &lt;input type=&quot;number&quot; value=&quot;5&quot; min=&quot;1&quot; max=&quot;12&quot; step=&quot;2&quot; /&gt;&lt;/p&gt;\n\n\nemail：编辑邮箱地址的输入框。类似 text 输入，但在支持的浏览器上会有邮箱格式的规则验证提示。\n\n&lt;p&gt;邮箱: &lt;input type=&quot;email&quot; /&gt;&lt;/p&gt;\n\n\nsearch (H5新增)：用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。\n\n&lt;p&gt;搜索框: &lt;input type=&quot;search&quot; /&gt;&lt;/p&gt;\n\n\ntel (H5新增)：用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。\n\n&lt;p&gt;电话号码:&lt;input type=&quot;tel&quot; /&gt;&lt;/p&gt;\n\n\nurl (H5新增)：用于输入 URL 的控件。类似 text 输入，在支持的浏览器上会有URL的规则验证提示，在支持动态键盘的设备上有相应的键盘。\n\n&lt;p&gt;网址:&lt;input type=&quot;url&quot; /&gt;&lt;/p&gt;\n\n表单日期类型：&lt;!-- week：用于输入以年和周数组成的日期，不带时区。 --&gt;      &lt;p&gt;星期:&lt;input type=&quot;week&quot; /&gt;&lt;/p&gt;      &lt;!-- month (H5新增)：输入年和月的控件，不带时区。 --&gt;      &lt;p&gt;月份:&lt;input type=&quot;month&quot; /&gt;&lt;/p&gt;      &lt;!-- time (H5新增)：于输入时间的控件，不包括时区。 --&gt;      &lt;p&gt;时间:&lt;input type=&quot;time&quot; /&gt;&lt;/p&gt;      &lt;!-- date (H5新增)：输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时会打开日期选择器或年月日的数字滚轮。 --&gt;      &lt;p&gt;日期:&lt;input type=&quot;date&quot; /&gt;&lt;/p&gt;      &lt;!-- datetime-local(H5新增)：输入日期和时间的控件，使用户所在时区。 --&gt;      &lt;!-- 在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。(目前支持的浏览器为数不多) --&gt;      &lt;p&gt;日期时间:&lt;input type=&quot;datetime-local&quot; /&gt;&lt;/p&gt;\n\n表单颜色类型&lt;p&gt;\t颜色:&lt;input type=&quot;color&quot; /&gt;&lt;/p&gt;\n\n表单范围控制类型&lt;p&gt;\t范围:\t&lt;!-- max属性设置最大值 --&gt;\t&lt;!-- min属性设置最小值 --&gt;\t&lt;!-- step设置步长值 --&gt;\t&lt;input type=&quot;range&quot; value=&quot;20&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;1&quot; name=&quot;myScore&quot; /&gt;&lt;/p&gt;\n\n 12-H5新增表单输入类型.html \n常用布局标签div与spandiv的特点   1. 独占一行,默认只要有标签内容,不管内容多或者少,都会占满一行\n   2. 不会标签内容的样式(不会加粗,不会倾斜等)\n   3. div上下无空白距离\n   4. 所以div作为容器使用, 方便设置CSS样式\n\nspan的特点   1. 不独占一行, 一行可以存放多个, 直到放不下才会换行\n   2. 不会标签内容的样式(不会加粗,不会倾斜等)\n   3. span上下左右无空白距离\n   4. span的宽度由内容决定\n   5. span也是作为容器使用,方便设置CSS样式\n\nHTML全局属性\n全局属性是所有 HTML 元素共有的属性；它们可以用于所有元素，尽管它们可能对某些元素没有影响。\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes\n\nclass：我们将class的属性值称之为“类名”，只要是拥有相同的class的属性值  不管是什么标签  我们都可以将其称之为一类！class属性一般多用于CSS中\n\n设置多个类名的时候,多个类名之间使用空格隔开\n\n\n&lt;b class=&quot;one two three&quot;&gt;bbb&lt;/b&gt;&lt;span class=&quot;three&quot;&gt;span&lt;/span&gt;\n\n\nid：id属性是标签的唯一标识，一个页面中可以有很多id属性，但是每个标签的id属性的值必须是唯一的 ;  它就好多我们的身份证号码一样！id属性一般多用于JavaScript中\n\n&lt;div id=&quot;div1&quot;&gt;id为div1的内容&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;id为div2的内容&lt;/div&gt;\n\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"React","url":"/1970/01/01/React/","content":"哥们还没学过，因为logo可爱所以就放上来了😄\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"HTML5 学习笔记","url":"/2023/07/06/HTML5/","content":"HTML5 简介HTML5 不仅是定义 HTML 标准的最新的版本，还是一系列用来制作现代富web内容的相关技术总称。\nHTML5 具有新的元素，属性和行为，并具有更大的技术集，允许构建更多样化和更强大的网站和应用程序。这个集合有时称为HTML5和它的朋友们，不过大多数时候仅缩写为一个词 HTML5。\nHTML5 及其相关技术是作为一系列小型标准而制定的甚至为某些技术进行了高度的细化，其标准内容设计为所有Open Web开发人员都可以使用，但是这样做的弊端是难以全面掌握指定的各个标准情况并且部分标准还存在一些歧义，导致浏览器中表现不一致。\n我们将根据HTML5功能分为以下8大类：\n\n语义：开发者可以更细致的描述文档结构，提高文档的可读性与对搜索引擎的友好。\n通信：能够让你和服务器之间通过创新的新技术方法进行通信。\n离线 &amp; 存储：能够让网页在客户端本地存储数据以及更高效地离线运行。\n多媒体：使 video 和 audio 成为了在所有 Web 中的一等公民。\n2D&#x2F;3D 绘图 &amp; 效果：提供了一个更加分化范围的呈现选择。\n性能 &amp; 集成：提供了非常显著的性能优化和更有效的计算机硬件使用。\n设备访问：能够处理各种输入和输出设备。\nCSS3: 让作者们来创作更加复杂的主题吧！\n\n新增语义标签概念：HTML5 引入了新的HTML元素，通过使用标准语义去描述web文档的结构，使得文档更精确，提高SEO性能与用户体验。\n\n&lt;header&gt;(常用)：标签定义文档的页眉（介绍信息）。\n&lt;main&gt;： 标签规定文档的主要内容。元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。\n&lt;footer&gt;(常用)：标签定义文档或节的页脚，通常包含版权或法律声明，有时还包含一些链接。在部分的情况下，页脚可能包含切片内容的发布日期，许可证信息等。&lt;article&gt;，&lt;section&gt;，&lt;aside&gt;，和&lt;nav&gt;可以有自己的&lt;footer&gt;。尽管有页脚的名称，页脚也不一定位于页面或节的末尾。\n&lt;section&gt;(常用)：标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分根据语义进行相关分组。\n&lt;article&gt;(常用)：标签规定独立的自包含内容。它不单指主要内容，还可以用于注释和小部件。该标签常用环境：论坛帖子、报纸文章、博客条目、用户评论。\n&lt;nav&gt;(常用)：包含经常出现在网站上的导航链接。导航可以具有主菜单和辅助菜单，但是不能将一个&lt;nav&gt;元素嵌套在另一个 &lt;nav&gt;元素中。\n&lt;aside&gt;(常用)：元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框。\n&lt;hgroup&gt;(常用)： 代表文档章节所属的多级别的目录，它将多个&lt;h1&gt;至&lt;h6&gt;的子元素组装到一起。\n\n&lt;hgroup&gt;    &lt;h1&gt;HTML&lt;/h1&gt;    &lt;h2&gt;HTML5标准 — Last Updated 12 August 2020&lt;/h2&gt;&lt;/hgroup&gt;&lt;p&gt;This course will start with a brief introduction about the limit of a function. Then we will describe how the idea of derivative emerges in the Physics and Geometry fields. After that, we will explain that the key to master calculus is …&lt;/p&gt;\n\n\n&lt;figure&gt;(常用)： 标签规定独立的流内容（图像、图表、照片、代码等等）。 经常与说明（caption） &lt;figcaption&gt; 配合使用, 并且作为一个独立的引用单元\n&lt;figcation&gt;(常用)： 是与其相关联的图片的说明&#x2F;标题，用于描述其父节点 &lt;figure&gt; 元素里的其他数据。该标签在&lt;figure&gt;块里是第一个或最后一个。并且该元素是可选的；如果没有该元素，这个父节点的图片只是会没有说明&#x2F;标题。\n\n&lt;figure&gt;    &lt;img src=&quot;/src/images/cat.jpg&quot;         alt=&quot;一只正在睡觉的猫&quot;&gt;    &lt;figcaption&gt;一只正在睡觉的猫&lt;/figcaption&gt;&lt;/figure&gt;\n\n\n&lt;time&gt;(常用)： 用来表示24小时制时间或者公历日期，若表示日期则也可包含时间和时区。此元素内必须包含一个机器可读的格式表示日期或时间，有安排日程表功能的应用可以利用这一点。\n\n&lt;p&gt;The concert starts at &lt;time&gt;20:00&lt;/time&gt;.&lt;/p&gt;&lt;p&gt;The concert took place on &lt;time datetime=&quot;2001-05-15 19:00&quot;&gt;May 15&lt;/time&gt;.&lt;/p&gt;\n\n\n&lt;mark&gt;：标记文本元素，该标签代表突出显示的文字，例如可以为了标记特定上下文中的文本而使用这个标签。 举个例子，它可以用来显示搜索引擎搜索后关键词。\n\n\n注意： 不要把 &lt;mark&gt; 元素和 &lt;strong&gt; 元素搞混淆；&lt;strong&gt; 元素用来表示文本在上下文的重要性的， 而 &lt;mark&gt; 元素是用来表示上下文的关联性的。\n\n\n&lt;data&gt;：元素将一个指定内容和机器可读的翻译(例商品的编码)联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 &lt;time&gt;。\n\n&lt;p&gt;新产品&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;&lt;data value=&quot;0100398&quot;&gt;迷你安格斯牛排堡&lt;/data&gt;&lt;/li&gt;    &lt;li&gt;&lt;data value=&quot;0100399&quot;&gt;巨无安格斯牛排堡&lt;/data&gt;&lt;/li&gt;    &lt;li&gt;&lt;data value=&quot;0100400&quot;&gt;三层巨无霸安格斯牛排堡&lt;/data&gt;&lt;/li&gt;&lt;/ul&gt;\n\n\n&lt;progress&gt;：元素用来显示一项任务的完成进度。虽然规范中没有规定该元素具体如何显示，浏览器开发商可以自己决定，但通常情况下，该元素都显示为一个进度条形式。\n\n&lt;progress id=&quot;file&quot; max=&quot;100&quot; value=&quot;70&quot;&gt; 70% &lt;/progress&gt;\n\n\n&lt;meter&gt;：元素用来显示已知范围的标量值或者分数值。\n\n&lt;p&gt;加热烤箱至 &lt;meter min=&quot;200&quot; max=&quot;500&quot;                value=&quot;350&quot;&gt;350 度&lt;/meter&gt;.&lt;/p&gt;\n\nHTML5改进标签表单概念：在 HTML5 中对 web 表单进行了部分改进，增加了一些新的属性，一些新的&lt;input&gt;元素type 属性值，新的表单元素以及强制校验API。\n新增属性：\n\n\n\n属性名\n描述\n\n\n\nautocomplete\ninput元素，用于表单的自动填充功能\n\n\nautofocus\ninput元素,页面加载时自动聚焦到此表单控件\n\n\nform\ninput元素,将控件和一个form元素联系在一起\n\n\nformaction\n当input元素type为image, submit时，用于提交表单的URL\n\n\nformenctype\n当input元素type为image, submit时，表单数据集的编码方式，用于表单提交\n\n\nformmethod\n当input元素type为image, submit时，用于表单提交的HTTP方法\n\n\nformnovalidate\n当input元素type为image, submit时，提交表单时绕过对表单控件的验证\n\n\nformtarget\n当input元素type为image, submit时，表单提交的浏览上下文\n\n\nheight 和 width\n当input元素type为image时，设置元素的宽高\n\n\nlist\n绝大部分input元素,自动填充选项的 &lt;datalist&gt; 的id值\n\n\nmin 和 max\n当input元素type为number时，当前数字表单元素可以输入的最小最大值\n\n\nmultiple\n当input元素type为email, file时。是否允许多个值(布尔值)\n\n\npattern (regexp)\n当input元素type为password, text, tel，匹配有效 value 的模式（pattern）\n\n\nplaceholder\n当input元素type为password, search, tel, text, url时，当表单控件为空时，控件中显示的内容\n\n\nrequired\n绝大部分input元素,表示此值为必填项或者提交表单前必须先检查该值(布尔值)\n\n\nstep\n当input元素type为number时，当前数字表单元素有效的递增值\n\n\nnovalidate\nfrom元素关闭浏览器的自动校验，这允许我们使用脚本控制表单校验。\n\n\n新增type：\n\n\n\n类型名\n属性值\n\n\n\ncolor\n用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。\n\n\ndate\n输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时会打开日期选择器或年月日的数字滚轮。\n\n\ntime\n于输入时间的控件，不包括时区。\n\n\nweek\n用于输入以年和周数组成的日期，不带时区。\n\n\ndatetime\n于输入时间的控件，不包括时区。\n\n\ndatetime-local\n输入日期和时间的控件，使用户所在时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。(目前支持的浏览器为数不多)\n\n\nemail\n编辑邮箱地址的输入框。类似 text 输入，但在支持的浏览器上会有邮箱格式的规则验证提示。\n\n\nmonth\n输入年和月的控件，不带时区。\n\n\nnumber\n只能输入数字的输入框。\n\n\nrange\n此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用min 和 max来规定值的范围。\n\n\nsearch\n用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。\n\n\ntel\n用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。\n\n\nurl\n用于输入 URL 的控件。类似 text 输入，在支持的浏览器上会有URL的规则验证提示，在支持动态键盘的设备上有相应的键盘。\n\n\n表单校验：\n介绍：当你向 Web 应用输入数据时，应用会验证你输入的数据是否是正确的。如果验证通过，应用允许提交这些数据到服务器并储存到数据库中（通常情况下），如果验证未通过，则 Web 应用会提示你有错误的数据，并且一般都会明确的告诉你错误发生在哪里。\n概念：HTML5提供一个新功能可以在不写一行脚本代码的情况下，即对用户的输入进行数据校验，这都是通过表单元素的校验属性实现的。这些属性可以让你定义一些规则，用于限定用户的输入，如果表单中输入的数据都符合这些限定规则，那么表示这个表单校验通过，否则则认为校验未通过。\n\n当一个元素校验通过时：\n该元素将可以通过 CSS 伪类 :valid 进行特殊的样式化；\n如果用户尝试提交表单，如果没有其它的控制来阻止该操作（比如JavaScript即可阻止提交），那么该表单的数据会被提交。\n如果一个元素未校验通过：\n该元素将可以通过 CSS 伪类 :invalid 进行特殊的样式化；\n如果用户尝试提交表单，浏览器会展示出错误消息，并停止表单的提交。\n\n表单校检相关属性:\n\nrequired 属性，限制表单为必填\n\n&lt;form&gt;    &lt;input id=&quot;username&quot; name=&quot;username&quot; required&gt;    &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt;\n\n\nminlength 属性和 maxlength 属性，限制输入的长度。 min 和 max 属性，限制输入的数字大小\n\n&lt;form&gt;    &lt;div&gt;        &lt;label for=&quot;username&quot;&gt;请输入你的用户名?&lt;/label&gt;        &lt;input id=&quot;username&quot; name=&quot;username&quot; required minlength=&quot;2&quot; maxlength=&quot;8&quot;&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;label for=&quot;number&quot;&gt;你的年龄?&lt;/label&gt;        &lt;input type=&quot;number&quot; id=&quot;age&quot; name=&quot;age&quot; value=&quot;19&quot; min=&quot;1&quot; max=&quot;99&quot;&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;button&gt;Submit&lt;/button&gt;    &lt;/div&gt;&lt;/form&gt;\n\n\npattern 属性, 使用正则表达式作为属性值可以用来对表单的内容进行校检\n\n&lt;!--密码长度7-14位，必须以大写字母开头，后面允许输入数字字母下划线和。 --&gt;&lt;form&gt;  &lt;label for=&quot;psd&quot;&gt;请输入密码&lt;/label&gt;  &lt;input id=&quot;psd&quot; name=&quot;psd&quot; required pattern=&quot;^[A-Z][0-9a-zA-Z_/.]&#123;6,13&#125;$&quot;&gt;  &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt;\n\n\n自定义错误信息，每次我们提交无效的表单数据时， 浏览器总会显示错误信息。 但是显示的信息取决于你所使用的浏览器（不同浏览器表现不一致）。\n\n\n注意：\n\n要自定义这些消息的外观和文本，你必须使用 JavaScript； 不能使用 HTML 和 CSS 来改变。 HTML5 提供 constraint validation API 来检测和自定义表单元素的状态。 除此之外，他可以改变错误信息的文本。\n越来越多的浏览器支持限制校验API，并且这逐渐变得可靠。这些 API 由成组的方法和属性构成，可在特定的表单元素接口上调用：&lt;button&gt;, &lt;input&gt;,&lt;fieldset&gt;,&lt;output&gt;,&lt;select&gt;,&lt;textarea&gt;\n\n\n例：\n&lt;form&gt;    &lt;label for=&quot;psd&quot;&gt;请输入密码&lt;/label&gt;    &lt;input id=&quot;psd&quot; name=&quot;psd&quot; required pattern=&quot;^[A-Z][0-9a-zA-Z_/.]&#123;6,13&#125;$&quot;&gt;    &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;    var psd = document.getElementById(&quot;psd&quot;);    psd.addEventListener(&quot;input&quot;, function (event) &#123;        if (psd.validity.patternMismatch) &#123;            psd.setCustomValidity(&quot;密码为7到14位必须以大写字母开头只支持数字字母_.请核对格式后认真输入！&quot;);        &#125; else &#123;            psd.setCustomValidity(&quot;&quot;);        &#125;    &#125;);&lt;/script&gt;\n\n\n约束校验的 API 的属性\n\n\n\n\n属性\n描述\n\n\n\nvalidationMessage\n一个本地化消息，描述元素不满足校验条件时（如果有的话）的文本信息。如果元素无需校验（willValidate 为 false），或元素的值满足校验条件时，为空字符串。\n\n\nvalidity\n一个 ValidityState 对象，描述元素的验证状态。\n\n\nvalidity.customError\n如果元素设置了自定义错误，返回 true ；否则返回false。\n\n\nvalidity.patternMismatch\n如果元素的值不匹配所设置的正则表达式，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nvalidity.rangeOverflow\n如果元素的值高于所设置的最大值，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nvalidity.rangeUnderflow\n如果元素的值低于所设置的最小值，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nvalidity.stepMismatch\n如果元素的值不符合 step 属性的规则，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nvalidity.tooLong\n如果元素的值超过所设置的最大长度，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nvalidity.typeMismatch\n如果元素的值出现语法错误，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nvalidity.valid\n如果元素的值不存在校验问题，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :valid CSS 伪类，否则命中 :invalid CSS 伪类。\n\n\nvalidity.valueMissing\n如果元素设置了 required 属性且值为空，返回 true，否则返回 false。当此属性为 true 时，元素将命中 :invalid CSS 伪类。\n\n\nwillValidate\n如果元素在表单提交时将被校验，返回 true，否则返回 false。\n\n\nValidityState = &#123;    badInput: Boolean, // 只读 true 表示用户提供了浏览器不能转换的输入。 如 number表单输入了中文    customError: Boolean, // 只读     patternMismatch: Boolean, // 只读    rangeOverflow: Boolean, // 只读    rangeUnderflow: Boolean, // 只读    stepMismatch: Boolean, // 只读    tooLong: Boolean, // 只读    tooShort: Boolean, // 只读    typeMismatch: Boolean, // 只读    valid: Boolean, // 只读    valueMissing: Boolean // 只读&#125;\n\n\n约束校验 API 的方法\n\n\n\n\n方法\n描述\n\n\n\ncheckValidity()\n如果元素的值校验合法，返回 true，否则返回 false。如果元素校验失败，此方法会触发invalid 事件。\n\n\nHTMLFormElement.reportValidity()\n如果元素或它的子元素控件符合校验的限制，返回 true . 当返回为 false 时, 对每个无效元素可撤销 invalid 事件会被唤起并且校验错误会报告给用户 。\n\n\nsetCustomValidity(message)\n为元素添加一个自定义的错误消息；如果设置了自定义错误消息，该元素被认为是无效的，则显示指定的错误。这允许你使用 JavaScript 代码来建立校验失败，而不是用标准约束校验 API 所提供的。这些自定义信息将在向用户报告错误时显示。如果参数为空，则清空自定义错误。\n\n\n新增表单元素：\n\n&lt;output&gt;：标签表示计算或用户操作的结果。\n\n\noutput 元素的属性：\n\nfor： 以空格分隔的其他元素列表id，其它影响计算结果的标签的ID，可以多个。。\nform： 与当前标签有关联的form（从属的表单）。该属性的值必须是当前文档内的表单元素的ID。如果未指明该属性，output标签必须是一个form的后代标签。该属性的用处在于可以让output标签脱离form标签，存在于一个网页文档的任意位置。\nname： 元素的名称\n\n\n&lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt;    &lt;input type=&quot;range&quot; id=&quot;a&quot; name=&quot;a&quot; value=&quot;50&quot; /&gt; +    &lt;input type=&quot;number&quot; id=&quot;b&quot; name=&quot;b&quot; value=&quot;10&quot; /&gt; =    &lt;output name=&quot;x&quot; for=&quot;a b&quot;&gt;&lt;/output&gt;&lt;/form&gt;\n\n\n&lt;fieldset&gt;： 元素用于对表单中的控制元素进行分组（也包括 label 元素）\n\n\nfieldset 元素的属性：\n\ndisabled： 如果设置了这个 bool 值属性, &lt;fieldset&gt; 的所有子代表单控件也会继承这个属性。这意味着它们不可编辑，\nform： 将该值设为一个 &lt;form&gt; 元素的 id 属性值以将 &lt;fieldset&gt; 设置成这个 &lt;form&gt; 的一部分。\nname： 元素分组的名称\n\n\n\n&lt;legend&gt;: 元素为 &lt;fieldset&gt; 元素定义标题（caption）。\n\n&lt;form&gt;  &lt;fieldset&gt;    &lt;legend&gt;选择你最喜欢吃的水果&lt;/legend&gt;    &lt;input type=&quot;radio&quot; id=&quot;apple&quot; name=&quot;fruits&quot;&gt;    &lt;label for=&quot;apple&quot;&gt; 苹果 &lt;/label&gt;&lt;br/&gt;    &lt;input type=&quot;radio&quot; id=&quot;cherry&quot; name=&quot;fruits&quot;&gt;    &lt;label for=&quot;cherry&quot;&gt; 樱桃 &lt;/label&gt;&lt;br/&gt;    &lt;input type=&quot;radio&quot; id=&quot;banana&quot; name=&quot;fruits&quot;&gt;    &lt;label for=&quot;banana&quot;&gt; 香蕉 &lt;/label&gt;  &lt;/fieldset&gt;&lt;/form&gt;\n\n新增属性data-*介绍：data-* 全局属性 是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本在 HTML 与 DOM 表现之间进行专有数据的交换。\n概念：自定义数据属性都可以通过所属元素的DOM接口来访问。 HTMLElement.dataset 属性可以访问它们。 * 可以使用遵循 xml名称生产规则 的任何名称来被替换，并具有以下限制：\n\n该名称不能以xml开头，无论这些字母是大写还是小写。\n该名称不能包含任何分号 (U+003A)。\n该名称不能包含A至Z的大写字母。\n\n\n自定义属性名只可以包含字母，数字和下面的字符： dash (-), dot (.), colon ( : ), underscore (_)。此外不应包含ASCII 码大写字母。\n\n&lt;ul&gt;    &lt;li data-version-date=&quot;v1-2020&quot; data-id=&quot;10784&quot;&gt;Jason Walters, 003: Found dead in &quot;A View to a Kill&quot;.&lt;/li&gt;    &lt;li data-id=&quot;97865&quot;&gt;Alex Trevelyan, 006: Agent turned terrorist leader; James&#x27; nemesis in &quot;Goldeneye&quot;.&lt;/li&gt;    &lt;li data-id=&quot;45732&quot;&gt;James Bond, 007: The main man; shaken but not stirred.&lt;/li&gt;&lt;/ul&gt;\n\nHTMLElement.dataset：属性允许访问在 HTML或 DOM中的元素上设置的所有自定义数据属性(data-*)集。\n\n注意：dataset 属性本身可以被读取，但不能直接写入。相反，所有的写入必须是它的“属性”，这反过来表示数据自定义属性。\n\ndataset方法会将自定义的data 属性名称转化成 DOMStringMap 的键值时会遵循下面的规则：\n\n前缀 data- 被去除(包括减号)；\n对于每个在ASCII小写字母 a到 z前面的减号 (U+002D)，减号会被去除，并且字母会转变成对应的大写字母(驼峰命名法)。\n其他字符（包含其他减号）都不发生变化\n\n&lt;div id=&quot;user&quot; data-id=&quot;1234567890&quot; data-user=&quot;johndoe&quot; data-date-of-birth&gt;John Doe&lt;/div&gt;&lt;script&gt;var el = document.querySelector(&#x27;#user&#x27;);// el.id == &#x27;user&#x27;// el.dataset.id === &#x27;1234567890&#x27;// el.dataset.user === &#x27;johndoe&#x27;// el.dataset.dateOfBirth === &#x27;&#x27;el.dataset.dateOfBirth = &#x27;1960-10-03&#x27;; // set the DOB.// 给元素添加一个新的自定义属性el.dataset.someDataAttr = &#x27;mydata&#x27;;&lt;/script&gt;\n\n\n自定义属性同样可以通过setAttribute()与getAttribute()操作\n\n存储数据持久化 DOM存储介绍：DOM存储的机制是通过存储字符串类型的键&#x2F;值对，来提供一种安全的存取方式。HTML5提供了两个全局对象（window 对象的属性）localStorage、SessionStorage实现DOM存储\n概念：通过全局对象（localStorage、SessionStorage）访问本地存储功能时。该属性会返回一个 Storage 对象，Storage对象的接口属性方法如下\ninterface Storage &#123;    length: Number, // 只读属性        key(index),  // 获取指定索引对应的key名        getItem(key), // 获取指定key名对应的value值        setItem(key, value), // 添加、修改一个指定key名的键值对值为value        removeItem(key), // 移除指定key名对应的键值对        clear() // 移除所有键值对&#125;\n\n注意：Storage对象中使用键值对存储数据时，key与value必须是字符串且key名唯一（如果key名冲突新的键值对会覆盖旧的键值对）。\n\n需要时刻注意的一点是，所有数据在被保存到下面将要介绍的任何一个存储器之前，都将通过它的 .toString 方法被转换成字符串。所以一个普通对象将会被存储为 “[object Object]”，而不是对象本身或者它的 JSON 形式。使用浏览器自身提供的 JSON 解析和序列化方法来存取对象是比较好的，也是比较常见的方法。\n\n兼容性: Storage 对象最近刚被加入标准当中，所以并不是所有的浏览器都支持。\n\nsessionStorage概念：sessionStorage（会话存储）是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器会话窗口不关闭，页面会话周期就会一直持续。即使页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。\n\n// 保存数据到当前会话的存储空间sessionStorage.setItem(&quot;username&quot;, &quot;John&quot;);// 访问数据var item = sessionStorage.getItem(&quot;username&quot;);// 获取对应index的keyvar key = sessionStorage.key(2)// 删除指定数据sessionStorage.removeItem(key)// 清除所有当前会话存储的数据sessionStorage.clear()\n\n\nlocalStorage\n\n概念：localStorage(本地存储) 与会话存储的工作方式很接近，不同之处在于它将数据存储在本地浏览器中持久储存。\n\n当浏览器进入私人模式(private browsing mode，Google Chrome 上对应的应该是叫隐身模式)的时候，会创建一个新的、临时的、空的数据库，用以存储本地数据(local storage data)。当浏览器关闭时，里面的所有数据都将被丢弃。\n\n// 保存数据到当本地的存储空间localStorage.setItem(&quot;username&quot;, &quot;John&quot;);// 访问数据var item = localStorage.getItem(&quot;username&quot;);// 获取对应index的keyvar key = localStorage.key(2)// 删除指定数据localStorage.removeItem(key)// 清除所有当前会话存储的数据localStorage.clear()\n\n\n面试题 sessionStorage、locaStorage、cookie的区别\n\ncookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下\n存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\n数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭\n作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的\nweb Storage支持事件通知机制，可以将数据更新的通知发送给监听者\nweb Storage的api接口使用更方便\n\n\n多媒体介绍：在HTML 5之前，要在网页上展示音频、视频、动画，除了使用第三方播放器以外，使用最多的是Adobe Flash插件。Flash插件在浏览器中不但需要经常更新还会出现一些问题导致机器锁死。HTML5的出现使得浏览器支持直接播放视频和音频文件，提供了音频视频的标准接口而无需安装插件。\n视频概念：HTML5允许你使用&lt;video&gt;元素在网页中嵌入视频内容。\n&lt;video src=&quot;https://f.video.weibocdn.com/003eXQhUgx07IsUtjXeM010412037ODj0E020.mp4?label=mp4_1080p&amp;template=1920x1080.25.0&amp;trans_finger=0bde055d9aa01b9f6bc04ccac8f0b471&amp;media_id=4577795490119695&amp;tp=8x8A3El:YTkl0eM8&amp;us=0&amp;ori=1&amp;bf=3&amp;ot=h&amp;ps=3lckmu&amp;uid=3ZoTIp&amp;ab=3915-g1,966-g1,3370-g1,1493-g0,1192-g0,1191-g0,1046-g2,1258-g0&amp;Expires=1607049593&amp;ssig=4cByzMWZP3&amp;KID=unistore,video&quot; controls&gt;  &lt;p&gt;你的浏览器不支持 HTML5 视频。可点击&lt;a href=&quot;https://f.video.weibocdn.com/003eXQhUgx07IsUtjXeM010412037ODj0E020.mp4?label=mp4_1080p&amp;template=1920x1080.25.0&amp;trans_finger=0bde055d9aa01b9f6bc04ccac8f0b471&amp;media_id=4577795490119695&amp;tp=8x8A3El:YTkl0eM8&amp;us=0&amp;ori=1&amp;bf=3&amp;ot=h&amp;ps=3lckmu&amp;uid=3ZoTIp&amp;ab=3915-g1,966-g1,3370-g1,1493-g0,1192-g0,1191-g0,1046-g2,1258-g0&amp;Expires=1607049593&amp;ssig=4cByzMWZP3&amp;KID=unistore,video&quot;&gt;此链接&lt;/a&gt;观看&lt;/p&gt;&lt;/video&gt;\n\n属性：以下是 &lt;video&gt; 元素支持的属性：\n\ncontrols： 设置是否显示浏览器标准控制器\nautoplay： 是否在视频&#x2F;音频加载完成后自动播放\nsrc： 视频音频文件路径 只加载 媒体元数据(媒体字节数,第一帧,播放列表,持续时间)\npreload： 音频视频是否预加载 auto 加载全部视频音频\nposter(video元素独有)： 视频不可用,第一次加载完成没有播放时,将会在空白区域展示该属性指向的图片\nloop： 循环播放\nheight width (video元素独有)： 设置视频的宽度高度\nmuted： 这个属性会导致媒体播放时，默认关闭声音。\n\n&lt;video muted=&quot;muted&quot; controls=&quot;controls&quot; width=&quot;375&quot; height=&quot;200&quot; src=&quot;https://overwatch.nosdn.127.net/1/assets/img/pages/home/anniversary/header.webm&quot;  autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; poster=&quot;https://overwatch.nosdn.127.net/1/assets/img/pages/home/header-video-poster.jpg&quot;&gt;&lt;/video&gt;\n\n使用多个播放源以提高兼容性介绍：不同的浏览器之间并不全支持相同的媒体文件格式，所以你得使用几个不同格式的文件来兼容不同的浏览器。如果你使用的格式都得不到浏览器的支持，那么媒体文件将不会播放。例如:\n\nWebM 格式文件通常包括了 Opus 或 Vorbis 音频和 VP8&#x2F;VP9 视频。这在所有的现代浏览器中都支持，除了他们的老版本。\nMP4 格式文件通常包括 AAC 以及 MP3 音频和 H.264 视频。这在所有的现代浏览器中都支持，还有 Internet Explorer。\nOgg 格式文件往往支持 Ogg Vorbis 音频和 Ogg Theora 视频。主要在 Firefox 和 Chrome 当中支持，不过这个容器已经被更强大的 WebM 容器所取代。\n\n概念：通过在&lt;video&gt;标签中将 src 属性移除，转而将它放在 &lt;video&gt; 内部几个单独的标签 &lt;source&gt; 当中。浏览器将会检查 &lt;source&gt; 标签，并且播放第一个浏览器自身支持的媒体文件，一般我们推荐视频源中应当包含WebM和MP4两种格式（这两种格式目前已经支持绝大多数平台和浏览器）\n\n&lt;source&gt; 标签包含两个属性\n\nsrc 音视频文件的路径\ntype （可选属性）表示音视频文件的 MIME 类型，浏览器也会通过检查这个属性来迅速的跳过那些不支持的格式。如果你没有添加 type 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这样会消耗掉大量的时间和资源。\n\n\n&lt;video muted=&quot;muted&quot; width=&quot;375&quot; height=&quot;200&quot;  src=&quot;https://overwatch.nosdn.127.net/1/assets/img/pages/home/anniversary/header.webm&quot;  autoplay=&quot;autoplay&quot; loop=&quot;loop&quot; poster=&quot;https://overwatch.nosdn.127.net/1/assets/img/pages/home/header-video-poster.jpg&quot;&gt;      &lt;source src=&quot;https://overwatch.nosdn.127.net/1/assets/img/pages/home/anniversary/header.webm&quot; type=&quot;video/webm&quot;&gt;      &lt;source src=&quot;https://overwatch.nosdn.127.net/1/assets/img/pages/home/anniversary/header.mp4&quot; type=&quot;video/mp4&quot;&gt;      &lt;p&gt;你的浏览器不支持 HTML5 视频。请更换浏览器&lt;/p&gt;&lt;/video&gt;\n\n音频概念：HTML5允许你使用&lt;audio&gt;元素在网页中嵌入音频。 &lt;audio&gt;与&lt;video&gt;标签使用方式完全相同，只有一些细微差别。\n&lt;audio controls&gt;  &lt;source src=&quot;viper.mp3&quot; type=&quot;audio/mp3&quot;&gt;  &lt;source src=&quot;viper.ogg&quot; type=&quot;audio/ogg&quot;&gt;  &lt;p&gt;你的浏览器不支持 HTML5 音频，可点击&lt;a href=&quot;viper.mp3&quot;&gt;此链接&lt;/a&gt;收听。&lt;/p&gt;&lt;/audio&gt;\n\n属性：音频播放器没有视觉部件 — 你只需要显示出能控制音频播放的控件。以下是 &lt;audio&gt; 元素支持的属性：\n\ncontrols： 设置是否显示浏览器标准控制器\nautoplay： 是否在视频&#x2F;音频加载完成后自动播放\nsrc： 视频音频文件路径 只加载 媒体元数据(媒体字节数,第一帧,播放列表,持续时间)\npreload： 音频视频是否预加载 auto 加载全部视频音频\nloop： 循环播放\nmuted： 这个属性会导致媒体播放时，默认关闭声音。\n\n编程式多媒体获取媒体信息介绍：多媒体元素除了上述可以在HTML中指定的属性外，还支持一些其他可以通过js读写的属性\n\nerror(只读): 表示最近的错误，如果没有错误则值为 null。\nnetworkState: 媒体数据加载过程中,媒体元素networkState得到当前网络状态\n0: 元素处于初始状态\n1: 浏览器已经选择好用什么编码格式来播放媒体,未建立网络连接\n2: 媒体数据加载中\n3: 没有支持的编码格式,不执行加载\n\n\ncurrentSrc (只读) 读取媒体元素 播放中的数据URL地址\ncurrentTime 用来获取、设置多媒体当前播放时间\nbuffered(只读) 媒体元素通过该属性返回一个对象,这个对象实现TimeRanges接口,确认浏览器是否已缓存媒体数据\n\n\nTimeRanges表示一个时间的范围,大多数情况下是一个单一的以0开始的范围,如果浏览器发出rang requests请求,这时TimeRanges 会有多个事件范围TimeRanges对象具有一个length属性,表示有多少个时间范围,该对象存在两个方法 TimeRanges.start(index)(从什么时间开始缓存)  TimeRanges.end(index)(从什么时间结束缓存)\n\nreadyState(只读) 媒体元素播放当前位置 就绪状态\n0: 没有获取到媒体的任何信息\n1: 已获取到了足够的媒体数据,但是当前播放位置没有有效媒体数据(获取到的媒体数据无效)\n2: 当前播放位置已经有数据可以播放,但是没有获取到让播放器前进的数据(当前播放的时缓冲的最后一帧)\n3: 当前播放位置已经有数据可以播放,页获取到让播放器前进的数据\n4:当前播放位置已经有数据可以播放,页获取到让播放器前进的数据,而且浏览器确认媒体数据以一种速度进行加载(保证后面的数据可以持续进行播放)\n\n\nvolume 表示音频的音量。值从0.0（静音）到1.0（最大音量）。\ndefaultPlaybackRate 控制媒体的默认播放速度。1.0表示正常的播放速度，如果值小于1.0，则播放速度会比”正常速度“慢，如果值大于1.0，则播放速度会比”正常速度“快。0.0是一个无效的值，并且会抛出 NOT_SUPPORTED_ERR 错误。\nplaybackRate 控制媒体当前的播放速度。1.0表示正常的播放速度，如果值小于1.0，则播放速度会比”正常速度“慢，如果值大于1.0，则播放速度会比”正常速度“快。\nduration(只读) 媒体以秒为单位的总长度时间，如果媒体不可用，则为0. 如果媒体可用，但时间长度未知, 值为NAN.\n\n控制媒体播放\n\ncanPlayType(in DOMString type) 方法浏览器是否能播放指定的音频&#x2F;视频类型。方法可返回下列值之一：\n“probably” - 浏览器最可能支持该音频&#x2F;视频类型\n“maybe” - 浏览器也许支持该音频&#x2F;视频类型,只有播放了才知道能不能播放\n“” - （空字符串）浏览器不支持该音频&#x2F;视频类型\n\n\n\nmyVid=document.createElement(&#x27;video&#x27;);// 检测视频/音频isSupp=myVid.canPlayType(&#x27;video/webm&#x27;);console.log(isSupp)// 检测视频/音频,和解编码器，如果包含解编码器不会返回maybeisSupp=myVid.canPlayType(&#x27;video/webm; codecs=&quot;vp8.0, vorbis&quot;&#x27;);console.log(isSupp)\n\n\nload() 方法重新加载音频&#x2F;视频元素。方法用于在更改来源或其他设置后对音频&#x2F;视频元素进行更新。\npause() 暂停播放\nplay() 开始播放。\n\n媒体事件处理\n\nloadstart 浏览器在网上寻找媒体数据\nprogress 浏览器正在获取媒体数据\nsuspend 浏览器暂停获取媒体数据,但是下载过程并没有正常结束\nabort 浏览器在下载完全部媒体数据之前终止数据获取(但是并不是由错误引起)\nerror 获取媒体数据过程中出错\nemptied 媒体元素所在网络突然变成未初始化状态(载入媒体过程中突然发生致命错误或者浏览器正选择播放格式时,又调用了load方法)\nstalled 浏览器尝试获取媒体数据失败\nplay 即将开始播放,执行了play方法时触发\npause 播放暂停,执行了pause方法\nloadedmetadata 浏览器获取完媒体的时长和字节数\nloadeddata 浏览器已加载完毕当前播放位置的媒体数据,准备播放\nwaiting 浏览器得不到下一帧而暂停播放,但很快能得到下一帧\nplaying 正在播放(只执行一次)\ncanplay 浏览器能够播放数据,但是播放期间需要缓冲\ncanplaythrough 浏览器能够播放数据,播放期间不需要缓冲\nseeking 浏览器正在请求数据\nseeked 浏览器停止请求数据\nended 播放结束后停止播放\nratechange 默认播放速率(defaultpalybackRate),当前播放速率(palybackRate)发生改变\ndurationchange 播放时长被改变\nvolumechange 音量被改变或者静音状态改变\ntimeupdate 当前播放位置被改变，可能是播放中自然改变，也可能人为拖拽进度条改变等\n\n&lt;video id=&quot;video&quot; controls preload=&quot;metadata&quot; poster=&quot;server/下载.jpg&quot; autoplay loop&gt;    &lt;source src=&quot;http://qncdn.miaopai.com/stream/NKOc-R~B4hf~klqqJ7Ix6fIGFraJnvDxyPfdWQ___0_1502864324.mp4?ssig=248461eb48ca1ff86e911529bec2ee39&amp;time_stamp=1502877154402&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt;&lt;script&gt;    var video = document.getElementById(&#x27;video&#x27;);    video.addEventListener(&#x27;progress&#x27;,function()&#123;        var timeRanges   =   video.buffered;        var networkState = video.networkState;        console.log(timeRanges,timeRanges.start(1))    &#125;)    video.addEventListener(&#x27;error&#x27;,function()&#123;        var error = video.error;        switch (error.code)&#123;            case 1:                alert(&#x27;视频的下载过程被终止&#x27;);                break;            case 2:                alert(&#x27;网络发生故障,视频的下载过程被终止&#x27;);                break;            case 3:                alert(&#x27;解码失败&#x27;);                break;            case 4:                alert(&#x27;不支持播放的视频格式&#x27;)                break;        &#125;    &#125;,false)&lt;/script&gt;\n\n性能Web Workers介绍：Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。通过将耗时较长的处理交给后台线程运行，从而解决页面因长耗时js处理导致页面被阻塞的问题。\n概念：HTML5 提供了一个 Worker 构造函数，通过该构造函数新建 Worker 对象并将需要交给后台线程处理的脚本文件 URL 传递给该对象，指定URL脚本文件就会在后台线程中执行了。\n注意：workers 运行在另一个全局上下文中,不同于当前的window. 因此，在 Worker 内通过 window获取全局作用域将返回错误。\n// 检测当前浏览器是否支持Worker APIif(window.Worker) &#123;    var myWorker = new Worker(&#x27;worker1.js&#x27;)&#125;\n\nWorker中的消息接受与发送\npostMessage(data) 消息发送：通过该方法可以使得worker实例对象与后台线程的脚本文件互相发送消息\n\n// myWorker向后台线程脚本发送消息 100myWorker.postMessage(100)// worker1.js// 后台线程脚本向主线程Worker实例对象发送消息 &#x27;hello world&#x27;postMessage(&#x27;hello world&#x27;)\n\n\nonmessage 接收消息：worker实例对象与后台线程的脚本文件可以通过该事件方法接受对方通过 postMessage 发送的消息。\n\nmyWorker.onmessage = function(evt) &#123;    console.log(&#x27;收到后台发送过来的消息&#x27;, evt.data)&#125;// worker1.jsonmessage = function(evt) &#123;   // 收到主线程 Worker 实例对象发送过来的数据   var msg = evt.data   &#125;\n\n「练习」\n使用web worker实现后台计算数字累加功能\n\n要求：\n\n页面中包含一个 type&#x3D;“number” 的 input 表单元素，用户可以在该表单中输入任意数字\n页面包含一个”计算累加”的 button 按钮，当button按钮被点击是，如果 input 值合法将该值发送到后台工作线程中\n后台工作线程接收到Worker发送的数字后开始从1循环累加到接收到的数字。累加完毕将累加结果发送回主线程\n主线程接受到结果后渲染到页面上\n\n\n\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"TypeScript","url":"/1970/01/01/TypeScript/","content":"哥们学过，没记笔记，看 阮一峰的 TypeScript 教程 就行了，遇到不懂的再问AI就行了😄\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"JavaScript 学习笔记","url":"/2023/08/06/JavaScript/","content":"JavaScript介绍\nJavaScript介绍为什么要学习Javascript\n我们之前学的HTML只能完成页面的结构,CSS完成页面的样式, HTML+CSS静态页面,没有任何页面效果的,页面也没有行为 \n如果想要页面有行为,比如某个元素可以被点击, 那么就需要学习JS,给页面某个元素添加行为\n\nJavaScript是什么官方概念:这是一个跨平台的脚本语言\n平台这里指的是操作系统(window系统, mac系统 , linux系统)\n跨平台的意思就是在不同的操作系统下, 都可以运行\n脚本语言意思是js不能单独运行,需要有一个运行环境,这个运行环境就是js的运行环境,比如浏览器环境,node.js环境\n为什么js可以跨平台,因为在不同操作系统下, 都有浏览器, 有浏览器就可以运行JS代码  \n\nJavascript的发展历史1995年,由一个名为布莱登·艾奇创造的脚本语言,原名livescript; 以前js为了验证表单信息\nJavaScript现在的意义(应用场景) \nJavaScript 发展到现在几乎无所不能。\n\n网页特效     比如图片轮播,选项卡….\n服务端开发(Node.js)\n命令行工具(Node.js)\n桌面程序(Electron) \nApp(Cordova) \n控制硬件-物联网(Ruff)\n游戏开发(cocos2d-js  ,  贪吃蛇  ,   微信打飞机….)\n表单验证\n与服务器进行交互(ajax-&gt;谷歌于2005年推出的)\n\n\nJavaScript和HTML、CSS的区别\nHTML：提供网页的结构，提供网页中的内容\nCSS: 用来美化网页\nJavaScript: 可以用来控制网页内容，控制样式,  给网页增加动态的效果\n\n\nJavaScript的组成\nECMAScript - JavaScript的核心\nECMA 欧洲计算机制造联合会\n网景：JavaScript\n微软：JScript\n定义了JavaScript的语法规范\nJavaScript的核心，描述了语言的”基本语法”和”数据类型”，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关\n\nDOM - 文档对象模型\n一套操作页面元素的API\nDOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作\n\nBOM - 浏览器对象模型\n一套操作浏览器功能的API\n通过BOM可以操作浏览器窗口，比如：控制浏览器跳转、获取分辨率、获取浏览器的可视区域大小等\n\n\n\nJS注释分为单行注释与多行注释(块注释)\n被JS注释的代码,不会执行\n// 单行注释  ctrl+//* 多行注释 */\n\nJS代码的语法规则\nJavaScript严格区分英文字母大小写\n\n  console.log(123);console.Log( 123 );// 报错console.log(true);console.log(True);// 报错console.log(nUll);// 报错\n\n\nJavaScript脚本程序需嵌入在HTML文件中才可以执行代码(当然现在也可以用node.js执行单独的js文件)\n\nJavaScript脚本程序可以独立保存为一个外部文件 这个文件是不能自己运行的它必须要依赖于HTML文件或者node.js环境\n\nJavaScript脚本程序中不能包含HTML标记代码\n&lt;h2&gt;12312312&lt;/h2&gt;\n\n每条语句末尾如果加分号一定是”英文”状态下的分号(;),最好加分号,不要省略\nconsole.log(123)// console.log(456)；// 报错,中文状态的分号console.log(789);console.log(123456789);\n\n\n一行写了多条JS语句  这个时候每一条语句就必须要加分号(最后一条语句可以不加分号)\n\n\n  console.log(123);console.log(456);console.log(789);console.log(123)console.log(456);console.log(789);// 报错\n\njs常用输出语句js常用输出语句有三个\n\ndocument.write(“内容”)\n\n把指定内容输出到body标签中 \n\n可以解析HTML标签\n\n\n\nconsole.log(“内容”)\n\n把指定内容输出到浏览器调试工具的控制台中 \n\n无法解析HTML标签\n\n我们经常会使用console.log调试bug\n\n\n\nwindow.alert(“内容”)\n\n以弹窗的形式输出内容\n\n无法解析HTML标签\n\nwindow对象的属性或者方法都可以省略window对象也就是window.alert()可以直接写成alert()\n\n注意: 如果”内容”是纯数字或者js中的关键字 可以不加引号, 其他内容都需要加一对双引号或者单引号包裹\n\n\n\n\nwindow.prompt()\nwindow.prompt() 用户输入对话框\n这个方法是属性window对象的方法   所以window可以省略\n这个方法是用来向浏览器中弹出一个用户输入对话框 \n\n语法:\nwindow.prompt(text,defaultText)\n\n第一个参数:text表示提示信息\n第二个参数:defautlText 表示输入框的中默认文本  默认值\n但是注意:这两个参数都可以省略不写！\n\n这个方法有两个按钮 :确定按钮、取消按钮 \n当用户点击”确定”按钮时会得到一个”String类型”的数据\n当用户点击”取消”按钮会得到一个关键字 null\n\n\nwindow.prompt();window.prompt(&quot;请输入您的银行卡密码&quot;);window.prompt(&quot;请输入您的银行卡密码&quot; , 123456 );\n\nJavaScript的书写位置js一般写在script标签, script也属于HTML标签, 所以script标签可以出现页面文档的任何地方和出现任意次\nscript标签一般都是写在head标签中\n\nJavaScript的书写位置-嵌入式就是把js代码写script标签中\n\n&lt;script&gt;    console.log(111);&lt;/script&gt;\n\n\nJavaScript的书写位置-外链式就是把js代码写在单独的js文件中\n外链式js文件是通过script标签的src属性引入\n注意: 不要在引入js文件的script标签中,写js代码; 因为写的js代码不会生效\n\n\n&lt;script src=&quot;js文件所在路径&quot;&gt;&lt;/script&gt; \n\n\nJavaScript的书写位置-行内式,就是把js代码写在标签的事件属性中\n\n&lt;button onclick=&quot;console.log(123);&quot; onmouseover=&quot;console.log(&#x27;abc&#x27;)&quot; onmouseout=&quot;console.log(&#x27;qwe&#x27;)&quot;&gt;按钮&lt;/button&gt;\n\n\n\n变量概念：变量就是可以变化的量, 变量是一个容器, 方便存取数据\n创建变量(定义变量,声明变量)\n语法一 定义单个变量, 变量不赋值\nvar 变量名;\nvar a;\n\n使用变量,就是直接使用变量名即可,变量名就可以代表这个变量的值\nconsole.log(&quot;a=&gt;&quot;, a);\n\n语法二 定义多个变量, 变量不赋值var 变量名1, 变量名2, 变量名3 … ;\nvar x, y, z;\n\n语法三 定义单个变量, 变量并赋值var 变量名 &#x3D; 值;\nvar b = 20;console.log(&quot;b=&gt;&quot;, 20);\n\n语法四 定义多个变量, 变量并赋值var 变量名1 &#x3D; 值1, 变量名2 &#x3D; 值2, 变量名3 &#x3D; 值3 …;\nvar num1 = 30, num2 = 40, num3 = 50;console.log(&quot;num1=&gt;&quot;, num1);console.log(&quot;num2=&gt;&quot;, num2);console.log(&quot;num3=&gt;&quot;, num3);\n\n注意: 如果变量名声明了,但是没有赋值,那么这个变量的值是会undefined注意: &#x3D; 号是赋值运算符, 把 &#x3D; 号右边的值,赋值给左边的变量;  那么以后这个变量名就可以代表这个值\n\n修改变量的值, 就是更新变量的值,  通过 &#x3D; 号 赋值运算符\nvar age = 18;console.log(&quot;age=&gt;&quot;, age);// 更新age的值(修改age值)age = 20;age = 30;age = 40;console.log(&quot;age=&gt;&quot;, age);\n\n变量的命名规则和规范\n由字母(AZaz)、数字(0~9)、下划线(_)、$符号组成，不能以数字开头\nvar @_@ = &quot;abc&quot;;console.log( @_@ ); //报错var a$B_5 = 123;console.log( a$B_5 );\n\n多个单词可以使用驼峰法\nvar userName = &quot;zhangsan&quot;;console.log(userName);\n\n多个单词可以使用下划线连接法\nvar user_name = &quot;lisisi&quot;;console.log(user_name);\n\n不能是JS中关键字和保留字，例如：for、while等(其中变量名为name需要注意,不会报错,但是不推荐使用,因为name是window对象下的一个属性, 不管设置的属性值是什么, 都会被加上双引号,成为字符串类型)\n/* var for = 456;console.log( for ); *//* var name = 123;console.log(typeof name);var name2 = 123;console.log(typeof name2); */\n\n区分大小写\nvar age = 18;var Age = 20;console.log(age);console.log(Age);console.log(aGe);\n\n\n规范 - 建议遵守的，不遵守不会报错\n变量名需要有意义,希望大家在声明变量的时候变量名要做到”见名知意” \n\n变量名可以由多个英文单词组成  建议使用下划线连接法 或者是驼峰法\n\n下划线连接法  每一个单词之间使用下划线进行连接  比如:get_user-name \n\n驼峰法  第一个英文单词的首字母全部小写 第二个开始其它的英文单词首字母大写  比如:getUserName\n\n\n\n\n\n\n变量的数据类型\n为什么变量需要有数据类型变量主要是用于存储数据的，现实生活中的数据有很多种比如有数值、有字母等等  那么为了将这些数据进行分门别类，所以就引出了变量的数据类型。\n\nJavaScript是一种弱类型的语言。在声明变量的时候不需要指定变量的数据类型强类型的语言，在声明变量的时候一定要先指明这个变量的数据类型是什么 并且值也是这个数据类型 \n因为JS是一门弱类型的脚本语言，”在声明变量的时候不需要先声明变量的类型”。但是它也是有类型，JS变量的类型是由”变量的值”来决定 。\n\n变量的数据类型分为：两大类、七小种\n两大类：\n基本数据类型(标量数据类型,值类型)\n复合数据类型(引用数据类型,对象类型)！\n\n\n七小种:\n基本数据类型: 字符串,数值,布尔,未定义型,空型 (只能存储一个值)\n复合数据类型: 数组,对象 (至少存储一个值，可以存储多个值)\n\n\n\n\n\n获取变量的数据类型在JavaScript中有一个内置的函数可以检测变量的数据类型  \n语法一: typeof( 值或者变量名 )\n语法二: typeof 值或者变量名\nvar a = 10console.log(typeof (a));console.log(typeof a);console.log(typeof true);console.log(typeof null);console.log(typeof undefined);\n\n\n\n基本(标量)数据类型字符串(string)\n只要值被一对引号(不管双引号还是单引号)包裹, 那么就是字符串\n\nconsole.log(&quot;abc&quot;, typeof (&quot;abc&quot;));console.log(&#x27;abc&#x27;, typeof (&#x27;abc&#x27;));console.log(&quot;123&quot;, typeof (&quot;123&quot;));\n\n\n字符串中不允许双包双,单包单; 但是允许双包单, 允许单包双\n\nconsole.log(&quot;我是一个&#x27;帅气&#x27;的人&quot;);console.log(&#x27;我是一个&quot;帅气&quot;的人&#x27;);console.log(&quot;&quot;);\n\n\n也可以使用转义符 转义符是反斜杠\\ 进行一些符号的转义\n\n// console.log( \\ );// 报错// console.log( &quot;\\&quot; );// 报错// console.log( &#x27;\\&#x27; );// 报错// console.log( \\\\ );// 报错console.log(&quot;\\\\&quot;); // 不报错console.log(&quot;我是一个\\&quot;帅气\\&quot;的人&quot;);console.log(&#x27;我是一个\\&#x27;帅气\\&#x27;的人&#x27;);\n\n\n获取字符串的长度\n通过 字符串变量名.length 可以获取字符串的总字符个数\n\n\nvar str = &quot;abc123张三疯@_@&quot;;console.log(str, str.length);\n\n\n字符串拼接\n字符串拼接就是把小字符串拼成大字符串, 每次拼接都会拼接到后面\n字符串拼接是使用+号,但是在js中的+号会分情况\n\n\n// 情况1: 如果加号左右两个都是数值,那么+号就是加法运算console.log(11 + 22, typeof (11 + 22));// 情况2: 如果加号左右两个有一个是字符串,那么+号就是字符串连接运算符console.log(&quot;11&quot; + 22, typeof (&quot;11&quot; + 22));console.log(11 + &quot;22&quot;, typeof (11 + &quot;22&quot;));console.log(&quot;11&quot; + &quot;22&quot;, typeof (&quot;11&quot; + &quot;22&quot;));\n\n数值(number)数值包括 整数(正整数,负整数), 小数(正小数,负小数), 0, 以及 NaN关键字\n备注: NaN当数据类型强制转换数值类型失败的时候,就会得到NaN(not a number)关键字\nconsole.log(5, typeof 5);console.log(-2, typeof - 2);console.log(0, typeof 0);console.log(5.123, typeof 5.123);console.log(-4.789, typeof - 4.789);console.log(NaN, typeof NaN);\n\n布尔(boolean)布尔值 只有两个 true(表示真,成立) 和 false(表示假,不成立)\nconsole.log(true, typeof true);console.log(false, typeof false);\n\n未定义(undefined)得到未定义的情况有很多,列几个常见情况给大家\n\n定义变量,不赋值,那么变量的值就为undefined\nvar a;console.log(a, typeof a);\n\n定义变量,赋值为undefined\nvar b = undefined;console.log(b, typeof b);\n\n访问不存在的数组元素值(数组后面讲)\nvar arr = [10, 20, 30];console.log(arr[0], typeof arr[0]);console.log(arr[1], typeof arr[1]);console.log(arr[2], typeof arr[2]);console.log(arr[3], typeof arr[3]);console.log(arr[4], typeof arr[4]);\n\n访问不存在的对象属性(对象后面讲)\nvar obj = &#123;    username: &quot;zhangsan&quot;,    age: 23&#125;console.log(obj.username, typeof obj.username);console.log(obj.age, typeof obj.age);console.log(obj.sex, typeof obj.sex);\n\n函数没有返回值(函数后面讲)\nfunction fn() &#123;    console.log(&quot;我是fn函数&quot;);&#125;var res = fn();console.log(res, typeof res);\n\n空型(null)得到空型的方式主要给变量赋值一个null 或者 dom对象获取失败也会返回null注意: typeof null的结果不是null, 而是object\nvar x = null;console.log(x, typeof x);var objDiv = document.getElementById(&quot;abc&quot;);console.log(objDiv, typeof objDiv);\n\n\n\n运算符\n含义：运算符就是可以运算的符号\n\n算术运算符\n算术运算符 + - * &#x2F; %(求余数, 取模)\n\nvar x = 10;var y = 3;console.log(x + y); // 13console.log(x - y); // 7console.log(x * y); // 30console.log(x / y); // 3.33333333333...\n\n自操作运算符\n自操作运算符 ++ –\n\n\n不管前加加还是后加加,最终结果都会加1\n如果有其他代码跟加加一起使用, 后加加, 运算后自增\n如果有其他代码跟加加一起使用, 前加加, 自增后运算\n\n赋值运算符\n赋值运算符 &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;\n\n+&#x3D; -&#x3D; *&#x3D; &#x2F;+ %&#x3D; 用法几乎一样\n\n\n以+&#x3D;为例\nvar x = 20;console.log(&quot;x=&gt;&quot;, x);x = x + 3;x += 3; // 左边x的值 加上 右边的3 ,再赋值自己xconsole.log(&quot;x=&gt;&quot;, x);\n\n字符串连接运算符\n字符串连接运算符 + +&#x3D;\n\n+和+&#x3D; 需要左右两个运算符至少有一个是字符串类型, 那么+和+&#x3D;才会是字符串连接运算符\n\n\nvar str = &quot;&quot;; // 定义一个空字符串str += &quot;&lt;h2&gt;&quot; + username + &quot;的个人信息&lt;/h2&gt;&quot;;str += &quot;&lt;ul&gt;&quot;;str += &quot;&lt;li&gt;姓名: &quot; + username + &quot;&lt;/li&gt;&quot;;str += &quot;&lt;li&gt;性别: &quot; + sex + &quot;&lt;/li&gt;&quot;;str += &quot;&lt;li&gt;年龄: &quot; + age + &quot;&lt;/li&gt;&quot;;str += &quot;&lt;li&gt;体重: &quot; + weight + &quot;&lt;/li&gt;&quot;;str += &quot;&lt;/ul&gt;&quot;;console.log(str);\n\n比较运算符\n比较运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D; &#x3D;&#x3D;&#x3D; !&#x3D;&#x3D;\n\n比较运算符的结果是布尔值(true或者false)\n\n&#x3D;&#x3D; 等于, “比较值是否相等”\n进行比较时，运算符&#x3D;&#x3D;会考虑其操作数（要比较的两个值）的类型。\n如果两个值的类型相同，就直接进行比较，如果两个值的类型不同，则尝试将它们转换为相同的类型，再进行比较\nconsole.log(10 == 10);console.log(10 == &quot;10&quot;);\n\n&#x3D;&#x3D;&#x3D; 全等于, 先比较”数据类型”是否相同, 如果不相同, 直接返回false; 如果”数据类型”相同,再进行值的比较\n&#x3D;&#x3D;&#x3D; 全等于,需要类型和值都相等,才会返回true\nconsole.log(10 === 10);console.log(10 === &quot;10&quot;);\n\n逻辑运算符\n逻辑运算符 &amp;&amp; || !\n\n\n逻辑与&amp;&amp;  表示并且的关系 需要&amp;&amp;左右两边都为true的时候,最终得到true\nconsole.log(false &amp;&amp; true);console.log(false &amp;&amp; false);console.log(10 &gt; 5 &amp;&amp; 10 === &quot;10&quot; &amp;&amp; &quot;a&quot; == &quot;a&quot;);\n\n逻辑或||  表示或者的关系 ||左右只有一个为true的时候,最终得到true\nconsole.log(false || true); // trueconsole.log(false || false); // falseconsole.log(3 != &quot;3&quot; || &quot;人&quot; == &quot;阿凡达&quot;);\n\n逻辑非!  表示取反的关系 !true&#x3D;&gt;false !false&#x3D;&gt;true\nconsole.log(true);console.log(!true);console.log(false);console.log(!false);\n\n三目运算符\n三目运算符语法\n条件表达式 ? 语句1 : 语句2;\n\n如果条件表达式成立,执行语句1;\n如果条件表达式不成立,执行语句2;\n\n\nvar a = 5;var b = 3;a &gt; b ? console.log( &quot;a大于b&quot;) : console.log( &quot;a不大于b&quot;);var a = 5;var b = 3;a &gt; b ? console.log( &quot;a大于b&quot;) : console.log( &quot;a不大于b&quot;);\n\n运算符的优先级\n优先级从高到底\n\n() 优先级最高\n\n一元运算符 ++   –   !\n\n算数运算符 先* &#x2F; %   后 +   -\n\n关系(比较)运算符 &gt;   &gt;&#x3D;   &lt;   &lt;&#x3D;\n\n相等(比较)运算符   &#x3D;&#x3D;   !&#x3D;   &#x3D;&#x3D;&#x3D;   !&#x3D;&#x3D;\n\n逻辑运算符 先&amp;&amp;   后||\n\n赋值运算符 &#x3D;  优先级最低\n\n\n\n\nconsole.log(4 &gt;= 6 || &quot;人&quot; != &quot;阿凡达&quot; &amp;&amp; !(12 * 2 == 144) &amp;&amp; true);\n\n流程控制\n什么是流程控制？控制流程（也称为流程控制）是计算机运算领域的用语，意指在”程序运行”时，个别的指令（或是陈述、子程序）运行或求值的”顺序”。\n不论是在声明式编程语言或是函数编程语言中，都有类似的概念。\n\n流程控制分为三种结构:顺序结构、分支结构、循环结构\n顺序结构: 代码从上到下, 按顺序执行\n\n分支结构: 代码有选择的执行, 选择某个分支的代码执行\n\n循环结构: 满足一定条件的时候,代码重复执行\n\n\n\n\n分支结构if语句实现分支\n分支结构又可以分为单分支,双分支以及多分支,条件表达式就是可以得到布尔值的式子\n\n单分支,只有一种选择, if语句实现\n语法\nif( 条件表达式 ){\n​    条件表达式成立时,执行的代码块;\n}\nvar age = 20;if (age &gt;= 18) &#123;    console.log(&quot;成年了,可以去网吧上网了&quot;);\n\n双分支,有两种选择, if…else语句实现\n语法\nif( 条件表达式 ){\n​    条件表达式成立时,执行的代码块;\n}else{\n​    条件表达式不成立时,执行的代码块;\n}\nvar age = 20;if (age &gt;= 18) &#123;    console.log(&quot;成年了,可以去网吧上网了&quot;);&#125; else &#123;    console.log(&quot;未成年,禁止上网&quot;);&#125;\n\n多分支,有多种选择, if…else if…else语句,  switch语句\n语法\nif( 条件表达式1 ){\n  条件表达式1成立时,执行的代码块;\n}else if( 条件表达式2 ){\n  条件表达式1不成立时,条件表达式2成立,执行的代码块;\n}else if( 条件表达式3 ){\n  条件表达式1和2都不成立时,条件表达式3成立,执行的代码块;\n}else if( 条件表达式4 ){\n  条件表达式1,2,3都不成立时,条件表达式4成立,执行的代码块;\n}else{\n  以上条件表达式都不成立,执行的代码块\n}\nvar age = 12;if (10 &lt;= age &amp;&amp; age &lt;= 16) &#123;    console.log(&quot;少年&quot;);&#125; else if (17 &lt;= age &amp;&amp; age &lt;= 44) &#123;    console.log(&quot;青年&quot;);&#125; else if (45 &lt;= age &amp;&amp; age &lt;= 64) &#123;    console.log(&quot;中年&quot;);&#125; else if (65 &lt;= age) &#123;    console.log(&quot;老年&quot;);&#125; else &#123;    console.log(&quot;幼年&quot;);&#125;\n\n\n\nswitch语句实现多分支\n运算规则: \n\n拿到switch()里面的变量名的值跟 case后面值进行”全等全等全等”比较, 如果比较成功, 则执行对应的代码块, 执行完代码块以后, 检查是否存在break关键字; 如果有break关键字,则结束switch分支; 如果没有break关键字,会一直往下执行代码块,直到遇到break关键字为止\n变量值跟case所有的所有值比较的时候,都不成立, 如果存在default语句,就会执行default默认的代码块\n\n\n扩展知识:  如果多个case 值的代码块是相同的情况下,可以把多个case值写在一起\n\n语法\nswitch(变量名)&#123;    case 值1:     case 值2:    case 值3:        满足case值1或者case值2或者case值3,都会执行的代码块;        break;            case 值4:        代码块4;        break;    case 值5:        代码块5;        break;    default:        如果给定default 子句，这条子句会在 表达式 的值与任一 case 语句都不匹配时执行&#125;\n\nvar week = 3;switch (week) &#123;    case 1:        console.log(&quot;星期一打篮球&quot;);        break;    case 2:        console.log(&quot;星期二打乒乓球&quot;);        break;    case 3:        console.log(&quot;星期三唱歌&quot;);        break;    case 4:        console.log(&quot;星期四打桌球&quot;);        break;    case 5:        console.log(&quot;星期五游泳&quot;);        break;    case 6:    case 7:        console.log(&quot;周末睡觉休息&quot;);        break;    default:        console.log(&quot;请输入1~7之间的数字!!!&quot;);&#125;\n\nif多分支语句与switch之间的区别\nswitch语句它在功能上和if语句多分支很相似 \n如果是”范围”的判断推荐使用if语句多分支\n如果是”固定值”之间的比较 推荐使用switch语句\n因为switch能够实现的功能  我们其实完全可以使用if语句多分支来实现！\n\n循环结构循环结构有循环四要素\n\n初始化变量, 循环从什么值开始\n循环条件, 循环什么时候结束\n循环体, 重复执行的代码块就是循环体\n变量更新, 更新变量的值,如果不更新变量的值,那么循环会一直成立,就会造成死循环\n\nwhile循环\nwhile循环语法\n初始化变量;while( 循环条件 )&#123;    循环体;    变量更新;&#125;\n\nvar i = 1; // 初始化变量;while (i &lt;= 5) &#123; // 循环条件    // 循环体    console.log(&quot;hello&quot; + i);    // 变量更新    i++;&#125;\n\ndo…while循环\ndo…while循环语法\n初始化变量;do&#123;    循环体;    变量更新;&#125;while( 循环条件 );\n\n**注意：**while先判断再执行循环体,  do…while先执行一次循环体,再判断 所以 do…while执行会执行一次循环体\nvar i = 1;while (i &lt;= 5) &#123;    console.log(i);    i++;&#125;console.log(&quot;&quot;);console.log(&quot;&quot;);var i = 1;do &#123;    console.log(i);    i++;&#125; while (i &lt;= 5);console.log(&quot;&quot;);console.log(&quot;&quot;);console.log(&quot;&quot;);\n\nfor循环\nfor循环语法:\nfor(①初始化变量; ②循环条件; ④变量更新 )&#123;    ③循环体;&#125; \n\nfor (var i = 1; i &lt;= 3; i++) &#123;    console.log(i);&#125;\n\n\n双重for循环\n\n// 九九乘法表var str = &quot;&quot;;str += &quot;&lt;table border=&#x27;1&#x27;&gt;&quot;;for (var i = 1; i &lt;= 9; i++) &#123; // 外层循环控制行    str += &quot;&lt;tr&gt;&quot;;    for (var j = 1; j &lt;= i; j++) &#123; // 内层循环控制列        str += &quot;&lt;td&gt;&quot; + j + &quot; &amp;times; &quot; + i + &quot; = &quot; + i*j + &quot;&lt;/td&gt;&quot;;    &#125;    str += &quot;&lt;/tr&gt;&quot;;&#125;str += &quot;&lt;/table&gt;&quot;;document.write(str);\n\n\n\n循环中断关键字典型的，当条件表达式不成立了，那么循环体就会终止执行。也可以称之为循环它寿终正寝了。\n\n循环提前终止:本来条件表达式是成立了，循环体还可以继续的往下执行，但是我们可以使用一些关键字让其提前终止。\n\nbreak和continue 循环终止的关键字  都需要配合 if语句来实现  主要的作用是为了提升循环的效率！\n\n注意:  break和continue这个两个关键字,只能在”循环语句”中使用\n\n\nbreak\nbreak打断的意思，当在循环体中遇到了break关键字以后，”立即跳出整个循环”\n\n// 举例: 小明吃5个包子，吃到第3个发现里面有半个虫子，感觉到恶心, 没胃口, 所以剩下其余包子都不吃了for (var i = 1; i &lt;= 5; i++) &#123;    if (i == 3) &#123;        console.log(&quot;吃到第3个发现里面有半个虫子,后面的包子不想吃了&quot;);        break;    &#125;    console.log(&quot;小明在吃第&quot; + i + &quot;个包子&quot;);&#125;\n\ncontinue\ncontinue继续的意思，”立即跳出当前本次循环，继续下一次循环”\n\n// 举例:  小明吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子for (var i = 1; i &lt;= 5; i++) &#123;    if (i == 3) &#123;        console.log(&quot;第3个有虫子，就扔掉第3个, 后面第4个和第5个包子没问题&quot;);        continue;    &#125;    console.log(&quot;小明在吃第&quot; + i + &quot;个包子&quot;);&#125;\n\n\n\n数组\n什么是数组？数组是一组数据”有序”的集合。数组它是属于”复合数据类型”。至少可以存储一个值。\n\n为什么要使用数组？因为在我们工作中 有很多数据是有关联的  我们要表示的时候想把这些数据用一个”东西”来存储，这个时候就可以用到数组！ \n\n所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。\n\n数组的相关概念\n什么是数组元素, 数组元素就是数组中每个数据\n数组元素的类型, 数组元素的类型可以是JS中的任意类型\n数组下标(索引), 数组下标默认就是从0开始每次递增1的数字\n如何访问数组里面的某一个元素, 数组变量名[数组下标]\n数组的长度, 数组长度就是数组元素的总个数;  通过 数组变量名.length 可以获取数组长度\n❤注意: 数组长度是一个动态值, 随着数组元素的总个数变化而变化\n❤❤❤最大数组下标 &#x3D; 数组长度 - 1;\n\n\n\n定义数组\n方式一: 使用[]来定义数组\n\n// 使用[]定义空数组var arr1 = [];console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;arr1.length=&gt;&quot;, arr1.length);console.log(&quot;&quot;);// 使用[]定义非空数组// var 数组变量 = [值1, 值2, 值3...]var arr2 = [&quot;zhangsan&quot;];console.log(&quot;arr2=&gt;&quot;, arr2);console.log(&quot;arr2.length=&gt;&quot;, arr2.length);console.log(&quot;&quot;);var arr3 = [&quot;abc&quot;, 123, true, null, undefined, [10, 20, 30]];console.log(&quot;arr3=&gt;&quot;, arr3);// 获取数组长度console.log(&quot;arr3.length=&gt;&quot;, arr3.length);// 获取某个数组元素console.log(&quot;arr3[0]=&gt;&quot;, arr3[0]);console.log(&quot;arr3[2]=&gt;&quot;, arr3[2]);// 注意: 通过下标访问不存在的数组元素将返回undefinedconsole.log(&quot;arr3[6]=&gt;&quot;, arr3[6]);console.log(&quot;arr3[7]=&gt;&quot;, arr3[7]);console.log(&quot;arr3[8]=&gt;&quot;, arr3[8]);\n\n\n方式二: 使用new Array()构造函数方式来定义数组\n\n// 定义空数组var arr4 = new Array();console.log(&quot;arr4=&gt;&quot;, arr4);// 定义指定长度的空数组// var 数组变量名 = new Array( size ); // size是数值var arr5 = new Array(5);console.log(&quot;arr5=&gt;&quot;, arr5);var arr6 = new Array(&quot;5&quot;);console.log(&quot;arr6=&gt;&quot;, arr6);var arr7 = new Array(5, 6);console.log(&quot;arr7=&gt;&quot;, arr7);// 定义非空数组// var 数组变量名 = new Array( 值1, 值2, 值3, 值4... )var arr8 = new Array(10, &quot;abc&quot;, 30, true, 50, 60);console.log(&quot;arr8=&gt;&quot;, arr8);console.log(&quot;&quot;);\n\n\n修改数组元素值\n语法\n数组变量名[数组下标] &#x3D; 新值\n\n\nvar arr9 = [10, 20, 30, 40, 50];console.log(&quot;arr9=&gt;&quot;, arr9);console.log(&quot;arr9[1]=&gt;&quot;, arr9[1]);arr9[1] = 234;console.log(&quot;arr9=&gt;&quot;, arr9);console.log(&quot;arr9[1]=&gt;&quot;, arr9[1]);\n\n多维数组\nJavaScript它本身是没有多维数组的概念，因为在JavaScript中 数组元素的数据类型可以是”任意数据类型”。\n假设在一个数组中有一些数组元素的的类型还是”数组”  这个时候我们就将它称之为多维数组！  也就是数组嵌套数组\n\n超过一维都是可以叫多维，多维数组指的是一个数组中的数组元素又是一个数组。\n\n\n// 二维数组, 就是数组嵌套数组 只嵌套一层var arr1 = [&quot;zhangsan&quot;, 23, &quot;男&quot;, &quot;Java&quot;, &quot;183cm&quot;];console.log(&quot;arr1=&gt;&quot;, arr1);// 如何访问二维数组中的某个数组元素// 语法// 数组变量名[下标1][下标2]console.log(arr[1][1]);console.log(arr[2][4]);\n\n数组的遍历\n数组的遍历就是把数组中所有的数组元素都访问一遍, 类似,早上班长点名\n\n由于数组的下标是从0开始的,最大下标是数组长度-1, 所以是可以确定循环次数, 那么我们就推荐使用for循环遍历\n\n\n一维数组的遍历\n遍历一维数组的语法\nfor(var i &#x3D; 0; i &lt; 一维数组变量名.length; i++ ){\n​    console.log( 一维数组变量名[i] )\n}\n\n\nvar arr = [10, 20, 30, 40, 50];for (var i = 0; i &lt;= arr.length - 1; i++) &#123;    console.log(arr[i]);&#125;\n\n二维数组的遍历\n二维数组遍历语法\n\nfor(var i &#x3D; 0; i &lt; 二维数组变量名.length; i++ ){\n​\tfor(var j &#x3D; 0; j &lt; 二维数组变量名[i].length; j++ ){\n​\tconsole.log(二维数组变量名[i][j]);\n​\t}\n}\nfor (var i = 0; i &lt; students.length; i++) &#123;    for (var j = 0; j &lt; students[i].length; j++) &#123;        console.log(students[i][j]);    &#125;    console.log(&quot;&quot;);&#125;\n\n新增数组元素\n新增数组元素,就是在已经创建好的数组基础上,往数组中添加新的数组元素\n\n格式:\njavascript里的数组可以通过 (数组变量名[数组下标] &#x3D; 值) 实现新增数组元素\n\n注意:\n\n如果数组下标已经存在,新值会覆盖旧值\n如果数组下标不存在,就会添加新元素,但是可能会跳过一些没有值的元素\n\n\n备注: 后期我们学习数组对象的方法的以后,我们可以使用\n数组对象.push() 方法给数组尾部添加 或者 数组对象.unshift() 方法给数组头部添加元素\n\n\nvar heros = [&quot;亚瑟&quot;, &quot;李白&quot;, &quot;小乔&quot;];console.log(heros);console.log(&quot;heros.length=&gt;&quot;, heros.length);console.log(&quot;&quot;);heros[heros.length] = &quot;王昭君&quot;;console.log(heros);console.log(&quot;heros.length=&gt;&quot;, heros.length);\n\n\n\n函数\n为什么需要函数？xxxxxxxxxx     &#x2F;&#x2F; 与v-for同级的ref 返回值都是列表渲染出来当前元素数组集合            &#x2F;&#x2F;v-for 内部的ref 返回值也是列表渲染出来当前元素数组集合        -span        没用的a                &lt;button @click&#x3D;”showRefList”&gt;click​    new Vue({        el: &#39;#app&#39;,        data: {            arr: [1, 2, 3, 4, 5]        },        methods: {            showRefList() {​                console.log(this.$refs.numList,                            this.$refs.spanList)                // [p,p,p,p,p] , [span,span,span,span,span]              }        }    })html\n\njs里面，也有非常多的相同代码，可能需要大量重复使用。 此时我们可以利用函数。\n\n为了解决代码的重用！(代码的复用 )\n减少代码量。\n\n\n函数的封装函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口( 把代码写在函数中, 通过函数名()就可以指定函数里面的代码 )\n简单理解：封装类似于将电脑配件整合组装到机箱中 (类似快递打包）  \n\n什么是函数？函数 就是封装了 一段 可被重复调用执行的 代码块。可以实现大量代码的重复使用。\n函数是可以被命名的，它是为了解决某些功能的代码段！\n可以被命名：表示函数是可以有名字的，也是可以没有名字的。\n代码段：函数体\n\n函数的分类分为系统内置函数和自定义函数\n系统内置函数就是js给我们提供的函数,我们可以直接使用\n自定义函数就是程序员根据需求自定义封装的函数\n\n\n定义函数(声明函数)\n语法 \nfunction 函数名( 形参1,形参2 ,形参3... )&#123;    函数体;    return 返回值;&#125;\n\n结构说明:\n\nfunction是定义函数的关键字, 区分大小写\n函数名可以自定义,但是有规则和规范,跟变量名的规则和规范一样的   由az AZ 0~9  _ $组成 不能以数字开头 不能使用js中的关键字和保留字\n()里面的是形参列表,形参就是形式参数, 形参可以省略 “形参的作用是为了接收调用函数的时才能确定的值” 形参其实就是一个变量,接收值使用的 形参是在函数中使用的;  在()里面写形参的时候,不需要加上var关键字;  形参如果没有接收到实参值的时候,默认形参的值undefined\n函数体就是封装在函数中的代码块, 函数体被封装到函数里面以后, 函数体代码不会执行 函数体代码需要函数被调用以后才会执行  函数被调用几次, 函数体就会执行几次 \nreturn 返回值, 是向函数的调用者返回指定的值 return语句可以省略\n\n\n例子1: 定义无形参的函数\n\n\nfunction fn() &#123;    console.log(&quot;hello&quot;);    console.log(&quot;你好鸭&quot;);    console.log(&quot;今天也要加油鸭&quot;);    console.log(&quot;&quot;);&#125;fn();\n\n\n例子2: 定义只有一个形参的函数\n\nfunction fn(username) &#123;    console.log(&quot;username形参的值为:&quot;, username);    console.log(username + &quot;,早上好&quot;);    console.log(&quot;&quot;);&#125;fn();fn(&quot;张三疯&quot;);\n\n\n例子3: 定义多个形参的函数\n\n// 函数的封装就是把代码写到函数里面function getSum(a, b) &#123;    console.log(&quot;a=&gt;&quot;, a);    console.log(&quot;b=&gt;&quot;, b);    console.log(&quot;a+b=&gt;&quot;, a + b);    console.log(&quot;&quot;);&#125;getSum();getSum(12);getSum(20, 30);getSum(50, 60, 70);\n\n定义函数的方式\n方式1 “函数声明方式” function 关键字 (命名函数) 🧡\n\n\n语法\nfunction 函数名( 形参1, 形参2, 形参3…){\n​    函数体;\n​    return 返回值;\n}\n\n\nfunction fn(a, b, c) &#123;    return a + b + c;&#125;console.log(fn(11, 22, 33));\n\n\n方式2 “函数表达式”  其实就是把匿名函数赋值给一个变量 🧡\n\nvar getSum = function (num1, num2) &#123;    return num1 * num2;&#125;console.log(getSum(5, 6));\n\n\n方式3 构造函数  new Function()   用的不多  了解即可\n\n\n语法\nvar 函数名 &#x3D; new Function(“形参1”, “形参2”, …, “函数体”);\n注意: new Function()定义函数的时候, new Function()里面的参数都是字符串\n\n\nvar sayHello = new Function(&quot;username&quot;, &quot;age&quot;, &#x27;console.log(&quot;我叫&quot; + username + &quot;,我今年&quot; + age + &quot;岁了&quot;)&#x27;);sayHello(&quot;zhangsan&quot;, 23);sayHello(&quot;lisi&quot;, 24);sayHello(&quot;wangwu&quot;, 25);\n\n函数形参和实参数量不匹配\n函数调用的时候实参不是必需的,javascript允许在调用函数的时候省略实参\n\nfunction getSum(a, b) &#123;    console.log(&quot;a=&gt;&quot;, a);    console.log(&quot;b=&gt;&quot;, b);    console.log(&quot;&quot;);&#125;// ❤❤❤实参个数等于形参个数getSum(10, 20);// 实参个数比形参个数少getSum(30);getSum();// 实参个数比形参个数多getSum(40, 50, 60, 70, 100);\n\n\n通过  函数名.length  可以得到形参的个数\n\nconsole.log(&quot;getSum形参的个数为:&quot;, getSum.length);\n\n\n不能省略前面的参数,只能省略后面的参数;如果一定要省略前面的参数,可以传入undefined\n\n// getSum(100);// getSum(, 100);// 报错getSum(&quot;&quot;, 100);getSum(null, 100);getSum(undefined, 100);\n\nreturn关键字\n一般在函数体里面不会有输出语句，只会有一个return关键字，将我们要输出的内容返回给”函数的调用者”。\nreturn在英文中表示“返回”的意思\nreturn关键字是在函数体里面使用\n\n如果函数体中没有return返回值, 或者只写return关键字,没有return具体值, 那么函数的调用者将得到undefined\n\nreturn它在函数体使用有两层含义：\n第一层含义: 当函数体里面遇到了return关键字以后，当前的这个return后面的函数体就不会再往下进行执行了。\n第二层含义:它会向”函数的调用者”返回数据 (重点) 返回值\n\n\n同名函数覆盖问题\nJS运行的时候,会分为预解析阶段和代码执行阶段\n预解析阶段主要负责检查语法,变量提升,函数提升等\n代码执行阶段,就是按一定的顺序,执行我们的JS代码\n先预解析阶段, 后代码执行阶段\n使用function关键字声明函数的时候, 是发生在预解析阶段, 会提前声明\n\n情况1: 在同一个&lt;script&gt;标签中, 定义多个相同函数名的函数的时候,后面定义的函数会覆盖前面定义的函数\n\n情况2: 在不同的外部js文件中, 定义多个相同函数名的函数,在同一个页面中引入这些js文件,后面引入的js文件定义的函数会覆盖前面引入js文件定义的函数\n\n情况3: 不同&lt;script&gt;块中的定义的同名函数互不影响\n\n\n函数中的arguments对象\narguments是一个关键字,只能在函数中使用, 它的取值是一个对象,所以也称之为arguments对象\narguments的值也是一个伪数组 “会把所有实参放在一个伪数组中” 伪数组就是类似数组一样 有length长度属性 有下标\n但是它不是真正的数组 不能使用数组对象的内置方法\n\narguments对象用在形参个数不确定的时候\n\n\n// console.log(arguments);// 报错function fn(a, b) &#123;    console.log(&quot;a=&gt;&quot;, a);    console.log(&quot;b=&gt;&quot;, b);    console.log(&quot;arguments=&gt;&quot;, arguments);    console.log(&quot;arguments.length=&gt;&quot;, arguments.length);    console.log(&quot;arguments[0]=&gt;&quot;, arguments[0]);    console.log(&quot;arguments[1]=&gt;&quot;, arguments[1]);    console.log(&quot;arguments[2]=&gt;&quot;, arguments[2]);    console.log(&quot;arguments[3]=&gt;&quot;, arguments[3]);    console.log(&quot;arguments[4]=&gt;&quot;, arguments[4]);    console.log(&quot;&quot;);&#125;fn();fn(50, 60, 70, 80, 90);\n\n匿名函数\n什么是匿名函数？ 没有名字的函数 称之为匿名函数！ \n\n匿名函数的使用匿名函数需要”赋值给变量”或者”赋值给事件” 或者 “立即调用这个匿名函数”\n\n\n// 把匿名函数赋值一个变量var a = function (x, y) &#123;    console.log(&quot;x=&gt;&quot;, x);    console.log(&quot;y=&gt;&quot;, y);    console.log(&quot;我是匿名函数1111&quot;);&#125;console.log(a);// 调用匿名函数,匿名函数赋值一个变量// 语法// 变量名();a(12, 14);// 把匿名函数赋值给一个事件(DOM知识)// 事件被触发以后,就会执行相应的函数var btn = document.querySelector(&quot;button&quot;);btn.onclick = function () &#123;    console.log(&quot;点击了按钮&quot;);&#125;\n\n立即执行函数\n立即调用的函数表达式( IIFE )\n也可以叫自调用匿名函数 , 简称 IIFE ( Immediately-invoked function expression )\n\n自调用你们函数使用场景: 只需要执行一次，不需要重复调用\n\n在定义函数之后，就会立即调用该函数,语法如下:\n\n;(function(){ 函数体 }());\n;( function()&#123;    console.log(&quot;我是匿名函数5555&quot;);&#125;() );\n\n;( function(){ 函数体 } )();🧡\n;( function()&#123;    console.log(&quot;我是匿名函数6666&quot;);&#125; )();\n\n**注意:**两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。\n\n\n经典算法-冒泡排序\n冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法\n\n冒泡排序思想\n让数组当中相邻的两个数进行比较，数组当中比较小的数值向下沉，数值比较大的向上浮！\n外层for循环控制循环次数，内层for循环控制相邻的两个元素进行比较。\n\n\n// 封装成冒泡排序函数function bubbleSort(arr) &#123;    for (var i = 0; i &lt; arr.length - 1; i++) &#123;        for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                // 交换两个变量的值                var temp = arr[j + 1];                arr[j + 1] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    return arr;&#125;var myArr = [5, 63, 4, 12, 6, 72, 33];console.log(&quot;myArr=&gt;&quot;, myArr);var myNewArr = bubbleSort(myArr);console.log(&quot;myNewArr=&gt;&quot;, myNewArr);\n\n\n 11-经典算法-冒泡排序.html \n\n对象\n什么是对象？\nJavaScript 对象是拥有”属性”和”方法”的数据。\n属性就是特性,特点\n方法就是行为,功能\n说白, 属性就是把变量存在对象中, 方法就是把函数存在对象中 通过对象访问属性 通过对象调用方法\n\n为什么要有对象？\n\n表达结构更清晰\n可以大量复用\n\n\n对象的分类\n内置对象 以及 自定义对象\n内置对象就是JS给我们提供的对象,我们可以直接使用, String, Date, Number, Array, RegExp, Window, Document等等\n自定义对象就是程序员根据需要自己定义的对象\n\n\n创建对象\n创建对象,使用字面量 {}  🧡\n\n// 1.1 创建一个空对象var obj1 = &#123;&#125;;console.log(&quot;obj1=&gt;&quot;, obj1);// 1.2 创建非空对象/* var 对象名 = &#123;            属性名1: 属性值1 ,            属性名2: 属性值2 ,            属性名3: 属性值3 ,            方法名1: 匿名函数1,             方法名1: 匿名函数2,            ...         &#125; */var obj4 = &#123;    uname: &quot;lisi&quot;,    age: 24,    sayHello: function (a) &#123;        console.log(&quot;你猴啊&quot;);        console.log(&quot;a=&gt;&quot;, a);        return &quot;好你妹啊&quot;;    &#125;,    sayHi: function () &#123;        console.log(&quot;嗨&quot;);    &#125;,&#125;console.log(&quot;obj4=&gt;&quot;, obj4);\n\n\n创建对象 使用函数 new Object()\n\nvar obj5 = new Object();console.log(&quot;obj5=&gt;&quot;, obj5);// 往空对象中添加属性和方法obj5.x = 10;obj5.y = 20;var x = 100;obj5.start = function () &#123;    console.log(&quot;开始&quot;);    // ❤❤❤在方法中,如何访问对象的属性或者方法    console.log(&quot;x=&gt;&quot;, x);    console.log(&quot;obj5.x=&gt;&quot;, obj5.x);    // ❤❤❤在方法中, 可以使用this关键字,代表当前对象    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;this === obj5=&gt;&quot;, this === obj5);    console.log(&quot;this.x=&gt;&quot;, this.x);    this.stop();&#125;\n\n注意: new Object()只能创建空对象\nvar obj6 = new Object( uname:&quot;wangwu&quot; );// 报错console.log(&quot;obj6=&gt;&quot;, obj6);\n\n以下代码,不会报错,但是实现的效果不对\nvar obj8 = new Object(uname = &quot;wangwu&quot;, age = 23);console.log(&quot;obj8=&gt;&quot;, obj8);var obj9 = new Object(&quot;wangwu&quot;, 23);console.log(&quot;obj9=&gt;&quot;, obj9);var obj10 = new Object(23, &quot;孙七&quot;);console.log(&quot;obj10=&gt;&quot;, obj10);\n\n\n构造函数\n\n访问对象的属性\n语法1 对象名.属性名 🧡\n\nconsole.log(obj4.uname);\n\n\n语法2 对象名[“属性名”]\n\nconsole.log(obj4[&quot;age&quot;]);\n\n注意: 如果访问不存在的对象属性, 会返回undefined\n调用对象的方法\n语法1: 对象名.方法名()\n\nobj4.sayHi();console.log(obj4.sayHello(10));\n\n\n语法2: 对象名[&quot;方法名&quot;]()\n\nobj4[&quot;sayHi&quot;]();\n\n注意: 如果调用对象中不存在的方法,会报错\nobj4.sleep();// 报错\n\n\n修改对象中某个属性的值\n\nconsole.log(&quot;obj4=&gt;&quot;, obj4);obj4.uname = &quot;李冰冰&quot;;console.log(&quot;obj4=&gt;&quot;, obj4);obj4[&quot;age&quot;] = 28;console.log(&quot;obj4=&gt;&quot;, obj4);\n\n\n添加新属性或者新方法到已存在对象中\n\nobj4.sex = &quot;男&quot;;obj4.sex = &quot;女&quot;;console.log(&quot;obj4=&gt;&quot;, obj4);obj4.eating = function () &#123;    console.log(&quot;吃个饭饭&quot;);&#125;console.log(&quot;obj4=&gt;&quot;, obj4);\n\n删除属性\n访问对象中不存在,会得到undefinedar obj = &#123;    uname: &quot;zhangsan&quot;,    age: 23&#125;console.log(&quot;obj=&gt;&quot;, obj);console.log(&quot;obj.uname=&gt;&quot;, obj.uname);console.log(&quot;obj.age=&gt;&quot;, obj.age);console.log(&quot;obj.sex=&gt;&quot;, obj.sex);\n\n删除属性语法\n语法1: delete 对象名.属性名;\n\n语法2: delete 对象名[“属性名”]\n\n\ndelete obj.age;delete obj[&quot;age&quot;];console.log(&quot;obj=&gt;&quot;, obj);console.log(&quot;&quot;);console.log(&quot;obj.uname=&gt;&quot;, obj.uname);console.log(&quot;obj.age=&gt;&quot;, obj.age);\n\n使用for…in遍历数组或者自定义对象因为对象没有数字下标,而且对象的属性名是没有规律的,所以不能使用简单for循环实现对象的遍历\n\n同名属性会覆盖\nvar obj = &#123;    uname: &quot;zhangsan&quot;,    uname: &quot;lisi&quot;,    age: 23&#125;console.log(obj);\n\n属性名默认是”字符串类型”,所以属性名是可以加上引号的\nvar obj = &#123;    &quot;1&quot;: 456,    1: 123&#125;console.log(obj);obj[1] = 789;console.log(obj);obj[&quot;1&quot;] = 666;console.log(obj);\n\n如果属性名有一些特殊符号, 比如短横杠-, 那么就一定要写引号\nvar obj1 = &#123;    &quot;user-name&quot;: &quot;sunqi&quot;,    &quot;age&quot;: 53,    &quot;user_sex&quot;: &quot;男&quot;,&#125;console.log(obj1);var sunqi = &quot;孙琪琪&quot;;var obj2 = &#123;    &quot;user-name&quot;: &quot;sunqi&quot;,    &quot;user-name2&quot;: sunqi,    age: 53,    user_sex: &quot;男&quot;,&#125;console.log(obj2);\n\n语法\nfor(var 变量名 in 数组对象或者自定义对象 ){\n​    1. 如果for…in遍历的是自定义对象, 那么变量名代表对象的属性名\n​    2. 如果for…in遍历的是数组对象, 那么变量名代表数组的下标\n}\n\n\nvar obj = &#123;    uname: &quot;李狗蛋&quot;,    age: 28,    sex: &quot;男&quot;,    a: &quot;我是aaaaa&quot;&#125;;for (var a in obj) &#123;    console.log(&quot;a=&gt;&quot;, a);    console.log(&quot;obj.a=&gt;&quot;, obj.a);    console.log(&#x27;obj[&quot;a&quot;]=&gt;&#x27;, obj[&quot;a&quot;]);    console.log(&#x27;obj[a]=&gt;&#x27;, obj[a]);    console.log(&quot;&quot;);&#125;console.log(&quot;&quot;);console.log(&quot;&quot;);console.log(&quot;&quot;);var arr = [10, 20, 30, 40, 50];for (var k in arr) &#123;    console.log(&quot;k=&gt;&quot;, k);    console.log(&quot;arr[k]=&gt;&quot;, arr[k]);    console.log(&quot;&quot;);&#125;\n\nJS的内置对象\nJS的内置对象有\n\nString对象:提供了处理字符串的属性与方法。\nMath对象:提供了一些操作数学方面属性与方法 \nArray对象:提供了一些操作数组的属性与方法\nDate对象:提供了一些对时间日期操作的方法\nNumber对象:它主要是提供了一个操作数值的方法\nEvents对象:提供对JavaScript事件的处理信息。\n\n\n通过 MDN&#x2F;W3C&#x2F;手册 查询需要的内容\nMozilla 开发者网络(MDN)提供有关开放网络技术(Open Web)的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。\n\nMDN :  https://developer.mozilla.org/zh-CN/    推荐W3C:    http://www.w3school.com.cn/jsref/index.asp菜鸟教程:  https://www.runoob.com/js/js-tutorial.html\n\n\n如何学习对象中的方法？\n\n先了解这个方法是哪个对象的,  这个方法的功能是什么\n参数的意义和类型\n返回值意义和类型\n编码demo案例代码进行测试效果\n\n\n\nMath对象Math.PI\nMath.PI 求圆周率\nconsole.log(Math.PI);\n\nMath.ceil()\nMath.ceil(x) 对x进行向上取整 得到一个比当前数要大的最小整数\nconsole.log(Math.ceil(5.9123)); // 6console.log(Math.ceil(5.2555)); // 6console.log(Math.ceil(5.0)); // 5console.log(Math.ceil(5.0000001)); // 6console.log(Math.ceil(-5.0)); // -5console.log(Math.ceil(-5.15566)); // -5console.log(Math.ceil(-5.677)); // -5\n\nMath.floor()\nMath.floor(x) 对x进行向下取整 得到一个比当前数要小的最大整数\nconsole.log(Math.floor(5.9123)); // 5console.log(Math.floor(5.2555)); // 5console.log(Math.floor(5.0)); // 5console.log(Math.floor(5.0000001)); // 5 console.log(Math.floor(-5.0)); // -5console.log(Math.floor(-5.15566)); // -6console.log(Math.floor(-5.677)); // -6\n\nMath.round()\nMath.round(x) 对x进行四舍五入取整\nconsole.log(Math.round(4.4)); // 4console.log(Math.round(4.45)); // 4console.log(Math.round(4.2)); // 4console.log(Math.round(4.5)); // 5\n\nMath.abs()\nMath.abs(x) 返回x的绝对值\nconsole.log(Math.abs(5));console.log(Math.abs(-5));console.log(Math.abs(5.2123456));console.log(Math.abs(-5.2789456));console.log(Math.abs(0));\n\nMath.max()\nMath.max(x1,x2,x3…) 求x1,x2,x3…这些数中的最大值\nconsole.log(Math.max(52, 75, 9, 3, 42));\n\nMath.min()\nMath.min(x1,x2,x3…) 求x1,x2,x3…这些数中的最小值\nconsole.log(Math.min(52, 75, 9, 3, 42));\n\nMath.pow(x,y)\nMath.pow(x,y) 求x的y次方 也就是y个x相乘\nconsole.log(Math.pow(2, 5));console.log(Math.pow(5, 0));console.log(Math.pow(2, -2));console.log(Math.pow(2, 0.3));\n\nMath.sqrt(x)\nMath.sqrt(x) 求平方根 比如4的平方根是2\nconsole.log(Math.sqrt(4));console.log(Math.sqrt(0));console.log(Math.sqrt(1));\n\nMath.random()\nMath.random() 生成一个”随机小数”, 取值范围 是 范围[0，1) 左闭右开 0 &lt;&#x3D; 随机小数 &lt; 1\nconsole.log(Math.random());\n\n\n使用Math.random()实现指定范围的随机整数\n公式:  Math.floor( Math.random() * (大值 - 小值 + 1) + 小值 )\n\n// 求出 30 ~ 35while (true) &#123;    var num = Math.floor(Math.random() * (35 - 30 + 1) + 30);    console.log(num);    if (num == 30 || num == 35) &#123;        break;    &#125;&#125;\n\n\n06-使用Math.random()实现指定范围的随机整数.html\n\n\n\n随机生成十六进制颜色var a = Math.random();console.log(a);// JS中,  可以使用 数值.toString(进制) 可以把其他类型的值转成指定进制的字符串console.log(a.toString(16));console.log(a.toString(16).substr(2, 6));console.log(&quot;#&quot; + a.toString(16).substr(2, 6));console.log(&quot;#&quot; + a.toString(16).substr(2, 3));\n\nString对象String对象的创建方式\n通过字面量 “”  ‘’\n\nvar str1 = &quot;abc&quot;;var str2 = &#x27;abc&#x27;;console.log(str1);console.log(str2);\n\n\n通过构造函数  new String(“字符串内容”)\n\nvar str3 = new String(&quot;abc&quot;);console.log(str3);\n\nString对象的属性\nString对象的属性 字符串的长度(字符总个数)\n通过 String对象.length 获取字符串的长度\n\nvar str4 = &quot;abc123@_@哈哈哈&quot;;console.log(str4.length);\n\nString对象的方法**注意:**字符串所有的方法，”都不会修改字符串本身”，操作完成会返回一个”新的字符串”\n**注意:**字符串方法中的”索引”都是从”0”开始!\n根据位置获取字符charAt()\n❤charAt(index) \n返回指定位置的字符(index 字符串的索引号) str.charAt(0)\n\nstr[]\n❤❤str[index] \n获取指定位置处字符 HTML5，IE8+支持 和charAt()等效\n\ncharCodeAt()\ncharCodeAt(index) \n获取指定位置处字符的ASCII码 (index索引号) str.charCodeAt(0)\n\nString.fromCharCode()\nString.fromCharCode(ASCII码) \n返回指定ASCII码对应的字符串 String.fromCharCode( 65 )\n\n\nASCII百度百科介绍:   https://baike.baidu.com/link?url=jcW6UQw1vRpolAwT3xlq8qRnxuZF_aG0T3zhw4yc_WZUiqDUltiUeHptJr4RDzJafctcoJORKDKFIhSsZlh77K\n\n字符串操作方法concat()\nconcat(str1,str2,str3…) concat() 方法用于连接两个或多个字符串。拼接字符串，等效于+，+更常用\n\nsubstr()\nsubstr(start[, length]) \n从start位置开始(索引号) ，length 取的个数\n如果length (长度)没有书写 表示一直截取到字符串的末尾  如果有写则表示截取的长度  \n另外,start还可以写负值,表示从倒数第几个开始截取,比如 “abc”.substr(-2,1) 表示从倒数第二个字符串开始截取一个长度的字符\n\nvar str = &quot;abcdefghij&quot;;console.log(str);// 如果忽略 length，则 substr 提取字符，直到字符串末尾console.log(str.substr(2));// 从下标2开始,截取长度为3的字符串console.log(str.substr(2, 3));// start 为负值, 从字符串的倒数第几个开始截取console.log(str.substr(-5));console.log(str.substr(-5, 2));// 如果 length 为 0 或负值，则 substr 返回一个空字符串console.log(str.substr(-5, -2));console.log(str.substr(-5, 0));\n\nsubstring()\nsubstring(start[, end]) \n截取字符串 从start(开始下标)处开始截取 ; \n如果end(结束下标) 没有书写 表示一直截取到字符串的末尾  \n如果有写则表示截取到end下标的前一个位置\n\n// substring(开始下标[, 结束下标])var anyString = &quot;Mozilla&quot;;console.log(anyString);// 省略结束下标,就会从开始下标开始截取到字符串的末尾console.log(anyString.substring(2));// 有开始下标也有结束下标  含头不含尾console.log(anyString.substring(2, 4));\n\n获取字符串位置方法indexOf()\nindexOf(“要查找的字符或字符串”) \n返回指定内容在原字符串中”第一次”出现的位置\n如果找不到就返回 -1; \n如果查找的是多个字符,找的到就返回第一个字符的下标\n\nlastIndexOf()\nlastIndexOf(“要查找的字符或字符串”) \n返回指定内容在原字符串中”最后一次”出现的位置， \n如果找不到就返回 -1; \n如果查找的是多个字符 ,找的到就返回第一个字符的下标\n\nvar str = &quot;this is a island&quot;;console.log(str.indexOf(&quot;g&quot;));console.log(str.indexOf(&quot;i&quot;));console.log(str.indexOf(&quot;is&quot;));console.log(&quot;&quot;);console.log(&quot;&quot;);console.log(str.lastIndexOf(&quot;g&quot;));console.log(str.lastIndexOf(&quot;i&quot;));console.log(str.lastIndexOf(&quot;is&quot;));\n\n替换 replace()\nreplace(“被替换字符串”, “替换成什么字符串”) 方法用于在字符串中用一些字符替换另一些字符, 默认只替换一次,不会全部替换\n如果需要全部替换,可以使用正则表达式(这个正则后续课程会讲)或者字符串对象的replaceAll()方法\n注意: 一些旧版浏览器对一些js方法比如这个replaceAll方法不是很兼容，会出现js报错问题。\n如果要全部替换的话，浏览器又不支持replaceAll这样的方法，那可以换成了使用正则表达式实现\n\n\n参考文档: https://www.jianshu.com/p/457943f03397\n\nvar str = &quot;hello,world!hello,javascript!hello,html!&quot;;console.log(str);console.log(&quot;&quot;);// replace默认只替换一次,不会全部替换console.log(str.replace(&quot;hello&quot;, &quot;你好&quot;));console.log(str.replace(&quot;hi&quot;, &quot;你好&quot;));console.log(&quot;&quot;);// 如果需要全部替换,可以使用&quot;正则表达式&quot;或者字符串对象的replaceAll(&quot;被替换字符串&quot;, &quot;替换成什么字符串&quot;)方法console.log(str.replace(/hello/g, &quot;你好&quot;));console.log(str.replaceAll(&quot;hello&quot;, &quot;你好&quot;));\n\n转换大小写toUpperCase()\n英文字母全部转换成大写\n\ntoLowerCase()\n英文字母全部转换成小写\n\nvar str = &quot;HeLLo&quot;;console.log(str);console.log(str.toUpperCase());console.log(str.toLowerCase());\n\n切割字符串 split()\nsplit(sep)  使用sep参数将字符串分隔为一个”数组”\nsep就是代码根据什么字符来分割字符串\nsep如果是””代表,”分割每一个字符”\n\nvar str = &quot;张三-李思思-王武-赵柳柳&quot;;console.log(str);var arr = str.split(&quot;-&quot;);console.log(arr);var arr2 = str.split(&quot;&quot;);console.log(arr2);\n\n\n如果split中没有任何参数 或者 分割符分割不了当前字符串,那么将得到一个数组元素的数组, 而且这个数组元素就是这个字符串\n\nvar arr3 = str.split();console.log(arr3);var arr4 = str.split(&quot;@&quot;);console.log(arr4);\n\n去除字符串的左右两边的所有空格 trim()var str = &quot;   zhang san    &quot;;console.log(str, str.length);console.log(str.trim(), str.trim().length);\n\n求字符串字符串中出现最多字符// 字符串var str = &quot;comeaweiabc&quot;;// 定义一个空对象var obj = &#123;&#125;;// 遍历字符串for (var i = 0; i &lt; str.length; i++) &#123;    // 取出单个字符    var char = str.charAt(i);    if (obj[char] == undefined) &#123;        // 给对象添加属性         obj[char] = 1;    &#125; else &#123;        obj[char]++;    &#125;&#125;// 出现最多次的次数var maxCount = 1;// 出现最多次的字符var maxChar = str[0];// 遍历对象objfor (var attr in obj) &#123;    // 判断大小    if (maxCount &lt; obj[attr]) &#123;        // 出现最多次的次数        maxCount = obj[attr];        // 出现最多次的字符        maxChar = attr;    &#125;&#125;console.log(maxChar, maxCount);\n\nArray对象Array对象创建方式数组-定义数组\n检测是否为数组\n方式1. Array.isArray( 值或者变量 )  判断指定值或者变量是否为数组 返回布尔值  如果是数组返回true, 不是数组返回false\n\n方式2: instanceof 运算符\ninstanceof 可以判断一个对象是否是某个构造函数的实例,返回布尔值\n\n\nvar str = &quot;abc&quot;;var num = 10;var bool = true;var weidingyi = undefined;var kong = null;var arr = [10, 20, 30];var obj = &#123;    uname: &quot;zhangsan&quot;&#125;;console.log(str, typeof str, Array.isArray(str), str instanceof Array);console.log(num, typeof num, Array.isArray(num), num instanceof Array);console.log(bool, typeof bool, Array.isArray(bool), bool instanceof Array);console.log(weidingyi, typeof weidingyi, Array.isArray(weidingyi), weidingyi instanceof Array);console.log(kong, typeof kong, Array.isArray(kong), kong instanceof Array);console.log(arr, typeof arr, Array.isArray(arr), arr instanceof Array);console.log(obj, typeof obj, Array.isArray(obj), obj instanceof Array);\n\nArray对象的属性数组的长度就是数组元素的总个数\n数组的长度  数组对象.length\nArray对象的方法数组添加和删除元素方法\n\n\n方法名\n功能\n\n\n\npush(值1,值2…)\n向数组尾部添加一个或者多个值, 返回新的数组长度\n\n\npop()\n删除尾部最后一个数组元素  返回被删除的数组元素\n\n\nunshift(值1,值2…)\n向数组头部添加一个或者多个值, 返回新的数组长度\n\n\nshift()\n删除头部最后一个数组元素 返回被删除的数组元素\n\n\n**注：**以上4个方法,都会修改原数组、\nvar arr = [10, 20, 30];console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);var res1 = arr.push(40);console.log(&quot;res1=&gt;&quot;, res1);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);var res2 = arr.push(50, 60, 70);console.log(&quot;res2=&gt;&quot;, res2);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);var res3 = arr.pop();console.log(&quot;res3=&gt;&quot;, res3);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);var res4 = arr.pop();console.log(&quot;res4=&gt;&quot;, res4);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);var res5 = arr.unshift(100, 200);console.log(&quot;res5=&gt;&quot;, res5);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);var res6 = arr.shift();console.log(&quot;res6=&gt;&quot;, res6);console.log(&quot;arr=&gt;&quot;, arr);\n\n合并数组方法concat(数组1,数组2…)  合并多个数组, 合成一个大数组, 将返回一个”新数组” 注意 不是合并成多维数组\nvar arr1 = [10, 20, 30];var arr2 = [200, 500];var arr3 = [&quot;lisi&quot;, &quot;lisi&quot;, &quot;wangwu&quot;];// concat()方法中不写参数,将返回原数组一模一样的新数组console.log(arr1.concat());// concat()里面放参数0console.log(arr1.concat(arr1));console.log(arr1.concat(arr2, arr3));console.log(arr1.concat(arr3, arr2));console.log(arr1.concat(arr3, arr2, [&quot;189cm&quot;, &quot;90kg&quot;]));// 合并数组,我们不建议使用+号, 因为+号会把每个数组中数组元素已逗号作为连接符,每个组成拼接成一个字符串, 最后再拼接成一个大字符串  +号其实会调用数组的toString()方法console.log(arr1 + arr2 + arr3);console.log(arr1.toString() + arr2.toString() + arr3.toString());console.log(arr1);console.log(arr1.toString());document.write(arr1);\n\n数组索引方法\nindexOf(“内容”)  查找数组中数组元素第一次出现的位置; 找不到返回-1\nlastIndexOf(“内容”) 查找数组中数组元素最后一次出现的位置; 找不到返回-1\n\nvar arr = [10, 20, 30, 10, 20, 50, 60, 20];console.log(arr.indexOf(100));console.log(arr.lastIndexOf(100));console.log(arr.indexOf(20));console.log(arr.lastIndexOf(20));\n\n数组转换为字符串\njoin(“连接符”)  把数组元素按指定的连接符拼接成一个字符串  “连接符”参数可以省略,将使用逗号作为连接符\n\nvar arr = [&quot;zhangsan&quot;, 23, &quot;男&quot;, 10, 20, 30];console.log(arr);console.log(arr.join());console.log(arr.join(&quot;-&quot;));console.log(arr.join(&quot;@&quot;));\n\n\ntoString()把数组转成字符串的时候,数组元素之间只能使用逗号连接\n\nvar arr = [10, 20, 30];console.log(arr.toString());console.log(arr.toString(&quot;-&quot;));console.log(arr.toString(&quot;|&quot;));\n\n小结: 字符串对象的.split()方法是把字符串分割成数组,而数组对象的.join()方法是把数组拼接成字符串\n数组排序方法\n数组中有对数组本身排序的方法，部分方法如下表\n\n\n\n方法名\n功能\n\n\n\nreverse()\n颠倒数组中元素的顺序,无参数 “该方法会改变原来的数组“ 返回新数组\n\n\nsort()\n对数组的元素进行排序 该方法会改变原来的数组 返回新数组\n\n\n\n注意： \n\nsort方法需要传入一个可以返回正值或者负值或者零的函数作为参数\n如果传入” function(a,b){ return a-b;}”，则为升序\n如果传入” function(a,b){ return b-a;}”，则为降序\n如果sort()里面未传递参数,那么数组元素将按照ASCII字符顺序进行升序排列\n\n\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n\nvar arr = [&quot;zhangsan&quot;, 52, &quot;女&quot;, 75, 60];arr.reverse();console.log(arr);\n\n\n直接使用sort()方法 sort方法不带参数, 那么将按”ASCII字符顺序进行升序排列\n\nvar str = &quot;aoAefo5xbAyoG1zzcD6op9p&quot;;var arr = str.split(&quot;&quot;);console.log(&quot;原数组arr=&gt;&quot;, arr.join(&quot;&quot;));// 直接使用sort()方法 sort方法不带参数, 那么将按&quot;ASCII字符顺序进行升序排列&quot;arr.sort();console.log(&quot;sort()以后的数组arr=&gt;&quot;, arr.join(&quot;&quot;));\n\n\nsort()方法里面可以放一个排序函数\n\nvar arr = [3, 5, 1, 60, 4, 72, 12, 139, 63, 92];console.log(arr);arr.sort(function (a, b) &#123;    // 升序    return a - b;&#125;);console.log(arr);var arr = [3, 5, 1, 60, 4, 72, 12, 139, 63, 92];console.log(arr);arr.sort(function (a, b) &#123;    // 降序    return b - a;&#125;);console.log(arr);\n\n数组元素的随机排序(抽奖)实现数组元素的随机排序, 使用Math.random()方法结合sort()方法\nvar arr = [1, 2, 3, 4, 5, 6, 7];console.log(&quot;arr=&gt;&quot;, arr);arr.sort(function () &#123;    return Math.random() - 0.5;&#125;);console.log(&quot;arr=&gt;&quot;, arr);\n\n清空数组所有元素的两种方式\n赋值空数组\n\nvar arr1 = [10, 20, 30, 40, 50];console.log(&quot;arr1=&gt;&quot;, arr1);// 第一种方式  赋值空数组arr1 = [];console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;&quot;);console.log(&quot;&quot;);\n\n\n设置数组的长度为0 因为数组的长度就是数组元素的总个数\n\nvar arr2 = [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;];console.log(&quot;arr2=&gt;&quot;, arr2);// 第二种方式  设置数组的长度为0 因为数组的长度就是数组元素的总个数arr2.length = 0;console.log(&quot;arr2=&gt;&quot;, arr2);\n\n数组截取slice()\n数组截取slice( begin, end ) 返回一个”新的数组对象”，\n这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。\n“原始数组不会被改变”。  数组截取就是”复制”数组中某部分数组元素到新数组中\n\n注意: begin和end参数都是可选的\n\n\n// slice() 不写任何参数, 从下标0开始截取到数组的末尾var newArr1 = arr.slice();console.log(&quot;newArr1=&gt;&quot;, newArr1);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);// slice(start) 写第一个start参数, 代表从下标start开始截取末尾var newArr2 = arr.slice(2);console.log(&quot;newArr2=&gt;&quot;, newArr2);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);// slice(start, end) 写两个参数, 代表从下标start开始截取到end下标  含头不含尾var newArr3 = arr.slice(2, 5);console.log(&quot;newArr3=&gt;&quot;, newArr3);console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);\n\n数组删除splice()\n\n\nsplice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法”会改变原数组”。\n\n\n\n格式1: splice(start)\n\n\n格式2: splice(start, deleteCount)\n\n\n格式3: splice(start, deleteCount, item1)\n\n\n格式4: splice(start, deleteCount, item1, item2, itemN)\n\n\n格式4: splice(开始下标, 删除个数, 要添加进数组的元素1, 要添加进数组的元素2, 要添加进数组的元素N)\n\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8];console.log(&quot;arr=&gt;&quot;, arr);console.log(&quot;&quot;);// 从下标2开始, 删除2个数组元素,  添加100, 200, 300,400到开始下标2的前面var newArr = arr.splice(2, 2, 100, 200, 300, 400);console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;arr=&gt;&quot;, arr);\n\n数组遍历 forEach()\nforEach对数组进行循环。（一般我们也会用for对数组进行循环，但是用for会麻烦一些，因为它要用循环变量）\n\nforEach() 方法对数组的每个元素执行一次给定的函数。\n\n\n\n参考文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n\nvar arr = [10, 20, 30, 40, 50, 60];arr.forEach(); // 报错,forEach()方法中需要传递至少一个function参数var arr = [10, 20, 30, 40, 50, 60];arr.forEach(function () &#123;&#125;); // 不报错var arr = [10, 20, 30, 40];arr.forEach(function () &#123;    console.log(&quot;hello&quot;);&#125;);\n\nvar arr = [10, 20, 30, 40];arr.forEach(function () &#123;    // arguments对象,可以得到实参列表    console.log(&quot;arguments=&gt;&quot;, arguments);&#125;); var arr = [10, 20, 30, 40];arr.forEach(function (item, index, array) &#123;    console.log(&quot;item=&gt;&quot;, item);    console.log(&quot;index=&gt;&quot;, index);    console.log(&quot;array=&gt;&quot;, array);    console.log(&quot;&quot;);&#125;);\n\n数组过滤 filter()\nfilter() 方法创建给定数组一部分的浅拷贝，其包含通过所提供函数实现的测试的所有元素。\n\n有几个数组元素,就会执行几次filter传递的function函数\n\n如果filter的function函数中return了一个可以转成true的值,那么表示这个数组元素通过了测试,需要留下, 也就是放进新数组中\n\n\n\n参考文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n\nvar newArr = arr.filter(function () &#123;&#125;);console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.forEach(function () &#123;&#125;);console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.filter(function () &#123;    return &quot;abc&quot;;&#125;);console.log(&quot;newArr=&gt;&quot;, newArr);\n\n\n**注意：**数组对象的forEach方法是没有返回值的,也就是返回值为undefined\n​      数组对象的filter方法的返回值是一个新数组, 该新数组元素的值由function返回的值是否可以转为true决定\n\n\nvar newArr = arr.forEach(function () &#123;    return true;&#125;);console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.forEach(function () &#123;    return &quot;abc&quot;;&#125;);console.log(&quot;newArr=&gt;&quot;, newArr);\n\n逐一处理 map()\nmap() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的”返回值”组成。\n\n\n参考文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n\nvar arr = [1, 4, 9, 16];var newArr = arr.forEach(function () &#123;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.filter(function () &#123;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.map(function () &#123;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.map(function () &#123;    return 123;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.map(function () &#123;    return 1;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.map(function () &#123;    return 2 &lt; 3;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);console.log(&quot;&quot;);var newArr = arr.map(function (item) &#123;    console.log(&quot;item=&gt;&quot;, item, &quot;item*2=&gt;&quot;, item * 2);    return item * 2;&#125;)console.log(&quot;newArr=&gt;&quot;, newArr);\n\n\n小结:\nforEach用于遍历数组\nfilter用于筛选所有符合条件的数组元素\nmap用于数组元素进行处理\n\n\n\n\n03-逐一处理map().html \n\nDate对象Date对象创建方式\nnew Date(); 创建”当前”日期时间对象\nvar date1 = new Date();        console.log(date1);\n\nnew Date(“日期时间字符串”)  创建”指定”日期时间对象\n\n时间可以省略\n\nvar date2 = new Date(&quot;2008-08-12&quot;);console.log(date2);var date3 = new Date(&quot;2008-8-12&quot;);console.log(date3);var date4 = new Date(&quot;2008/08/12&quot;);console.log(date4);var date5 = new Date(&quot;2008/8/12&quot;);console.log(date5);\n\n\n不能只写时间, 日期必须写\n\nvar date6 = new Date(&quot;12:17:8&quot;);console.log(date6);var date7 = new Date(&quot;12:17:08&quot;);console.log(date7);var date8 = new Date(&quot;12:17&quot;);console.log(date8);var date9 = new Date(&quot;12&quot;);console.log(date9);\n\n\n写日期也写时间\n\nvar date10 = new Date(&quot;2008-8-12 12:17:8&quot;);console.log(date10);var date11 = new Date(&quot;2008-08-12 12:17:08&quot;);console.log(date11);var date12 = new Date(&quot;2008/08/12 12:17:08&quot;);console.log(date12);var date13 = new Date(&quot;2008/8/12 12:17:08&quot;);console.log(date13);\n\nnew Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);\n注意: 表示月份的整数值，从 0（1 月）到 11（12 月）。\n\n建议至少需要写年份和月份两个参数,其他参数可以省略,有默认值\n\nconsole.log(new Date(2012, 2));console.log(new Date(2012, 2, 5));console.log(new Date(2012, 2, 5, 10));console.log(new Date(2012, 2, 5, 10, 8));console.log(new Date(2012, 2, 5, 10, 8, 6));console.log(new Date(2012, 2, 5, 10, 8, 6, 755));\n\n\n最后一个参数是毫秒数milliseconds,直接输出日期对象,是看不到毫秒数\n需要使用 日期对象.getMilliseconds() 获取日期对象的毫秒数\n\n\nconsole.log(new Date(2012, 2, 5, 10, 8, 6).getMilliseconds());console.log(new Date(2012, 2, 5, 10, 8, 6, 755).getMilliseconds());\n\nDate对象的方法\n\n\n方法名\n功能\n\n\n\ngetFullYear()\n获取4位数的年份\n\n\ngetMonth()\n获取月份 返回值 0~11 0表示1月 11表示12月\n\n\ngetDate()\n返回一个月中的某一天 返回值：1~31\n\n\ngetHours()\n小时 返回值0~23\n\n\ngetMinutes()\n获取分钟 返回值：0~59\n\n\ngetSeconds()\n获取秒数 返回值：0~59\n\n\ngetMilliseconds()\n获取毫秒 返回值：0~999\n\n\ngetDay()\n获取一周中的某一天 就是星期几 返回值：0~6 0代表星期天 1代表星期一\n\n\ngetTime()\n获取时间戳 返回从1970年1月1日00时00分00秒到现在的毫秒数！\n\n\ntoLocaleString()\n根据本地时间把 Date 对象转换为字符串，并返回结果。\n\n\n通过Date对象获取总毫秒数(时间戳)方式1: 日期对象.getTime() 或者 日期对象.valueOf()\nvar d = new Date();console.log(d.getTime());console.log(d.valueOf());console.log(&quot;&quot;);\n\n方式2: Date.now();\nconsole.log(Date.now());console.log(&quot;&quot;);\n\n方式3: +日期对象  比如 +new Date();\nconsole.log(+new Date());\n\nnumber对象Number对象创建方式方式1: 字面量\nvar num1 = 10;console.log(num1);var num2 = 123.456;console.log(num2);\n\n方式2: 构造函数Number\nvar num3 = new Number(10);console.log(num3);var num4 = new Number(123.456);console.log(num4);\n\nNumber对象的方法 toFixed()\nNumber.prototype.toFixed()\n\n\n-方法使用定点表示法来格式化一个数值。\n\n\n语法\nnumber数值对象.toFixed(小数点后数字的个数)\n\n返回值  使用定点表示法表示给定数字的”字符串”。\n\n\n// 注意: toFixed()会进行四舍五入var num2 = 123.426;console.log(num2);console.log(num2.toFixed(0));console.log(num2.toFixed(1));console.log(num2.toFixed(2));console.log(num2.toFixed(10));\n\n变量数据类型的转换变量数据类型的转换分为两种\n第一种: 强制转换(显式转换)  通过几个JS的内置函数完成转换\n第二种: 自动转换(隐式转换)  JS根据我们的代码上下文进行自动转换\n注意: 强制转换和自动转换的结果是相同的\n强制转换(显式转换)其他类型转换成字符串类型\n方式1  toString()  注意: null和undefined无法使用toString方法\n备注: 进制之间转换可以使用toString方法,把指定数值转成指定进制字符串, toString方法返回的结果是一个”字符串”\n​      Number对象.toString( 进制 )\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\n\n\n方式2  String(变量名或者值)  都可以使用String方法\n\n\n其他类型转换成数值类型\nNumber( 变量名或者值 )\n\n\nNaN是一个JS关键字,代表 not a number\n\n\n\n\n数据格式\n转换后的结果\n\n\n\n“数字”\n数字\n\n\n“数字字符”\nNaN\n\n\n“字符数字”\nNaN\n\n\n“字符”\nNaN\n\n\n“” 和 “ “空字符串和有空格的字符串\n0\n\n\ntrue\n1\n\n\nfalse\n0\n\n\nundefined\nNaN\n\n\nnull\n0\n\n\n[] 空数组\n0\n\n\n{} 空对象 以及 非空数组以及非空对象\nNaN\n\n\n\n**小结:**只要是在字符串中含有非数字的都会转换为NaN;\n\n\nparseInt()方法 这个方法我们主要用于提取整数, 不会进行四舍五入操作 返回值是数值类型\nparseInt(string  [, radix] )   解析一个字符串并返回指定基数的十进制整数， radix 是2-36之间的整数，表示被解析字符串的基数。\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n注意: 如果parseInt()如果第一个参数不是一个字符串，则将其转换为字符串 (使用 ToString抽象操作)。字符串开头的空白符将会被忽略。\n\n\nconsole.log(123);console.log(parseInt(123));// 5进制的123 =&gt; 1*5^2 + 2*5^1 + 3*5^0 = 25 + 10 + 3 = 38 console.log(parseInt(123, 5));// 5进制的123  但是输出的时候, 我们看到的是十进制的数   // 8进制21 =&gt;  2*8^1 + 1*8^0 = 16 + 1 = 17console.log( parseInt(021, 8) );// 8进制的21console.log( 021.toString() ); // 8进制的21转成字符串以后得到的&quot;17&quot;// 8进制的17 =&gt; 1*8^1 + 7*8^0 = 8 + 7 = 15console.log( parseInt( &quot;17&quot;, 8) );// 8进制的17\n\n\nparseFloat(string)  函数解析一个参数（必要时先转换为字符串）并返回一个浮点数(小数)\nparseFloat() 从字符串中提取小数 将字符串转换为number类型\nparseFloat() 从一个字符串提取小数 如果第一个字符不是数字会得到NaN 如果是会进行提取\n提取规则 如果遇到了除了第一个.以外的非数字 就会停止提取\n\n\nconsole.log(parseFloat(&quot;123.456abc&quot;));console.log(parseInt(&quot;123.456abc&quot;));console.log(parseFloat(&quot;123.456.789abc&quot;));console.log(parseFloat(&quot;abc123.456.789&quot;));\n\nNaN问题\n判断值是否为NaN, 不可以使用 &#x3D;&#x3D; 或者 &#x3D;&#x3D;&#x3D;\n\n判断值是否为NaN, 需要使用一个内置函数 isNaN()\n\nisNaN()判断是否为NaN\tisNaN &#x3D;&gt; is not a number  \nisNaN(变量名)  如果是NaN就返回true  如果不是NaN的就是false\n\n\n注意: isNaN 会先将一个变量的数据类型自动的转换为Number类型  如果是NaN就会得到true　如果是一个数字的话就是得到false\nconsole.log( isNaN( NaN ) , Number(NaN) );console.log( isNaN( true ), Number(true) );console.log( isNaN(&quot;abc&quot;) , Number(&quot;abc&quot;) );console.log( isNaN( 123 ) , Number(123) );console.log( isNaN( &quot;456&quot;) , Number(&quot;456&quot;) );\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN#description\n\n其他类型转转换成布尔类型\n方式: Boolean( 变量名或者值 )\n\n只需记住5个假值：undefined、 null、0、”” 和NaN   其他的值都是真值\n\n重点记住 Boolean(1) &#x3D;&gt; true,  Boolean(0) &#x3D;&gt; false\n\n\nconsole.log( Boolean(null) );// falseconsole.log( Boolean(undefined) );// falseconsole.log( Boolean(0) );// falseconsole.log( Boolean(&quot;&quot;) );// falseconsole.log( Boolean(NaN) );// falseconsole.log( Boolean(&quot;0&quot;) );// trueconsole.log( Boolean(1) );// trueconsole.log( Boolean(5) );// trueconsole.log( Boolean(&quot; &quot;) );// true\n\n自动转换(隐式转换)在js中，当运算符在运算时，如果两边数据类型不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算。这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换\n例如： 1 &gt; “0”  这行代码在js中并不会报错，编译器在运算符时会先把右边的”0”转成数字0 然后再比较大小\nconsole.log(1 &gt; &quot;0&quot;);\n\n隐式转换规则\n字符串连接符\n介绍:用于数字时，运算符+表示加法运算，而用于字符串时，表示拼接。如果你试图将数字和字符串相加，JavaScript将把数字转换为字符串，再进行拼接。\n\n\nconsole.log(10 + 20);console.log(10 + &quot;20&quot;);\n\n\n算术运算符\n介绍：如 ++&#x2F;–(自增自减运算符) + - * &#x2F; %(算术运算符)  &gt; &lt; &gt;&#x3D; &lt;&#x3D;(比较运算符)\n\n\nJavaScript将认为你要执行的是算术运算，而不是字符串运算。JavaScript会将数据转成number类型。\nvar str = &quot;123&quot;;console.log(str, typeof str);++str;console.log(str, typeof str);console.log(&quot;&quot;);var str = &quot;123abc&quot;;console.log(str, typeof str);++str;console.log(str, typeof str);\n\n\n关系运算符：&#x3D;&#x3D;   !&#x3D; \n介绍：进行比较时，关系运算符&#x3D;&#x3D; 或者 !&#x3D; 会考虑其操作数（要比较的两个值）的”类型”。如果两个值的”类型相同”，就”直接进行比较”，如果两个值的”类型不同”，JS则尝试将它们转换为”相同的类型”，再进行比较\n\n细节1: 字符串和数字比较时，字符串转”数字”,再比较\n\nconsole.log( Number(&quot;2&quot;) ); console.log( &quot;2&quot; == 2 );\n\n\n细节2: 数字和布尔比较时，布尔转”数字”,再比较\n\nconsole.log( Number( true ) );console.log( Number( false ) );console.log( 5 == true );console.log( 1 == true );console.log( 0 == true );\n\n\n细节3: 字符串和布尔比较时，两者转”数字”,再比较\n\nconsole.log( &quot;1&quot; == true );console.log( &quot;0&quot; == false );console.log( &quot;5&quot; == false );\n\n\n细节4: 对象和布尔比较时，两者转”数字”,再比较\n\nconsole.log( Number( &#123;&#125; ) );console.log( &#123;id: 1&#125; == true );console.log( &#123;&#125; == false );\n\n\n细节5: 对象和数值比较时，对象转”数字”,再比较\n\nconsole.log( Number(&#123; id : 1&#125;) );console.log( &#123; id : 1&#125; == 1 );\n\n\n细节6: undefined与null &#x3D;&#x3D;比较时,  undefined和null都转”布尔”,再比较\n**注意：**使用严格关系运算符 &#x3D;&#x3D;&#x3D;（严格相等）和 !&#x3D;&#x3D;(严格不相等)遵循当且仅当两个值的类型和值都相同时，它们才是严格相等的规则。就无需操心类型转换的问题\n\n\nconsole.log( Boolean(undefined) );console.log( Boolean(null) );console.log( undefined == null );console.log( undefined === null );\n\n条件表达式：!（逻辑非运算符）\n介绍：在JavaScript中用于条件表达式中时被视为true或false。\n要记住哪些值是真值，哪些值是假值，只需记住5个假值：undefined、 null、0、”” 和NaN   其他的值都是真值。\n\n\nconsole.log(2, !2);console.log(undefined, !undefined);console.log(null, !null);console.log(0, !0);console.log(&quot;&quot;, !&quot;&quot;);console.log(NaN, !NaN);\n\n\n\n递归\n什么是递归概念：递归就是直接或间接的调用自身的一种”函数”。递归是一种强大的编程技术。他把一个问题分解为一组”相似”的问题，每一组都使用”通用方法”去解决。简单来说一个递归函数就是调用函数自身去解决它的子问题。\n\n递归, 先递进,再回归，递归通俗地讲就是函数自己调用自己，它具有以下三要素1、一个大问题可以分解为更小的问题, 而且用同样的方法解决\n2、分解后的子问题求解方式一样，不同的是规模在变小\n3、存在递归终止条件\n\n**注意：**在使用递归函数时一定要设置退出函数的条件，否则会发生死循环造成严重问题\n\n**注意：**递归函数的作用和循环效果一样，由于递归很容易发生“超过最大调用堆栈大小”错误（Maximum call stack size exceeded），所以必须要加退出条件\n\n递归的目的递归的目的是用于解决特殊的问题,这类问题需要具备以下的特点 \n\n大问题可以拆分成小问题 \n小问题可以继续拆分为小小问题 无论问题规模的大小 解决方式都一样\n\n\n递归的用法\n第一步:封装一个能解决单一问题的函数(类似循环体)\n\n第二步:在这个函数中调用当前函数 调整问题的规模(类似循环中的变量更新) \n\n第三步:在函数中设置递归出口 如果没有递归出口 递归调用无法结束(类似循环中的判断条件)\n\n\n\n举例: 使用递归输出10~1\n使用循环输出10~1,包括10和1\nfunction fn(i) &#123;    // 控制台输出内容    console.log(i);    // 调整规模    i--;    if (i == 0) &#123;        // return可以终止函数体的执行        return;    &#125;    // 再次调用自身函数    fn(i);&#125;fn(10);\n\n\n04-递归课堂练习.html \n\n使用递归实现扁平化数组功能function flatten(arr) &#123;    // 创建一个新的空数组    var newArr = [];    // 遍历数组arr    arr.forEach(function (item) &#123;        // console.log(&quot;item=&gt;&quot;, item);        // 如何判断一个值是否为数组        // console.log( Array.isArray( item ) );        // console.log(&quot;&quot;);        if (Array.isArray(item)) &#123; // 判断item是否为数组            // console.log(&quot;item=&gt;&quot;, item );            // 再次调用flatten()            var res = flatten(item);            // 拼接数组            newArr = newArr.concat(res);        &#125; else &#123;            newArr.push(item);        &#125;    &#125;);    // 返回newArr    return newArr;&#125;var arr1 = [1, 2, 3, [4, 5, [6, 7], 8, 9]];console.log(flatten(arr1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]var arr2 = [    [100, 200, [666, [888, 999]]], 10, 20];console.log(flatten(arr2)); // [100, 200, 666, 888, 999, 10, 20]\n\n\n\n作用域(Scope)\n作用域概述作用域是当前的执行上下文，值 (en-US)和表达式在其中“可见”或可被访问。如果一个变量 (en-US)或表达式不在当前的作用域中，那么它是不可用的。作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。简单说,作用域就是什么地方能用,什么地方不能用。\n\nJavaScript 的作用域分以下三种：\n全局作用域\n\n全局作用域：脚本模式运行所有代码的默认作用域\n任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。例如：\n// 全局变量var greeting = &#x27;Hello World!&#x27;;function greet() &#123;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();\n\n\n函数作用域\n\n函数作用域(局部作用域)：由函数创建的作用域\n函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。\n这些变量只能在函数内部访问，不能在函数以外去访问。例如：\nfunction greet() &#123;  var greeting = &#x27;Hello World!&#x27;;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n\n块级作用域\n\nES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。看例子：\n&#123;  // 块级作用域中的变量  let greeting = &#x27;Hello World!&#x27;;  var lang = &#x27;English&#x27;;  console.log(greeting); // Prints &#x27;Hello World!&#x27;&#125;// 变量 &#x27;English&#x27;console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting);\n\n面向过程与面向对象介绍\n**例：**面向过程的数组排序  冒泡排序\n\n​\t\t面向对象的数组排序  看看有没有什么对象可以帮助排序的 数组对象.sort()方法\n\n面向过程: 注重于流程顺序\n分析解决问题都需要哪些步骤\n将这些步骤一步一步封装成方法\n根据业务逻辑，将方法依次调用\n\n\n面向对象：oop （Object对象 Oriented面向 Programming编程 ）\n**核心思想：**关注的是 以事务为中心 提取顺序流程中的参与者（对象） 将各个流程顺序进行划分。\n编写到各个参与者的方法里面，各自按照约定好的顺序，执行各自的流程顺序，来共同完成一个业务逻辑\n\n对象的范畴：万物万事皆对象\n\n对象的特征：属性\n\n对象的行为：方法\n\n面向对象有三大特点:\n封装性 就是封装功能代码到某个对象中\n继承性 子承父业 子构造函数可以继承父构造函数的方法和属性\n多态性  执行同一个方法，传入的对象不一样，输出的结果不一样\n\n\n\n\n\n\n参考文档: https://www.jianshu.com/p/fafa021d2ebe参考文档: https://www.jianshu.com/p/3bac73fe5e65\n\n构造函数\n**介绍:**为了解决从原型对象生成实例(生成对象)的问题，Javascript提供了一个构造函数（Constructor）模式。\n对象构造函数（简称为构造函数）让你能够更好地创建对象。构造函数犹如一个小型工厂，能够创建无数类似的对象。定义后，每当需要创建新对象时都可调用它。\n\n先定义一个构造函数，再使用它来创建对象。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。再对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。\n\n构造函数也是一种函数, 只是构造函数是专门用于创建对象的函数  为了跟普通函数更好的区分,建议构造函数名首字母大写\n\n在 JS 中，使用构造函数时要注意以下两点：1.构造函数用于创建某一类对象，其首字母要大写\n2.构造函数要和 new 一起使用才有意义\n\n构造函数语法function 构造函数名( [形参列表] )&#123;  // 添加属性  this.属性名1 = 形参1;  this.属性名2 = 形参2;  this.属性名3 = 形参3;  ...  // 添加方式  this.方法1 = function()&#123;&#125;;  this.方法2 = function()&#123;&#125;;  ...&#125;\n\nfunction Cat(name, color, weight) &#123;    console.log(&quot;1. this=&gt;&quot;, this);    // 给对象添加属性    this.name = name;    this.color = color;    this.weight = weight;    console.log(&quot;2. this=&gt;&quot;, this);    // 给对象添加方法    this.cry = function () &#123;        console.log(this.name + &quot;喵喵喵&quot;);    &#125;    this.eating = function () &#123;        console.log(this.name + &quot;吃猫粮&quot;);    &#125;    console.log(&quot;3. this=&gt;&quot;, this);&#125;var jm = Cat(&quot;橘猫&quot;, &quot;橘色&quot;, 9);console.log(&quot;jm=&gt;&quot;, jm);console.log(&quot;&quot;);var yd = new Cat(&quot;英短&quot;, &quot;灰色&quot;, 7);console.log(&quot;yd=&gt;&quot;, yd);\n\n构造函数的工作原理\n**介绍：**你知道了如何声明构造函数以及如何使用它来创建对象，但还需看看幕后的情况，以了解构造函数的工作原理。\n要明白构造函数的工作原理，关键在于了解运算符new都做了些什么。\n\n\n\nnew 首先创建一个新的空对象。\n接下来，new 设置 this，使其指向这个新对象。(this存储了一个引用，指向代码当前处理的空对象。)\n设置this后，调用函数Cat，并将 “大毛”,”黄色” 和 9作为实参传递给它。\n接下来，执行这个函数的代码。与大多数构造函数一样，Cat给新创建的this对象的属性赋值。\n最后，Cat函数执行完毕后，运算符new返回this指向新创建的对象的引用。**注意：**它会自动为你返回this，你无需在代码中显式地返回。指向新对象的引用被返回后，我们将其赋给变量cat1。\n\n// 定义一个a变量var a = null;function Cat(name, color, weight) &#123;    console.log(&quot;1. this=&gt;&quot;, this);    // 给对象添加属性    this.name = name;    this.color = color;    this.weight = weight;    console.log(&quot;2. this=&gt;&quot;, this);    // 给对象添加方法    this.cry = function () &#123;        console.log(this.name + &quot;喵喵喵&quot;);    &#125;    this.eating = function () &#123;        console.log(this.name + &quot;吃猫粮&quot;);    &#125;    console.log(&quot;3. this=&gt;&quot;, this);    // 把this赋值给a变量    a = this;&#125;var dm = new Cat(&quot;大毛&quot;, &quot;黄色&quot;, 9);console.log(&quot;dm=&gt;&quot;, dm);console.log(&quot;a=&gt;&quot;, a);console.log(&quot;dm === a&quot;, dm === a);\n\n理解对象实例\n**介绍：**你无法通过观察确定JavaScript对象是哪种类型的对象，如小狗或汽车。在JavaScript中，对象是一个动态的结构，无论对象包含哪些属性和方法，其类型都是object。\n\n概念: 说对象是某个构造函数的实例可以通过JavaScript提供的方法判断。\n\n使用运算符instanceof来确定对象是由哪个构造函数创建的。\nconsole.log(yd instanceof Cat); // trueconsole.log(yd instanceof Dog); // falseconsole.log(yd instanceof Array); // falseconsole.log(yd instanceof Date); // falseconsole.log(yd instanceof String); // falseconsole.log(yd instanceof Object); // true\n\n使用构造函数创建对象后,实例对象会自动含有一个constructor属性，指向它们的构造函数。\nconsole.log(yd.constructor);console.log(Cat);console.log(yd.constructor === Cat);\n\n\n\n\n07-理解对象实例.html \n\nthis关键字\nthis是什么\nthis是一个JS关键字\nthis的值是一个对象, 所以一般会叫this对象console.log(this);console.log(typeof this);\n\n\nthis的难点\nthis的值是不确定的, 在不同环境在, this的取值是不一样的\nthis的值不能被赋值\n\n\n确定this的值\n函数外  this代表window对象\nconsole.log(&quot;this=&gt;&quot;, this);\n\n函数内(对象的方法内)\n\n\n//2.1 普通函数内 this代表window对象function fn() &#123;    console.log(&quot;我是fn函数&quot;);    console.log(&quot;this=&gt;&quot;, this);    console.log(&quot;&quot;);&#125;fn();window.fn();\n\n**注意: **全局作用域下,使用var定义的全局变量和全局函数会成为window对象的属性和方法\n\n小结:  this的值指向调用该方法或者该函数的对象决定  谁调用我, 我就指向谁\n\n\n[12-this  重点,难点.html](....\\web\\每日代码\\19_JS\\12-this  重点,难点.html)\n\n\n\n改变函数内部 this对象 指向的三个方法\n指定 this 为 null 或 undefined 时会自动替换为指向全局对象Window\n\nFunction.prototype.call()\nFunction.prototype.call(thisArg, arg1, arg2, …) 方法使用一个指定的 this 值和单独给出的一个或多个参数来”调用一个函数”。\n\nObject.prototype.toString\nObject是一个构造函数,它有一个原型prototype\n这个原型又是一个对象，在Object.prototype这个对象中有一个方法toString\n\n由于它是一个function，则它可以使用call\n\nObject.prototype.toString的返回值不是数组(只是看起来前后有[ ] )\n它的返回结果是固定格式的：\n[object 当前对象的构造器的名字]\n\n\n\n\n**应用场景：**封装一个获取数据类型的函数\nfunction getType( val )&#123;    return Object.prototype.toString.call(val).slice(7,-1);&#125;console.log( getType(&quot;abc&quot;) );console.log( getType(123) );console.log( getType(true) );console.log( getType(false) );console.log( getType(undefined) );console.log( getType(function fn()&#123;&#125;) );console.log( getType(null) );console.log( getType([52,47,96]) );console.log( getType(&#123;&#125;) );console.log( getType(&#123;id:12,uname:&quot;二狗子&quot;&#125;) );\n\n\n[03-改变函数内部this对象指向 call方法.html](....\\web\\每日代码\\20_JS\\03-改变函数内部this对象指向 call方法.html) \n\n\n**参考文档：**https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\n\nFunction.prototype.apply()\nFunction.prototype.apply() 方法调用一个具有给定 this 值的函数，以及以一个”数组”（或一个”类数组对象”）的形式提供的参数。\n\n注意: apply()和call()最明显的区别就是传递参数的形式不同 apply()传递参数是把所有参数放在一个数组中  call()传递参数是一个一个的传\n\n\n**应用场景：**求数组的最大值或者最大小值\nvar arr = [75,96,37,5,61,12];console.log( Math.max.apply(null, arr) );console.log( Math.max.apply(undefined, arr) );console.log( Math.min.apply(null, arr) );console.log( Math.min.apply(undefined, arr) );\n\n\n[04-改变函数内部this对象指向 apply方法.html](....\\web\\每日代码\\20_JS\\04-改变函数内部this对象指向 apply方法.html) \n\n\n**参考文档：**https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\n\nFunction.prototype.bind\nFunction.prototype.bind( thisArg[, arg1[, arg2[, …]]] ) 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n注意: bind()跟call(),apply()最明显的区别是 ,  bind()是返回一个新的函数, bind()不会调用函数\n\n**应用场景：**更换延时器指定对象达到禁用按钮目的\nvar btn = document.querySelector(&quot;button&quot;);btn.onclick = function()&#123;    console.log(&quot;获取验证码成功&quot;);    // 禁用控件    this.disabled = true;    // 延时器    window.setTimeout(function()&#123;        console.log(&quot;延时器的代码执行了&quot;);        console.log(&quot;this=&gt;&quot;, this);        // 取消禁用        this.disabled = false;    &#125;.bind(this), 3000 );&#125;\n\n\n[05-改变函数内部this对象指向 bind方法.html](....\\web\\每日代码\\20_JS\\05-改变函数内部this对象指向 bind方法.html) \n\n\n**参考文档：**https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n\n构造函数的弊端\n**介绍：**构造函数方法很好用，但是存在浪费内存的问题。\n构造函数方法每次创建一个实例,”就会单独创建一个空间来存放同一个方法”,这样就比较浪费内存\n\n\n\n08-构造函数的弊端.html \n\n\n通过以上代码,我们发现内置对象Array创建的不同实例之间的同一个方法是可以共享空间的,\n但是我们自己创建的构造函数不同实例之间同一个方法是无法共享空间的\n\n原因是, 内置对象的方法都是放在”构造函数身上的一个prototype属性中” \n这个prototype属性的属性值是一个对象,所以我们也会称之为prototype对象, 也可以叫原型对象  \nprototype对象上面的方法和属性都可以被不同的实例所共享\n\n\n构造函数原型对象prototype(显式原型)\n构造函数通过原型分配的方法和属性是所有实例对象所共享的。\n\nJavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个原型对象的所有方法和属性，都会被构造函数所拥有。\n\n我们可以把那些不变的方法或者属性，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法和在这些属性。\n\n**注意:**一般情况下,我们的公共属性和公共方法我们放到原型对象身上 , 而不同的属性定义到构造函数里面\n\n**注意:**实例对象身上也可以添加属性和方法\n\n\n原型是什么？一个对象，我们也称为 prototype 为原型对象。\n\n原型的作用是什么？主要用于共享方法。\n\n\n\n\nfunction Cat(name, color, weight) &#123;    this.name = name;    this.color = color;    this.weight = weight;    // 直接在构造函数内部添加方法    this.cry = function () &#123;        console.log(this.name + &quot;喵喵喵&quot;);    &#125;    this.eating = function () &#123;        console.log(this.name + &quot;吃猫粮&quot;);    &#125;&#125;// 输出Cat构造函数console.log(Cat);// 输出Cat构造函数的原型对象prototypeconsole.log(Cat.prototype);// 给原型对象添加方法Cat.prototype.sleep = function () &#123;    // 原型对象添加的方法中this指向 调用这个方法的实例对象     console.log(&quot;this=&gt;&quot;, this);    console.log(this.name + &quot;睡觉觉&quot;);&#125;Cat.prototype.runing = function () &#123;    console.log(this.name + &quot;跑步步&quot;);&#125;console.log(Cat.prototype);\n\n__proto__(隐式原型)\n“实例对象”身上也有一个属性__proto__  这个属性会指向当前构造函数的原型对象  \n这个__proto__属性就称之为对象原型  也可以叫隐式原型\n\n正是因为实例对象身上有对象原型, 所以我们的实例对象才可以使用构造函数原型对象身上添加的方法和属性\n\n\n// 数组的原型对象console.log(Array.prototype);// 创建数组的实例对象var arr1 = [10, 20, 30, 40, 50];var arr2 = new Array(100, 200, 300);console.log(arr1.__proto__);console.log(arr2.__proto__);console.log(arr1.__proto__ === Array.prototype); //trueconsole.log(arr2.__proto__ === Array.prototype); //true\n\n原型对象的应用——扩展内置对象方法// 求数组元素和的方法Array.prototype.getSum = function () &#123;    // 在原型对象添加的方法中,this代表调用这个方法的实例对象    // console.log(&quot;this=&gt;&quot;, this);    // 定义一个变量,保存和    var sum = 0;    // 遍历数组    for (var i = 0; i &lt; this.length; i++) &#123;        sum += this[i];    &#125;    return sum;&#125;// 求数组元素最大值的方法Array.prototype.getMax = function () &#123;    // 假设数组第一个元素为最大值    var maxVal = this[0];    // 遍历数组    for (var i = 1; i &lt; this.length; i++) &#123;        if (maxVal &lt; this[i]) &#123; // 比较大小            maxVal = this[i];        &#125;    &#125;    // 返回找到的最大值    return maxVal;&#125;\n\n&lt;!-- 通过你script标签的src属性引入外链式js文件 --&gt;&lt;script src=&quot;./js/my.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var arr1 = [10, 20, 45, 96, 75];    console.log(arr1.getSum());    console.log(arr1.getMax());    console.log(&quot;&quot;);    var arr2 = [52, 62, 37, 12, 95];    console.log(arr2.getSum());    console.log(arr2.getMax());    console.log(&quot;&quot;);    var arr3 = new Array(1, 2, 3, 4, 5, 6);    console.log(arr3.getSum());    console.log(arr3.getMax());&lt;/script&gt;\n\nconstructor构造器属性\n构造函数原型对象身上自带一个constructor构造器属性\nconstructor构造器属性作用是用于指回”构造函数本身”\nfunction Cat(name, color, weight) &#123;    this.name = name;    this.color = color;    this.weight = weight;&#125;console.log(Cat.prototype);console.log(Cat.prototype.constructor);console.log(Cat.prototype.constructor === Cat); //true// 实例对象身上的对象原型指向构造函数的原型对象// 通过 new 构造函数名() 得到实例对象var bsm = new Cat(&quot;波斯猫&quot;, &quot;黑白&quot;, 9);console.log(bsm.__proto__);console.log(bsm.__proto__.constructor);console.log(bsm.__proto__.constructor === Cat); //true\n\n当我们给构造函数的原型对象赋值一个对象的时候, constructor属性就会丢失\nCat.prototype = &#123;    say: function () &#123;        console.log(this.name + &quot;喵喵喵&quot;);    &#125;,    eating: function () &#123;        console.log(this.name + &quot;吃东西&quot;);    &#125;,    sleep: function () &#123;        console.log(this.name + &quot;睡觉&quot;);    &#125;&#125;;console.log(Cat.prototype);\n\n\n07-constructor构造器属性.html \n\n原型链\n对于使用过基于类的语言 (如 Java 或 C++) 的开发者们来说，JavaScript 实在是有些令人困惑 —— JavaScript 是动态的，本身不提供一个 class 的实现。即便是在 ES2015&#x2F;ES6 中引入了 class 关键字，但那也只是语法糖，JavaScript 仍然是基于原型的。\n\n当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为 proto）指向它的构造函数的原型对象（prototype）。该原型对象也有一个自己的原型对象（proto），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。\n\n几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。\n\n**介绍：**在 JavaScript 中所有的对象（除了少数例外）都有自己的原型。而且，对象的原型本身也是一个对象。正因为原型是一个对象，所以原型对象也有它自己的原型！\n\n**概念：**所有对象都有一个__proto__(隐式原型)属性，属性指向它构造函数的prototype，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\n\n// 数组实例对象var arr = [10, 20, 30];// 数组对象原型console.log(arr.__proto__);// 数组对象原型指向数组的原型对象console.log(Array.prototype);console.log(arr.__proto__ === Array.prototype);// 原型对象也有一个自己的对象原型（__proto__）console.log(Array.prototype.__proto__);// Object的原型对象console.log(Object.prototype);console.log(Array.prototype.__proto__ === Object.prototype);console.log(Object.prototype.__proto__); // null\n\n原型链成员的查找机制\n任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性, 直到null, 这样一层一层往上找,就形成了一条链,我们称此为原型链;\n\nJavaScript 的成员查找机制(规则):\n\n当访问一个对象的属性（或者方法）时，首先查找这个对象自身有没有该属性(或者方法)。\n如果没有就查找构造函数里面是否有这个属性或者方法\n如果构造函数里面也没有, 就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。\n如果它的原型还没有, 就查找构造函数原型对象的原型（Object的原型对象）。\n依此类推一直找到 Object 为止（null）。\n__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。\n如果多个原型对象同时有同一个属性(或者方法),遵循就近原则\n\n\n\nfunction Cat() &#123;    this.color = &quot;构造函数里面设置的颜色: 蓝色&quot;;    this.say = function () &#123;        console.log(&quot;构造函数里面设置的say方法&quot;);    &#125;&#125;Cat.prototype.color = &quot;Cat构造函数原型对象身上设置的颜色: 绿色&quot;;Object.prototype.color = &quot;Object构造函数原型对象身上设置的颜色: 灰色&quot;;Cat.prototype.say = function () &#123;    console.log(&quot;Cat构造函数原型对象设置say方法&quot;);&#125;Object.prototype.say = function () &#123;    console.log(&quot;Object构造函数原型对象身上设置say方法&quot;);&#125;var bsm = new Cat();bsm.color = &quot;波斯猫实例对象身上的颜色: 红色&quot;;bsm.say = function () &#123;    console.log(&quot;波斯猫实例对象设置的say方法&quot;);&#125;console.log(bsm.color);bsm.say();console.log(&quot;&quot;);console.log(&quot;&quot;);console.log(&quot;&quot;);// JS中所有对象都可以顺着原型链找到Object的原型对象var arr = [20, 50, 60];console.log(arr);console.log(arr.color);arr.say();console.log(&quot;&quot;);console.log(&quot;&quot;);console.log(&quot;&quot;);\n\n\n另外,可以使用in运算符可以用来判断，某个实例是否含有某个属性\n如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。\nconsole.log(“属性名” in 某个对象 );\nconsole.log(&quot;length&quot; in arr);console.log(&quot;abc&quot; in arr);console.log(&quot;color&quot; in arr);\n\n实现构造函数之间的继承\n继承包括继承属性和继承方法\n继承简单就是子承父业 子构造函数继承父构造函数的方法和属性, 子构造函数也可以有自己独有的方法和属性\n\n\nfunction Animal(name, age, weight) &#123;    this.name = name;    this.age = age;    this.weight = weight;&#125;Animal.prototype.say = function () &#123;    console.log(this.name + &quot;say方法&quot;);&#125;Animal.prototype.eating = function () &#123;    console.log(this.name + &quot;eating方法&quot;);&#125;// 猫构造函数function Cat(name, age, weight, color) &#123;    /* this.name = name;            this.age = age;            this.weight = weight; */    // 继承属性    // Animal.call(this, name, age, weight);    Animal.apply(this, [name, age, weight]);    // 独有属性color    this.color = color;&#125;\n\n\n继承方法, 把父构造函数的原型对象,赋值给子构造函数的原型对象  会出现引用问题 因为是对象之间的赋值操作\n\nCat.prototype = Animal.prototype;// 手动设置constructor属性Cat.prototype.constructor = Cat;\n\n\n使用for…in遍历Animal构造函数的原型对象\n\nfor (var attr in Animal.prototype) &#123;    // console.log(&quot;attr=&gt;&quot;, attr);    // console.log(&quot;Animal.prototype[attr]=&gt;&quot;, Animal.prototype[attr]);    // console.log(&quot;&quot;);    Cat.prototype[attr] = Animal.prototype[attr];&#125;Cat.prototype.catch = function () &#123;    console.log(this.name + &quot;catch方法&quot;);&#125;var bsm = new Cat(&quot;波斯猫&quot;, 2, 9, &quot;白&quot;);console.log(bsm);bsm.say();bsm.eating();bsm.catch();\n\n\n12-实现构造函数之间的继承.html \n\n静态属性与静态方法\n通过”构造函数自身”调用的属性,称之为静态属性\n\nconsole.log(Math.PI);\n\n\n通过”构造函数自身”调用的方法,称之为静态方法\n\nconsole.log(Math.random());\n\n\n通过实例对象调用的属性,称之为实例属性\n\nvar arr = [10, 20, 30];console.log(arr);console.log(arr.length);\n\n\n通过实例对象调用的方法,称之为实例方法\n\narr.pop();\n\n\n例：\n\nfunction Person(name, age, sex) &#123;    // 实例属性    this.name = name;    this.age = age;    this.sex = sex;&#125;// 实例方法Person.prototype.sayHello = function () &#123;    console.log(this.name + &quot;,hello&quot;);&#125;// 通过构造函数自身添加的属性,就是静态属性Person.COUNTRY = &quot;China&quot;;// 通过构造函数自身添加的方法,就是静态方法Person.sleep = function () &#123;    console.log(&quot;睡觉&quot;);&#125;var zs = new Person(&quot;zhangsan&quot;, 23, &quot;男&quot;);// 实例属性和实例方法是通过&quot;实例对象&quot;调用的console.log(zs.name);console.log(zs.age);console.log(zs.sex);zs.sayHello();console.log(&quot;&quot;);console.log(&quot;&quot;);// 静态属性和静态方法是通过&quot;构造函数自身&quot;调用的console.log(zs.COUNTRY);console.log(Person.COUNTRY);// zs.sleep();// 报错Person.sleep();\n\n\n02-静态属性与静态方法.html \n\n引用(深浅拷贝)\n概念： 变量并不实际存储”对象”。”变量存储指向对象的引用”。引用就像指针，是对象的存储地址:  换句话说，变量并不存储对象本身，而是存储类似于指针的东西。在JavaScript中，但我们需要知道，当对象赋值给变量时它肯定指向相应的对象。当我们使用属性与方法时，JavaScript将负责根据引用获取对象并访问其属性。\n\n浅拷贝指的是仅拷贝对象的”指针地址”,而不复制对象本身,新旧对象还是”共享同一块内存”，这样会使被拷贝的对象会因为拷贝的对象的数据改变而改变 \n\n深拷贝指的是拷贝一个对象的数据之前先给拷贝的对象创建一个堆地址，创造一个一模一样的值 , 新值跟原值”不共享内存”, 这样当拷贝的对象指向的堆中的数据改变时，被拷贝的对象堆中的数据并不会被改变（意思就是o，obj指向不同的堆）\n\nJS中基本数据不存在引用问题\n值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。\n**注：**Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。\n\n引用数据类型（对象类型）：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。\n\n\n// 传递的意思就是 一个变量的值&quot;赋值&quot;给另一个变量// 值类型(基本类型)的传递是值传递, 互不相干var a = 10;var b = a;console.log(&quot;a=&gt;&quot;, a);console.log(&quot;b=&gt;&quot;, b);console.log(&quot;&quot;);console.log(&quot;&quot;);// 改变a的值a = 20;console.log(&quot;a=&gt;&quot;, a);console.log(&quot;b=&gt;&quot;, b);console.log(&quot;&quot;);console.log(&quot;&quot;);// 改变b的值b = 50;console.log(&quot;a=&gt;&quot;, a);console.log(&quot;b=&gt;&quot;, b);console.log(&quot;&quot;);console.log(&quot;&quot;);// 引用数据类型（对象类型）的传递是引用传递, 同生共死var obj1 = &#123;    id: 1,    name: &quot;zhangsan&quot;,    age: 23&#125;;var obj2 = obj1;console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);console.log(&quot;&quot;);console.log(&quot;&quot;);// 修改obj1的id属性obj1.id = 123;console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);console.log(&quot;&quot;);console.log(&quot;&quot;);// 修改obj2的age属性obj2.age = 24;console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);console.log(&quot;&quot;);console.log(&quot;&quot;);// 给obj1添加sex属性obj1.sex = &quot;男&quot;;console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);console.log(&quot;&quot;);console.log(&quot;&quot;);// 删除obj2里面的name属性delete obj2.name;console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);// 数组也属于引用类型数据var arr1 = [10, 20, 30];var arr2 = arr1;console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;arr2=&gt;&quot;, arr2);console.log(&quot;&quot;);console.log(&quot;&quot;);arr1[0] = 111;console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;arr2=&gt;&quot;, arr2);console.log(&quot;&quot;);console.log(&quot;&quot;);arr2[1] = 222;console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;arr2=&gt;&quot;, arr2);console.log(&quot;&quot;);console.log(&quot;&quot;);arr1.push(500, 600);console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;arr2=&gt;&quot;, arr2);\n\n解除数组引用浅拷贝(解决第一层引用)解除数组引用核心: 遍历数组赋值给新数组 或者 使用数组对象内置方法得到一个新数组 \n注意: 该方式只能解决外层引用问题,如果内层数据再次出现数组或者对象, 内层数据还是会引用\n​\t  也就是实现的是解决第一层的引用, 深层的引用解决不了\nvar arr1 = [    10,    [21, 22, 23],    30,    &#123;        id: 1,        uname: &quot;zhangsan&quot;,        age: 23    &#125;];/*var arr2 = [];// 遍历数组arr1for (var i = 0; i &lt; arr1.length; i++) &#123;    arr2[i] = arr1[i];&#125;*/var arr2 = arr1.map(function (item) &#123;    return item;&#125;);console.log(&quot;arr1=&gt;&quot;, arr1);console.log(&quot;arr2=&gt;&quot;, arr2);\n\n深拷贝实现深拷贝  自己封装函数\n// obj参数表示需要被深拷贝的对象function deepCopy(obj) &#123;    // 判断obj参数的数据类型是否为&quot;object&quot;    if (typeof obj !== &quot;object&quot;) &#123;        return obj;    &#125;    // 如果obj是对象,我们就创建新的空对象    // 如果obj是数组,我们就创建新的空数组    var newObj = Array.isArray(obj) ? [] : &#123;&#125;;    // 遍历obj    for (var attr in obj) &#123;        if (typeof obj[attr] !== &quot;object&quot;) &#123;            // 如果obj[attr]的数据类型是基本数据类型,可以直接赋值给newObj            newObj[attr] = obj[attr];        &#125; else &#123;            // 如果obj[attr]的数据类型是引用数据类型,需要再次进行deepCopy            newObj[attr] = deepCopy(obj[attr]);        &#125;    &#125;    // 返回newObj对象    return newObj;&#125;\n\n解除对象引用浅拷贝指的是仅拷贝对象的指针地址,而不复制对象本身,新旧对象还是”共享同一块内存”，这样会使被拷贝的对象会因为拷贝的对象的数据改变而改变 \n深拷贝指的是拷贝一个对象的数据之前先给拷贝的对象创建一个堆地址，创造一个一模一样的值 , 新值跟原值不共享内存, 这样当拷贝的对象指向的堆中的数据改变时，被拷贝的对象堆中的数据并不会被改变\n浅拷贝(解决第一层引用)\n方式一: for…in遍历  实现的是”浅拷贝”\n注意: 该方式只能解决外层引用问题,如果内层数据再次出现数组或者对象, 内层数据还是会引用\n​      也就是实现的是解决第一层的引用, 深层的引用解决不了\n\n\nvar obj1 = &#123;            id: 1,            uname: &quot;zhangsan&quot;,            age: 23,            hobby: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;]        &#125;        var obj2 = &#123;&#125;;        // for...in遍历obj1        for (var attr in obj1) &#123;            obj2[attr] = obj1[attr];        &#125;        console.log(&quot;obj1=&gt;&quot;, obj1);        console.log(&quot;obj2=&gt;&quot;, obj2);\n\n\n方式二: 使用ES6新增的一个Object.assign()合并对象的方法 实现的是”浅拷贝”\n\n\n语法\nObject.assign(目标对象, 源对象1, 源对象2, 源对象3… )\n\n返回值 修改后的目标对象。\n\n注意: 合并的时候, 会把源对象列表中的属性添加到目标对象中, 如果同名属性将覆盖属性值\n\n\n\n**参考文档：**https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\nvar obj1 = &#123;    id: 1,    uname: &quot;zhangsan&quot;,    age: 23,    hobby: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;]&#125;var obj2 = &#123;&#125;;Object.assign(obj2, obj1);console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);console.log(&quot;&quot;);obj1.id = 11;obj2.uname = &quot;lisi&quot;;obj1.hobby[0] = &quot;烧烤&quot;;console.log(&quot;obj1=&gt;&quot;, obj1);console.log(&quot;obj2=&gt;&quot;, obj2);\n\n深拷贝\nJSON.stringify() 与 JSON.parse()  配合使用\n\nJSON.stringify()把JSON对象转成JSON字符串的方法\n\nJSON.parse() 把JSON字符串转成JSON对象\n\n注意: 该种方式不能拷贝对象中的方法以及属性值为undefined的属性\n\n\nvar obj1 = &#123;    name: &quot;小明&quot;,    age: 19,    address: &quot;北京&quot;,    hobby: [&quot;抽烟&quot;, &quot;喝酒&quot;, &quot;烫头&quot;],    data: &#123;        friends: [&quot;lee&quot;, &quot;Tom&quot;, &quot;Jane&quot;],        mother: &quot;韩梅&quot;    &#125;,    sayHello: function () &#123;        console.log(&quot;hello&quot;);    &#125;,    sayHi: function () &#123;        console.log(&quot;Hi&quot;);    &#125;,    sex: undefined&#125;;var obj2 = JSON.parse(JSON.stringify(obj1));console.log(obj1);console.log(obj2);console.log(&quot;&quot;);obj1.name = &quot;马冬梅&quot;;obj2.age = 18;obj1.hobby[0] = &quot;唱跳Rap&quot;;obj2.data.mother = &quot;马什么梅&quot;;console.log(obj1);console.log(obj2);\n\n高阶函数\n高阶函数情况1: 把函数当做参数传递进另一个函数中, 我们使用的比较多的就是回调函数\n\nvar arr = [6, 9, 1, 42, 3];console.log(arr);console.log(&quot;&quot;);arr.forEach(function (item) &#123;    console.log(&quot;item=&gt;&quot;, item);&#125;);console.log(&quot;&quot;);arr.sort(function (a, b) &#123;    return a - b;&#125;)console.log(arr);\n\n\n高阶函数情况2: 把函数当做返回值返回出来\n\nfunction fn(a) &#123;    // return返回    return function (b) &#123;        console.log(&quot;a=&gt;&quot;, a);        console.log(&quot;b=&gt;&quot;, b);        console.log(a + b);    &#125;&#125;fn(30)(40);\n\n闭包\n什么是闭包闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函\n数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。\n\n闭包让开发者可以从内部函数访问外部函数的作用域就是表示内层函数可以访问外层函数定义的形参以及变量\n\n闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。我们知道Javascript语言的特殊之处，就在于”函\n数内部可以直接读取全局变量”。另一方面，在函数外部自然无法读取函数内的局部变量。而闭包就是能够读取其他函数内部变量的函数。在本质上，闭\n包就是将函数内部和函数外部连接起来的一座桥梁。\n\n创建闭包最简单方式就是函数嵌套函数\n闭包的特性🧡1.函数内再嵌套函数\n2.内部函数可以引用外层函数的形参和局部变量\n3.被引用的形参和局部变量不会被垃圾回收机制回收\n\n\n\n参考文档:  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures\n\nfunction fn1() &#123;    var num = 10;    function fn2() &#123;        num++;        console.log(num);    &#125;    return fn2;&#125;fn1()();\n\n点击事件,获取索引号// 解决方式一: 自定义属性var lis = document.querySelectorAll(&quot;li&quot;);for (var i = 0; i &lt; lis.length; i++) &#123;    lis[i].dataset.index = i;    lis[i].onclick = function () &#123;        console.log(&quot;li被点击以后,才会执行click事件函数里面对应的代码&quot;);        console.log(&quot;i=&gt;&quot;, i);        var index = this.dataset.index;        console.log(&quot;index=&gt;&quot;, index);        console.log(&quot;&quot;);    &#125;;&#125;console.log(&quot;i=&gt;&quot;, i);console.log(111);console.log(222);console.log(333); // 解决方式二: 闭包var lis = document.querySelectorAll(&quot;li&quot;);for (var i = 0; i &lt; lis.length; i++) &#123;    // 立即执行函数    ;(function( index )&#123;        lis[i].onclick = function () &#123;            console.log(index);        &#125;;    &#125;)( i );&#125; // 解决方式二: 闭包var lis = document.querySelectorAll(&quot;li&quot;);for (var i = 0; i &lt; lis.length; i++) &#123;    lis[i].onclick = function (index) &#123;        return function () &#123;            console.log(&quot;index=&gt;&quot;, index);        &#125;    &#125;(i);&#125;\n\n\n08-经典的古老的例子-点击事件,获取索引号.html \n\n正则表达式\n什么是正则表达式介绍：正则表达式(regular expression)是一个描述字符模式的对象，是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。\n\n正则表达式的特点\n灵活性、逻辑性和功能性非常的强。\n\n可以迅速地用极简单的方式达到字符串的复杂控制。\n\n对于刚接触的人来说，比较晦涩难懂。比如：/^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$/  验证邮箱的表达式\n\n实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. \n比如用户名: /^[a-z0-9_-]&#123;3,16&#125;$/\n\n\n\n正则表达式的作用正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。\n\n常用正则表达式vscode可以安装any-rule插件, 该插件提供了一些常用的正则表示式  安装完成以后  按ctrl+shift+p快捷键以后, 找到正则大全 可以根据需求改一些常用正则表达式\n\n正则表达式的组成一个正则表达式可以由简单的字符构成，比如 &#x2F;abc&#x2F;，也可以是简单字符和特殊字符的组合，比如 &#x2F;ab*c&#x2F; 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+、 * 、 ?等。\n\n特殊字符非常多，可以参考相关文档:\n\njQuery手册正则表达式部分 https://jquery.cuishifeng.cn/regexp.html\n\n菜鸟教程  https://www.runoob.com/regexp/regexp-tutorial.html\n\n菜鸟教程正则表达式在线测试  https://c.runoob.com/front-end/854/\n\nMDN  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\n\n\n\n\n\n边界符\n正则表达式中的边界符（位置符）用来提示字符所处的位置，边界符主要有以下两个\n^ 表示匹配行首的文本（以谁开始）\n$ 表示匹配行尾的文本（以谁结束）\n\n注意: 如果 ^和 $ 在一起，表示必须是”精确匹配”,表示”只能是这个字符串”\n\n\n// 含有&quot;a&quot;字符var reg1 = /a/;console.log(reg1.test(&quot;a&quot;));console.log(reg1.test(&quot;a123&quot;));console.log(reg1.test(&quot;123a&quot;));// 以&quot;a&quot;字符开头var reg2 = /^a/;console.log(reg2.test(&quot;a&quot;));console.log(reg2.test(&quot;a123&quot;));console.log(reg2.test(&quot;123a&quot;));// 以&quot;a&quot;字符结尾var reg3 = /a$/;console.log(reg3.test(&quot;a&quot;));console.log(reg3.test(&quot;a123&quot;));console.log(reg3.test(&quot;123a&quot;));// 注意: 如果 ^和 $ 在一起，表示必须是&quot;精确匹配&quot;,表示&quot;只能是这个字符串&quot;var reg4 = /^a$/;console.log(reg4.test(&quot;a&quot;));console.log(reg4.test(&quot;a123&quot;));console.log(reg4.test(&quot;123a&quot;));// 以&quot;abc&quot;开头var reg5 = /^abc/;console.log(reg5.test(&quot;abc123&quot;));console.log(reg5.test(&quot;a123bc&quot;));console.log(reg5.test(&quot;a123b456c&quot;));\n\n\n03-边界符.html \n\n字符类\n字符类表示有一系列字符(多个字符)可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号[]内。\n\n方括号 [][] 方括号,表示有一系列字符可供选择，只要匹配其中一个就可以了\n\n范围符 -[-] 方括号内部 范围符-\n方括号内部加上 - 表示范围\n可以在中括号里面加一个短横线表示一个范围 ,比如[a-z]表示a到z的26个英文字母任何一个字母,包括a和z\n\n取反符 ^[^] 方括号内部 取反符^\n\n字符组合方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以\n举例:  /[a-z1-9]/.test(&#39;andy&#39;)\n\n\n// 方括号var reg1 = /[qw]/; // 含有一个q或者一个wconsole.log(reg1.test(&quot;q&quot;));console.log(reg1.test(&quot;w&quot;));console.log(reg1.test(&quot;q123&quot;));// 范围符-var reg2 = /[a-z]/; // 含有一个a到z,包括a和z,其中一个字符console.log(reg2.test(&quot;a123&quot;));console.log(reg2.test(&quot;1b23&quot;));console.log(reg2.test(&quot;12c3&quot;));// 取反符^//  [^] 方括号内部 取反符^// var reg4 = /[abc]/; // 含有一个 a, b, c其中一个var reg4 = /[^abc]/; // 含有a,b,c之外其他的一个字符即可console.log(reg4.test(&quot;a&quot;));console.log(reg4.test(&quot;d&quot;));console.log(reg4.test(&quot;abc&quot;));console.log(reg4.test(&quot;abc1&quot;));// 字符组合var reg3 = /[0-3a-c@]/; // 含有0,1,2,3 a,b,c,@其中一个console.log(reg3.test(&quot;0&quot;));console.log(reg3.test(&quot;qw0e&quot;));console.log(reg3.test(&quot;@_@&quot;));\n\n\n04-字符类.html \n\n量词符\n量词符用来设定某个模式出现的次数。\n\n注意: 没有小括号的情况下, 量词符是修饰前一个字符出现的次数\n\n\n\n\n\n操作符\n描述\n\n\n\n*\n重复0次或更多次\n\n\n+\n重复1次或更多次\n\n\n?\n重复0次或1次\n\n\n&#123;n&#125;\n重复n次\n\n\n&#123;n,&#125;\n重复n次或更多次\n\n\n&#123;n,m&#125;\n重复n到m次\n\n\n// * 重复0次或更多次var reg2 = /^ab*$/; // *元字符此时修饰的是bconsole.log(reg2.test(&quot;123&quot;));console.log(reg2.test(&quot;a&quot;));console.log(reg2.test(&quot;abbbb&quot;));console.log(reg2.test(&quot;abbbbb&quot;));// + 重复1次或更多次var reg3 = /^ab+$/;console.log(reg3.test(&quot;123&quot;));console.log(reg3.test(&quot;a&quot;));console.log(reg3.test(&quot;abbbb&quot;));console.log(reg3.test(&quot;abbbbb&quot;));// ? 重复0次或1次var reg4 = /^ab?$/;console.log(reg4.test(&quot;123&quot;));console.log(reg4.test(&quot;a&quot;));console.log(reg4.test(&quot;abbbb&quot;));console.log(reg4.test(&quot;abbbbb&quot;));// &#123;n&#125; 重复n次var reg5 = /^ab&#123;2&#125;$/;console.log(reg5.test(&quot;123&quot;));console.log(reg5.test(&quot;a&quot;));console.log(reg5.test(&quot;abbbb&quot;));console.log(reg5.test(&quot;abbbbb&quot;));// &#123;n,&#125; 重复n次或更多次var reg6 = /^ab&#123;2,&#125;$/;console.log(reg6.test(&quot;123&quot;));console.log(reg6.test(&quot;a&quot;));console.log(reg6.test(&quot;abbbb&quot;));console.log(reg6.test(&quot;abbbbb&quot;));// &#123;n,m&#125; 重复n到m次var reg7 = /^ab&#123;2,3&#125;$/;console.log(reg7.test(&quot;123&quot;));console.log(reg7.test(&quot;a&quot;));console.log(reg7.test(&quot;abbbb&quot;));console.log(reg7.test(&quot;abbbbb&quot;));\n\n\n05-量词符.html \n\n组匹配,分组,使用()表示\n功能: 把多个原子,组在一起，成一个大原子\n\n区别:\n/^abc&#123;2&#125;$/   代表c这个字符重复2次\n/^(abc)&#123;2&#125;$/  代表abc这个整体进行重复2次\n\n\nvar reg1 = /^abc&#123;2&#125;$/;console.log(reg1.test(&quot;abc&quot;)); // falseconsole.log(reg1.test(&quot;abcc&quot;)); // trueconsole.log(reg1.test(&quot;abccc&quot;)); // falseconsole.log(reg1.test(&quot;abcabc&quot;)); // falseconsole.log(reg1.test(&quot;abcabcabc&quot;)); // falsevar reg2 = /^(abc)&#123;2&#125;$/;console.log(reg2.test(&quot;abc&quot;)); // falseconsole.log(reg2.test(&quot;abcc&quot;)); // falseconsole.log(reg2.test(&quot;abccc&quot;)); // falseconsole.log(reg2.test(&quot;abcabc&quot;)); // trueconsole.log(reg2.test(&quot;abcabcabc&quot;)); // falsevar reg3 = /^a(bc)&#123;2&#125;$/;console.log(reg3.test(&quot;abc&quot;)); // falseconsole.log(reg3.test(&quot;abcc&quot;)); // falseconsole.log(reg3.test(&quot;abccc&quot;)); // falseconsole.log(reg3.test(&quot;abcabc&quot;)); // falseconsole.log(reg3.test(&quot;abcabcabc&quot;)); // falseconsole.log(reg3.test(&quot;abcbc&quot;)); // true\n\n括号总结1.中括号  字符集合  匹配方括号中的任意字符 \n2.大括号  量词符  里面表示重复次数\n3.小括号  组匹配 可以让多个小原子组成一个大原子\n\n**在线测试正则表达式：**regexper(外国网站)  https://regexper.com/\n\n预定义类预定义类指的是某些常见模式的简写方式\n\n\n\n字符\n描述\n\n\n\n\\\n将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。\n\n\n^\n匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。\n\n\n$\n匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。\n\n\n*\n匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。\n\n\n+\n匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。\n\n\n?\n匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。\n\n\n{n}\nn是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。\n\n\n{n,}\nn是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。\n\n\n{n,m}\nm和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。\n\n\n?\n当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。\n\n\n.\n匹配除“\\n*”之外的任何单个字符。要匹配包括“\\n*”在内的任何字符，请使用像“&#96;(.\n\n\n(pattern)\n匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。\n\n\n(?:pattern)\n匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“&#96;(\n\n\n(?&#x3D;pattern)\n正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“&#96;Windows(?&#x3D;95\n\n\n(?!pattern)\n正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“&#96;Windows(?!95\n\n\n(?&lt;&#x3D;pattern)\n反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“&#96;(?&lt;&#x3D;95\n\n\n(?&lt;!pattern)\n反向否定预查，与正向否定预查类拟，只是方向相反。例如“&#96;(?&lt;!95\n\n\nx|y\n匹配x或y。例如，“&#96;z\n\n\n[xyz]\n字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。\n\n\n[^xyz]\n负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。\n\n\n[a-z]\n字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。\n\n\n[^a-z]\n负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\n\n\n\\b\n匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。\n\n\n\\B\n匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\n\n\n\\cx\n匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\n\n\n\\d\n匹配一个数字字符。等价于[0-9]。\n\n\n\\D\n匹配一个非数字字符。等价于[^0-9]。\n\n\n\\f\n匹配一个换页符。等价于\\x0c和\\cL。\n\n\n\\n\n匹配一个换行符。等价于\\x0a和\\cJ。\n\n\n\\r\n匹配一个回车符。等价于\\x0d和\\cM。\n\n\n\\s\n匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\n\n\n\\S\n匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。\n\n\n\\t\n匹配一个制表符。等价于\\x09和\\cI。\n\n\n\\v\n匹配一个垂直制表符。等价于\\x0b和\\cK。\n\n\n\\w\n匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。\n\n\n\\W\n匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。\n\n\n\\xn\n匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。.\n\n\n*num*\n匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。\n\n\n*n*\n标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。\n\n\n*nm*\n标识一个八进制转义值或一个向后引用。如果*nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm*。\n\n\n*nml*\n如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\n\n\n\\un\n匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。\n\n\n\n参考文档: https://jquery.cuishifeng.cn/regexp.html\n\n常用正则表达式\n\n\n类型\n正则\n\n\n\n用户名\n&#x2F;^[a-z0-9_-]{3,16}$&#x2F;\n\n\n密码\n&#x2F;^[a-z0-9_-]{6,18}$&#x2F;\n\n\n十六进制值\n&#x2F;^#?([a-f0-9]{6}|[a-f0-9]{3})$&#x2F;\n\n\n电子邮箱\n&#x2F;^([a-z0-9_.-]+)@([\\da-z.-]+).([a-z.]{2,6})$&#x2F; &#x2F;^[a-z\\d]+(.[a-z\\d]+)*@(\\da-z?)+(.{1,2}[a-z]+)+$&#x2F;\n\n\nURL\n&#x2F;^(https?://)?([\\da-z.-]+).([a-z.]{2,6})([/\\w .-])/?$&#x2F;\n\n\nIP 地址\n&#x2F;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)&#x2F; &#x2F;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&#x2F;\n\n\nHTML 标签\n&#x2F;^&lt;([a-z]+)([^&lt;]+)(?:&gt;(.)&lt;/\\1&gt;|\\s+/&gt;)$&#x2F;\n\n\n删除代码\\注释\n(?&lt;!http:|\\S)&#x2F;&#x2F;.*$\n\n\nUnicode编码中的汉字范围\n&#x2F;^[\\u2E80-\\u9FFF]+$&#x2F;\n\n\n正则表达式的创建\n方式一：通过调用RegExp对象的构造函数创建\nvar 变量名 &#x3D; new RegExp(“正则表达式” [,”匹配模式”] );\n\n\nvar reg1 = new RegExp(&quot;a&quot;);console.log(reg1);\n\n\n方式二：利用字面量创建(推荐) 正则表达式\nvar 变量名 &#x3D; &#x2F;正则表达式&#x2F;[匹配模式];\n\n\nvar reg2 = /a/;console.log(reg2);\n\n注意: 匹配模式可以省略不写\n匹配模式匹配模式也叫修饰符：表示正则匹配的附加规则，放在正则模式的最尾部。\n修饰符可以单个使用，也可以多个一起组合使用,  多个修饰符组合使用时,不分顺序。\n\n\n\n修饰符\n含义\n描述\n\n\n\ni\nignore - 不区分大小写\n将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。\n\n\ng\nglobal - 全局匹配\n查找所有的匹配项。\n\n\nm\nmulti line - 多行匹配\n使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。\n\n\ns\n特殊字符圆点 . 中包含换行符 \\n\n默认情况下的圆点 . 是匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。\n\n\ngi\n全局匹配 + 忽略大小写\n复合叠加\n\n\n\n如何设置给正则表达式添加匹配模式\n方式1. 字面量创建正则表达式   &#x2F;正则表达式&#x2F;匹配模式\n方式2. 构造函数RegExp创建正则表达式   new RegExp(“正则表达式”, “匹配模式”)\n\n\n\n参考文档: https://www.runoob.com/regexp/regexp-flags.html\n\n\n01-匹配模式.html \n\n正则对象相关方法正则对象.test(str): 判断字符串中是否具有指定模式的字符串，返回结果是一个布尔类型的值;\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\n\n正则对象.exec(str): 返回字符串中指定模式的子串，一次只能获取一个与之匹配的结果;\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\n\n\n格式:\n返回值 &#x3D; 正则.exec(目标字符串)\n\n功能:  匹配。在目标字符串中，找出符合正则表达式要求的字符串。\n\n返回值:如果能够匹配某个字符串，则返回值是一个数组。其中:\n第一个是匹配成功的字符串；\n第二个index，表示在哪里匹配到的。\n第三个input，表示目标字符串\n\n如果不能匹配，则返回值是null\n\n\n\n注意: 一次exec只能得到一个匹配成功的结果 ，如果要全部匹配出来，则需要调用多次exec\n\n注意: 如果要全部结果匹配出来, 全局匹配模式g不能少! 否则exec每次只能得到字符串中第一次匹配到的那个结果\n\n\nvar str = &quot;生日是:19901-10-10 生日是:1998-11-12 生日是2003-05-03 生日是3003-06-07 生日是2008-08-08&quot;;// 匹配生日字符串// var reg = /[12]\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/;var reg = /[12]\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/g;// 有一个问题，我们事先并不知道，这个匹配会成功多少次？所以我不能用for循环去执行匹配。// 可以使用while循环匹配var res;while (res = reg.exec(str)) &#123;    console.log(res);&#125;\n\nString对象跟正则相关方法\n\n\n方法\n功能\n\n\n\n字符串对象.search(reg)\n返回指定模式的子串在字符串”首次”出现的位置\n\n\n字符串对象.match(reg)\n以数组的形式返回指定模式的字符串，可以返回所有匹配的结果\t🧡\n\n\n字符串对象.replace(reg, 替换后的字符)\n把指定模式的子串进行替换操作\t🧡\n\n\n字符串对象.split(reg)\n以指定模式分割字符串，返回结果为数组\n\n\n\n字符串对象.search(reg)\n与indexOf非常类似，返回指定模式的子串在字符串”首次”出现的位置\n\nindexOf参数不建议写正则表达式  不管能否找到,都是返回-1\n\n\n\n\nvar str = &quot;生日是:19901-10-10 生日是:1998-11-12 生日是2003-05-03 生日是3003-06-07 生日是2008-08-08&quot;;var reg1 = /[12]\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/;var reg2 = /[12]\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/g;var reg3 = /\\d&#123;10&#125;/;console.log(str.search(reg1));console.log(str.indexOf(&quot;1998-11-12&quot;));// indexOf参数不建议写正则表达式  不管能否找到,都是返回-1console.log(str.indexOf(reg1));\n\n\n字符串对象.match(reg) ：以数组的形式返回指定模式的字符串，可以返回所有匹配的结果\t🧡\n\n注意: match(reg)方法如果不是全局匹配,匹配出来的效果跟正则对象的exec方法一样\nconsole.log(str.match(reg1));console.log(reg1.exec(str));console.log(str.match(reg2));console.log(str.match(reg3));\n\n\n字符串对象.replace(reg,”替换后的字符”) ：把指定模式的子串进行替换操作\t🧡字符串对象.replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。\n\nreplace()基本用法,第二个参数是字符串\n第一个参数: 被替换的字符串 或者 正则表达式\n第二个参数: 替换为的字符串\n返回值是一个替换完毕的新字符串\n\nconsole.log(str);console.log(str.replace(reg1, &quot;****-**-**&quot;));console.log(str.replace(reg2, &quot;****-**-**&quot;));console.log(str.replace(reg3, &quot;****-**-**&quot;));\n\nreplace()高级用法,第二个参数是function每次找到一次目标,就会调用一次function(){}匿名函数,把目标替换成函数中的return值;\n目标可以通过匿名函数中的arguments关键字查看\nvar result5 = str.replace(reg2, function (targetValue, targetIndex, myStr) &#123;    // console.log(&quot;arguments=&gt;&quot;, arguments);    // console.log(&quot;targetValue=&gt;&quot;, targetValue);    // console.log(&quot;targetIndex=&gt;&quot;, targetIndex);    // console.log(&quot;myStr=&gt;&quot;, myStr);    // console.log(&quot;执行了匿名函数&quot;);    var year = targetValue.substr(0, 4);    var month = targetValue.substr(5, 2);    var day = targetValue.substr(8, 2);    return month + &quot;月&quot; + day + &quot;日&quot; + year + &quot;年&quot;;&#125;);console.log(&quot;str=&gt;&quot;, str);console.log(&quot;result5=&gt;&quot;, result5);\n\n\n字符串对象.split(reg) ：以指定模式分割字符串，返回结果为数组\n\nvar str = &quot;张三-李四-王五-赵六&quot;;console.log(str.split(&quot;-&quot;));console.log(str.split(/-/));var str = &quot;张三3李四4王五5赵六&quot;;console.log(str.split(&quot;3&quot;));console.log(str.split(/\\d/));\n\n反向引用(组匹配)概念在做匹配时，如果正则表达式中有小括号，则它会把小括号中所匹配到的文本都存储在一个特殊的地方,  以备以后使用。\n这些存储在分组中的特殊值被称为反向引用。\n如何使用反向引用的结果\nRegExp构造函数的静态属性RegExp.$n 获取第n个()中匹配的内容，n是从1开始的自然数\n注意: “只有执行过正则相关方法”,才可以使用RegExp.$n的方式得到反向引用的结果\nvar str = &quot;我的生日是1999-08-07, 今年我24岁&quot;;var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;if (reg.test(str)) &#123;    console.log(RegExp.$1);    console.log(RegExp.$2);    console.log(RegExp.$3);&#125;\n\n直接在定义分组的正则表达式中包含反向引用。通过特殊的转义序列  \\1,\\2…  来调用。\t🧡var str = &quot;q7q7-a1a1-b2b2-abcd-qwer-4567-7890-f4f4-a7b8&quot;;// 目标,找到 a1a1, b2b2, f4f4 这些字符串   规律第一个字符跟第三个字符相同 第二个跟第四个字符相同var reg = /(\\w)(\\w)\\1\\2/g;console.log(str.match(reg));\n\n在匹配成功的数组中，通过下标去访问。var str = &quot;我的生日是1999-08-07, 今年我24岁; 你的生日是2002-02-14, 今年就21岁&quot;;var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g;var res;while (res = reg.exec(str)) &#123;    console.log(res);    console.log(&quot;年份=&gt;&quot;, res[1]);    console.log(&quot;月份=&gt;&quot;, res[2]);    console.log(&quot;日期=&gt;&quot;, res[3]);    console.log(&quot;&quot;);&#125;\n\n\n05-如何使用反向引用的结果.html \n\n反向引用与replace结合使用需求\n目标字符串:  “生日是:1991-10-11。生日是:1998-11-12。生日是:1990-1-10。生日是:1990&#x2F;09&#x2F;11。生日是:1980-01-13。”;\n把生日中的格式调整一下, 1990-01-31(年-月-日)  &#x3D;&#x3D;&#x3D;&gt;  31-01-1990(日-月-年)\nvar str = &quot;生日是:1991-10-11。生日是:1998/11/12。生日是:1990-1-10。生日是:1990/09/11。生日是:1980-01-13。生日是: 2022-7/14&quot;;var reg = /(\\d&#123;4&#125;)([-/])(\\d&#123;1,2&#125;)\\2(\\d&#123;2&#125;)/g;var newStr = str.replace(reg, function (result, year, $2, month, day) &#123;    console.log(arguments);    return day + &quot;-&quot; + month + &quot;-&quot; + year;&#125;);console.log(&quot;newStr=&gt;&quot;, newStr);\n\n或者的用法  用|符号表示或者的意思\n语法:\nx|y 匹配x或y\n\n例如:\nz|food  能匹配”z”或”food”\n(z|f)ood 能匹配”zood”或”food”\n\n\nvar reg1 = /^(z|food)$/;console.log(reg1.test(&quot;z&quot;)); // trueconsole.log(reg1.test(&quot;food&quot;)); // trueconsole.log(reg1.test(&quot;zood&quot;)); // falseconsole.log(&quot;&quot;);var reg2 = /^(z|f)ood$/;console.log(reg2.test(&quot;z&quot;)); // falseconsole.log(reg2.test(&quot;food&quot;)); // trueconsole.log(reg2.test(&quot;zood&quot;)); // trueconsole.log(&quot;&quot;);console.log(&quot;&quot;);var str = &quot;ipad,iphone,imac,ipod,iamsorry,iwatch&quot;;// 找到所有苹果产品// var reg = /ipad|iphone|imac|ipod|iwatch/g;var reg = /i(pad|phone|mac|pod|watch)/g;console.log(str.match(reg));\n\n转义字符因为在正则表达式中 . +  * ? 等是属于正则表达式的一部分，但是我们在匹配时，字符串中也需要匹配这些特殊字符，所以，我们必须使用  反斜杠\\  对某些特殊字符进行转义；\n\n需要转义的字符：\n点号.\n小括号()\n中括号[]\n左斜杠 &#x2F;\n右斜杠\\\n选择匹配符 |\n…\n\n\nvar str = &quot;英短原产于[英国],它是一个动物(猫)&quot;;// 目标:  从str字符串中找到 &quot;[英国]&quot; 和 &quot;(猫)&quot;var reg = /\\[英国\\]|\\(猫\\)/g;console.log(str.match(reg));\n\n取消反向引用(非捕获组)介绍：(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。\n概念：非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成&#x2F;(foo){1, 2}&#x2F;，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为&#x2F;(?:foo){1, 2}&#x2F;，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。\n引用分组会需要额外的空间存储。当我们只是需要分组(把小原子组成大原子)而不需要引用时，就可以手动取消这个引用。\n原子就是单个字符  比如  &#x2F;abc{2}&#x2F; &#x3D;&gt;  &#x2F;(abc){2}&#x2F;\n做法是: 在()里面的前面加一个 ?: 即可\nvar str = &quot;abcabcabcc123456abcd&quot;;// var reg = /abc&#123;2&#125;/g;var reg = /(?:abc)&#123;2&#125;/g;var res;while (res = reg.exec(str)) &#123;    console.log(res);&#125;\n\n贪婪匹配与惰性匹配我们会发现以上代码运行结果中，默认优先配到 13 位，在对后面的进行匹配；为什么不是优先匹配 5 位后，在对后面的进行匹配呢？\n因为在正则表达式中，默认情况下，能匹配多的就不匹配少的，我们把这种匹配模式就称之为 贪婪匹配,也叫做 贪婪模式所有的正则表达式，默认情况下采用的都是贪婪匹配原则。\n如果在量词符的后面添加一个问号?  那我们的贪婪匹配原则就会转化为非贪婪匹配原则，优先匹配少的，也叫惰性匹配;\nvar str = &quot;我的QQ20869921366666666666,nsd你的是6726832618吗?&quot;;// var reg = /[1-9]\\d&#123;4,12&#125;/g;var reg = /[1-9]\\d&#123;4,12&#125;?/g;console.log(str.match(reg));\n\n\n\n函数的防抖,节流\n介绍函数防抖中的抖动就是执行的意思，而一般的抖动都是持续的、多次的、频繁的执行某一段代码。函数防抖就是某函数持续多次执行，我们希望让它冷静下来再执行。也就是当持续触发事件的时候，函数是完全不执行的，等最后一次触发结束的一段时间之后，再去执行。在前端开发中经常会遇到这种频繁的事件触发，比如：window 的 onresize、onscrollonmousemoveonkeyup、onkeydown 、oninput等等……\nwindow.onresize = function () &#123;    console.log(&quot;浏览器可视区域发生改变&quot;);&#125;window.onscroll = function () &#123;    console.log(&quot;页面滚动中..&quot;);&#125;\n\n\n01-函数的防抖介绍.html \n\n\n为什么需要防抖,节流这种频繁的事件触发不做限制的话，有可能一秒之内执行几十次、几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作 DOM 的函数（浏\n览器操作 DOM 是很耗费性能的），那不仅会浪费计算机资源，还会降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。\n除此之外，短时间内重复的 ajax 调用不仅会造成数据关系的混乱，还会造成网络拥塞，增加服务器压力，显然这个问题也是需要解决的。\n函数防抖和节流，都是控制事件触发频率的方法。\n\n02-观察以下示例代码来了解事件如何频繁的触发.html \n\n\n区别函数防抖, 事件尽管触发, 需要停止触发事件以后 ,再等上一个指定时间以后, 才会执行指定代码\n函数节流, 指定时间内,只能触发一次事件\n\n防抖,节流体验Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。\nlodash中文文档 https://www.lodashjs.com/\n\n使用Lodash.js库debounce方法体验什么是函数防抖\nlodash的_.debounce()方法\n**参考文档：**https://www.lodashjs.com/docs/lodash.debounce\n\n使用Lodash.js库throttle方法体验什么是函数节流\nlodash的_.throttle()方法\n参考文档: https://www.lodashjs.com/docs/lodash.throttle\n\n\n\nbootcdn网址(可以通过这个网站在线引入第三方库)  https://www.bootcdn.cn/\n\n\n函数的防抖\n概念其中防抖的原理就是：事件尽管触发，但是在事件触发 n 秒后才执行，如果你在一个事件触发的 n \n秒内又触发相同事件，那我就以新的事件 n 秒后才执行，舍弃掉上一次事件触发执行操作。简单地说就是频繁的触发事件完毕后的 n 秒内不再触发同\n一事件，函数才会执行。\n\n生活中例子生活中例子1:    一群人排队上公交车, 公交车司机, 直到最后一个人上了车以后,再关车门\n生活中例子2:    坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此，“函数防抖”的关键在于，在 一个事件 发生 一定时间 之后，才执行 特定动作。\n生活中例子3:  王者荣耀或者英雄游戏中, 多次按回城按钮,只有按了以后,停下来一段时间才会回城\n\n函数防抖的使用场景函数防抖一般用在什么情况之下呢？一般用在，连续的事件只需触发一次回调的场合。具体有：\n\n搜索框搜索输入。只需用户最后一次输入完，再发送请求；\n用户名、手机号、邮箱输入验证；\n浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染。\n懒加载、滚动加载、加载更多或监听滚动条位置；\n百度搜索框，搜索联想功能；\n防止高频点击提交，防止表单重复提交；\n\n\n函数节流的实现\n\nfunction mydebounce(func, wait) &#123;    // 延时器标识符    var timeoutId = null;    // 使用一个变量,保存this上下文的对象    var context = null;    // 使用一个变量,保存实参列表    var args = null;    // 返回一个新函数    return function () &#123;        // 把正确的this对象赋值给context变量        context = this;        // 把正确的arguments对象赋值给args变量        args = arguments;        console.log(arguments);        // 清除上一个延时器        window.clearTimeout(timeoutId);        // 开启一个延时器        timeoutId = window.setTimeout(function () &#123;            // 改变func函数内部this指向,并且传递参数            func.apply(context, args);        &#125;, wait);    &#125;&#125;// 获取dom对象var container = document.getElementById(&quot;container&quot;);// 定义一个变量,保存次数var count = 0;// 封装一个函数function fn(e) &#123;    // console.log(&quot;fn函数被调用了&quot;);    console.log(&quot;this对象=&gt;&quot;, this);    console.log(&quot;e事件对象=&gt;&quot;, e);    console.log(&quot;&quot;);    // // 自加1    count++;    // // 设置container标签内容    this.innerText = &quot;触发了&quot; + count + &quot;次事件,当前鼠标在盒子内坐标为&quot; + e.offsetX + &quot;,&quot; + e.offsetY;&#125;// 给container对象绑定鼠标移动事件// 使用自己封装的防抖动函数container.onmousemove = mydebounce(fn, 400);var objInput = document.querySelector(&quot;input&quot;);objInput.onkeyup = mydebounce(function (e) &#123;    console.log(&quot;this对象=&gt;&quot;, this);    console.log(&quot;e事件对象=&gt;&quot;, e);    console.log(&quot;e.key=&gt;&quot;, e.key);    console.log(this.value);&#125;, 400);\n\n函数的节流\n概念规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n\n生活中例子举个栗子，坐火车或地铁或高铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过，分析可知，“函数节流”的要点在于，在 一定时间 之内，限制 一个动作 只 执行一次 。\n再举个栗子， 王者荣耀某个英雄释放技能以后,该技能进入冷却,等该技能冷却结束以后才能再次释放技能\n\n函数节流的使用场景\nDOM元素的拖拽功能实现\n射击游戏\n计算鼠标移动的距离\n监听scroll滚动事件\n\n\n函数节流的实现在函数的节流中首次触发是否执行以及结束后是否执行，不同需求，实现的方式也有所不同。目前实现函数节流有两种主流方式：\n\n使用时间戳(从1970年1月1日0时0分0秒到现在的毫秒数)\n设置延时器(setTimeout)。\n\n我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。\n\n使用时间戳完成节流函数的第一版本**原理：**当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期(时间间隔)，就执行函数，并更新时间戳为当前的时间戳，如果小于，就不执行。**目标：**第一次触发,最后不会被调用触发函数\n\n\nfunction mythrottle1(func, wait) &#123;    // 之前的时间戳    var old = 0;    // 定义一个变量保存this对象    var context = null;    // 定义一个变量保存实参列表    var args = null;    // 返回一个新函数    return function () &#123;        // 保存this对象        context = this;        // 保存arguments对象        args = arguments;        // 获取当前最近的时间戳        var now = new Date().getTime();        // 如果大于设置的时间周期(时间间隔)，就执行函数，如果小于，就不执行。        if (now - old &gt; wait) &#123;            // 修改函数内部this指向,并传递参数            func.apply(context, args);            // 并更新时间戳为当前的时间戳            old = now;        &#125;    &#125;&#125;\n\n\n使用延时器完成节流函数的第二版本**原理：**当触发事件的时候，设置一个延时器，再触发事件的时候，如果延时器存在，就不执行，直到延时器执行完毕，然后执行函数，清空延时器，再设置下个延时器。**目标：**实现第二个版本  第一次不触发,最后一次触发\n\nfunction mythrottle2(func, wait) &#123;    // 定义一个变量保存this对象    var context = null;    // 定义一个变量保存实参列表    var args = null;    // 延时器标识符    var timeoutId = null;    // 返回一个新函数    return function () &#123;        // 保存this对象        context = this;        // 保存arguments对象        args = arguments;        // 判断延时器是否存在        if (timeoutId === null) &#123; // 如果不延时器存在            // 开启延时器            timeoutId = window.setTimeout(function () &#123;                // 改变函数内部this指向以及传递参数                func.apply(context, args);                // 执行完毕函数以后, 重新给timeoutId标识符赋值为null                timeoutId = null;            &#125;, wait);        &#125;    &#125;&#125;\n\n\n使用时间戳和延时器双剑合璧完成节流函数的第三版本**目标：**使用时间戳和延时器双剑合璧完成节流函数的第三个版本  第一次触发,最后一次也触发\n\nfunction mythrottle3(func, wait) &#123;    // 之前的时间戳    var old = 0;    // 定义一个变量保存this对象    var context = null;    // 定义一个变量保存实参列表    var args = null;    // 延时器标识符    var timeoutId = null;    // 返回一个新函数    return function () &#123;        // 保存this对象        context = this;        // 保存arguments对象        args = arguments;        // 获取当前最近的时间戳        var now = new Date().getTime();        // 如果大于设置的时间周期(时间间隔)，就执行函数，如果小于，就不执行。        if (now - old &gt; wait) &#123;            // 修改函数内部this指向,并传递参数            func.apply(context, args)            // 并更新时间戳为当前的时间戳            old = now;            // 如果此时有延时器存在,则清除延时器,并且设置延时器变量timeout值恢复为null            if (timeoutId) &#123;                clearTimeout(timeoutId);                timeoutId = null;            &#125;        &#125;        // 判断延时器是否存在        if (timeoutId === null) &#123; // 如果不延时器存在            // 开启延时器            timeoutId = window.setTimeout(function () &#123;                // 改变函数内部this指向以及传递参数                func.apply(context, args);                // 执行完毕函数以后, 重新给timeoutId标识符赋值为null                timeoutId = null;                // 更新时间戳                // 重新获取现在最新的时间戳                now = new Date().getTime();                // 把now的值赋给old, 更新old的值                old = now;            &#125;, wait);        &#125;    &#125;&#125;function mythrottle(func, wait, options) &#123;    // 判断options是否为undefined    if (options === undefined || (options.leading &amp;&amp; options.trailing)) &#123;        return mythrottle3(func, wait);    &#125;    if (options.leading === true &amp;&amp; options.trailing === false) &#123;        return mythrottle1(func, wait);    &#125;    if (options.leading === false &amp;&amp; options.trailing === true) &#123;        return mythrottle2(func, wait);    &#125;&#125;\n\nAjaxAjax概述Ajax：标准读音 [ˈeɪˌdʒæks] ，中文音译：阿贾克斯\n它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。\nAjax我们需要学习的是如何拿到服务器端地址的数据,并前端进行渲染\n\n参考文档: JS Ajax请求（简明教程） (biancheng.net)\n\najax对象.readyState ajax的状态码\n\n\n值\n状态\n描述\n\n\n\n0\nUNSENT\n代理被创建，但尚未调用 open() 方法。\n\n\n1\nOPENED\nopen() 方法已经被调用。\n\n\n2\nHEADERS_RECEIVED\nsend() 方法已经被调用，并且头部和状态已经可获得。\n\n\n3\nLOADING\n下载中；responseText 属性已经包含部分数据。\n\n\n4\nDONE\n下载操作已完成。\n\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\n\najax对象.status 请求的响应状态常用状态码 200请求成功 404请求地址有问题,找不到资源 403拒绝访问 500服务器错误\n\n网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。可以判断服务器端返回的状态码，分别进行处理。\n\n网络畅通，服务器端没有接收到请求，返回  404 状态码。检查请求地址是否错误。\n\n网络畅通，服务器端能接收到请求，服务器端返回 500 状态码。服务器端错误，找后端程序员进行沟通。\n\n服务器端成功处理了请求，服务器端返回 200 状态码。在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。当 readyState 等于 4 且状态为 200 时，表示响应已就绪\n\nBad Request 客户端请求的语法错误，服务器无法理解   返回400状态码\n\n网络中断，请求无法发送到服务器端。会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。\n\n\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\nAjax的实现步骤XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。\nconsole.log(&quot;XMLHttpRequest=&gt;&quot;, XMLHttpRequest);\n\n第一步: 创建ajax对象, 通过XMLHttpRequest()构造函数\nvar xhr = new XMLHttpRequest();\n\n第二步: 使用ajax对象初始化一个请求  通过XMLHttpRequest对象.open( method要使用的 HTTP 方法, url请求地址, async表示是否异步执行操作默认true表示异步操作 )method参数取值主要是GET和POST 这两个请求方式\nxhr.open(&quot;GET&quot;, &quot;https://v2.alapi.cn/api/dog?token=lJLxHK2NrnPVri457AaK&quot;);\n\n第三步: 发送请求  通过 XMLHttpRequest对象.send()如果是GET请求方式, send()方法中不需要写参数;如果是POST请求方式, send()方法中可能需要写请求参数;\nxhr.send();\n\n第四步: 处理响应结果当 ajax对象的readyState 属性发生变化时,就会触发readystatechange事件\nxhr.onreadystatechange = function () &#123;    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;        // xhr.responseText表示ajax对象获取服务器返回的文本值        console.log(&quot;xhr.responseText=&gt;&quot;, xhr.responseText);        // 把json字符串转成json对象  JSON.parse(json字符串)        var res = JSON.parse(xhr.responseText)        console.log(&quot;res=&gt;&quot;, res);        console.log(&quot;res.data.content=&gt;&quot;, res.data.content);        // 设置p段落标签内容        objP.innerText = res.data.content;    &#125;&#125;\n\n注意: 默认ajax请求的时候,如果直接使用file协议访问会报错  需要使用http协议或者https协议访问   vscode可以安装live server插件\n但是, 访问远程某个网址(api接口),如果api接口开启了CORS(跨域资源共享), 我们就可以直接使用file:&#x2F;&#x2F;&#x2F;协议浏览页面,测试效果\nalapi网站：https://www.alapi.cn/\n参考文档: https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\n\n12-Ajax的实现步骤.html \n\nget请求和post请求的区别\n我们大概要记住以下几点：\n浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】\nget请求会被浏览器主动缓存，而post不会。【重要】\nget请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。\nget请求在url中传递的参数有大小限制，基本是2kb&#96;，不同的浏览器略有不同。而 post 没有注意。\nget的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。\n\n\nGET与POST的区别？\nget是从服务器上获取数据，post是向服务器推送数据。  \nget是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。\n对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。\nget传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。\nget执行效率却比post方法好。\n\n\n\n面试题:  https://interview.html5.wiki/compound.html#_5-get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB\nURL介绍统一资源定位符(Uniform Resource Locaotr,URL) 是互联网上标准资源的地址. 互联网上的每个文件都有一个唯一的URL,它包含的信息指出文件的位置以及浏览器应该怎么处理它.\nurl可以简单理解为是某个网址\n\n\n\nURL的一般语法格式：\nprotocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment\n\n\n\n比如:\nhttps://www.mi.com/shop/buy/detail?product_id=10000203&amp;selected=10000203#bottom\n\n\n一个URL由以下几部分组成:\n\n\n\n组成\n说明\n\n\n\nprotocol\n通信协议，常见的有http:&#x2F;&#x2F;、https:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;等\n\n\nhost\n主机（域名），比如: www.mi.com\n\n\nport\n端口号，可选，省略时会使用默认端口，比如http协议默认端口为80；https协议默认端口为443\n\n\npath\n路径，由零个或者多个”&#x2F;“符号隔开的字符串，一般用来表示主机上的一个目录或者文件地址，比如”&#x2F;shop&#x2F;buy&#x2F;detail”\n\n\nquery\n参数，以键值对的形式通过&amp;符号分隔开，GET请求提交数据就是这种方式\n\n\nfragment\n片段，#后面的内容，常见于链接的锚点\n\n\nget 请求方式传参get方式传递参数是通过url拼接字符串的形式\n语法如下\nurl?键名1&#x3D;键值1&amp;键值2&#x3D;键值2…\n// 获取文本框输入的关键字var keyword = objInput.value;// 发送ajax请求// 创建ajax对象var xhr = new XMLHttpRequest();// 初始化请求xhr.open(&quot;GET&quot;, &quot;https://v2.alapi.cn/api/idiom?token=lJLxHK2NrnPVri457AaK&amp;word=&quot; + keyword);// 发送请求xhr.send();// 监听ajax状态码的变化xhr.onreadystatechange = function () &#123;    // ajax状态为4 并且 http响应状态码为200    if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;        // 获取服务器响应的文本内容数据        // console.log(xhr.responseText);        // 把json字符串转成json对象        var res = JSON.parse(xhr.responseText);        console.log(res);        // 获取目标数据        var data = res.data;        // 渲染数据        if (data !== null) &#123;            objUl.innerHTML = data.map(function (item) &#123;                return &quot;&lt;li&gt;&lt;h2&gt;&quot; + item.word + &quot;&lt;/h2&gt;&lt;p&gt;&quot; + item.explanation + &quot;&lt;/p&gt;&lt;/li&gt;&quot;;            &#125;).join(&quot;&quot;);        &#125;    &#125;&#125;\n\n\n[03-GET 请求方式传参.html](....\\web\\每日代码\\35_Ajax\\03-GET 请求方式传参.html) \n\nPOST 请求方式传参POST 请求方式传参方式一传统表单传值方式 常用   数据通过send方法发送,并且在发送请求之前, 需要设置请求头\npost传统表单传值方式传参需要先设置请求头  告诉服务器端当前请求参数的格式是为传统表单传值方式\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);\n传统表单传值方式  “name&#x3D;zhangsan&amp;age&#x3D;20&amp;sex&#x3D;男”\n传统表单参数字符串  格式 键名1&#x3D;键值1&amp;键名2&#x3D;键值2…\n方式一: 直接字符串拼接\nvar paramStr = &quot;token=lJLxHK2NrnPVri457AaK&amp;keyword=&quot; + keywordVal + &quot;&amp;page=&quot; + pageSizeVal + &quot;&amp;type=&quot; + biaoqingTypeVal;\n\n方式二: 创建一个js对象,保存要传递的参数\nvar paramData = &#123;    token: token,    keyword: keywordVal,    page: pageSizeVal,    type: biaoqingTypeVal&#125;// console.log(&quot;paramData=&gt;&quot;, paramData);// 定义一个空字符串var paramStr2 = &quot;&quot;;// for...in遍历paramData对象for (var attr in paramData) &#123;    paramStr2 = paramStr2 + attr + &quot;=&quot; + paramData[attr] + &quot;&amp;&quot;;&#125;paramStr2 = paramStr2.slice(0, -1);\n\nPOST传递参数,还需要在请求发送之前,设置请求头\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);\n\nPOST传递参数是通过send()方法  在send()方法里面放传统表单参数字符串\n//xhr.send(paramStr);xhr.send(paramStr2);\n\n\n[04-POST 请求方式传参方式一.html](....\\web\\每日代码\\35_Ajax\\04-POST 请求方式传参方式一.html) \n\nPOST 请求方式传参方式二传递json格式字符串 不常用   数据通过send方法发送,并且需要设置请求头\npost传json格式字符串参数需要先设置请求头 在请求头中指定 Content-Type 属性的值是 application&#x2F;json，告诉服务器端当前请求参数的格式是 json。\nxhr.setRequestHeader(“Content-Type”, “application&#x2F;json”);\nvar paramData = &#123;&#125;; // 空对象// 添加属性paramData.token = token;paramData.page = pageSizeVal;paramData.keyword = keywordVal;paramData.type = biaoqingTypeVal;// 通过 JSON.stringify( json对象 )  就可以把json对象转换成JSON字符串// POST传递参数,需要发送请求之前设置对应的请求头xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);// 发送请求xhr.send(JSON.stringify(paramData));\n\n\n[05-POST 请求方式传参方式二.html](....\\web\\每日代码\\35_Ajax\\05-POST 请求方式传参方式二.html) \n\n请求报文在 HTTP 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式。\n报文分为报文头和报文体\n报文头中存储的是一些键值对信息,可以理解为客户端向服务器说的一些话,比如\n设置请求头\nxhr.setRequestHeader(“Content-Type”, “application&#x2F;x-www-form-urlencoded”);\n报文体主要存储一些内容,比如POST请求的参数,就是存储在报文体中\n报文头和报文体在请求的过程中, 整体被发送到服务器当中\n参考文章: https://www.cnblogs.com/myseries/p/11239662.html\n跨域问题不是所有的接口地址都是可以直接请求的  有些接口只允许特定的ip或者域名访问  也就是有所限制\nwindow.open( url ) 该方法可以在新窗口打开指定url的网页\n注意: 以上接口,用浏览器直接访问没有问题, 但是使用ajax请求的时候, 即使我们浏览页面的时候,使用了live server浏览器,还是会出现如下错误:\n要解释以及解决以上问题,我们需要先学习同源政策\n同源政策\nAjax请求限制Ajax 默认只能向自己的服务器发送请求。\n比如现在有一个A网站、有一个B网站，A网站中的 HTML 文件只能向A网站服务器中发送 Ajax 请求，B网站中的 HTML 文件只能向 B 网站中发送 Ajax 请求，但是 A 网站是不能向 B 网站发送 Ajax请求的，同理，B 网站也不能向 A 网站发送 Ajax请求。\n\n什么是同源如果两个页面拥有相同的协议、相同的域名和相同的端口，那么这两个页面就属于同一个源，同一个源就不会有跨域问题,  但是协议、域名和端口其中只要有一个不相同，就是不同源,那就是跨域。\nhttp:&#x2F;&#x2F;协议的默认端口号是80\nhttps:&#x2F;&#x2F;协议的默认端口号是443\n\n\n例：\n\n\n\nURL\n同源性\n\n\n\nhttp://www.example.com/dir/page.html\n同源\n\n\nhttp://www.example.com/dir2/other.html\n同源\n\n\nhttp://example.com/dir/other.html\n不同源（域名不同）\n\n\nhttp://v2.www.example.com/dir/other.html\n不同源（域名不同）\n\n\nhttp://www.example.com:81/dir/other.html\n不同源（端口不同）\n\n\nhttps://www.example.com/dir/page.html\n不同源（协议不同）\n\n\n\n同源政策的目的同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。\n随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。\n\n\n最常见的六种跨域解决方案:  https://blog.csdn.net/m0_37873510/article/details/126558023\nJSONP方式解决跨域\njsonp 是 json with padding 的缩写，它不属于 Ajax 请求，但它可以模拟 Ajax 请求。  JSONP只能模拟”get请求”\n\nJSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。”解决跨域问题的一种技术,一种方案”\n\nJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的”数据交换格式”。\n\njsonp的原理就是利用了script标签不受浏览器同源策略的限制，然后和后端一起配合来解决跨域问题的。\n\n注意: jsonp可以解决部分接口跨域问题,  不是所有的接口都可以使用jsonp技术解决,  取决后端\n\nJSONP的实现步骤\n将不同源的服务器端请求地址写在 script 标签的 src 属性中, 并传递callback参数与函数名\n\n**注意：**callback参数名称不是固定为callback,只是一般情况下为callback这个名字\n\n服务器端响应jsonp需要的数据\n\n**注意：**此步骤需要服务器端完成\n\n在客户端全局作用域下定义函数 fn, 并在 fn 函数内部对服务器端返回的数据进行处理\n\n**注意：**fn函数的定义需要放在全局作用域下\n\n\n&lt;script&gt;    function fn(data) &#123;        console.log(&quot;我是fn函数&quot;);        console.log(&quot;arguments=&gt;&quot;, arguments);        // data就是服务器响应的jsonp数据        console.log(&quot;data=&gt;&quot;, data);    &#125;&lt;/script&gt;&lt;script src=&quot;https://api.asilu.com/phone?phone=13123456789&amp;callback=fn&quot;&gt;&lt;/script&gt;\n\n封装jsonp函数function jsonp(options) &#123;    // 判断options中的callbackName属性值是否为undefined    if (options.callbackName === undefined) &#123;        options.callbackName = &quot;callback&quot;;    &#125;    // 创建script标签    var newScript = document.createElement(&quot;script&quot;);    // 参数字符串    var paramStr = &quot;&quot;;    // for..in遍历options.data    for (var attr in options.data) &#123;        // 拼接字符串        paramStr = paramStr + &quot;&amp;&quot; + attr + &quot;=&quot; + options.data[attr];    &#125;    // 随机函数名    var randomFunName = &quot;myjsonp&quot; + Math.random().toString(16).substr(2);    // 所有全局作用域下定义的变量会成为window对象的属性    // 所有全局作用域下定义的函数会成为window对象的方法    window[randomFunName] = options.success;    // 设置src属性    newScript.src = options.url + &quot;?&quot; + options.callbackName + &quot;=&quot; + randomFunName + paramStr;    // 添加到body中    document.body.appendChild(newScript);    // 当script标签加载完毕以后,删除这个script标签    newScript.onload = function () &#123;        this.remove();    &#125;&#125;\n\n\n\n\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"RedmiNote12Turbo 个人玩机优化记录(祭奠澎湃牢米)","url":"/2025/08/27/redmi-note12-turbo-root-%E6%95%99%E7%A8%8B/","content":"系统个人用的是EU版的系统，一直开VPN+全天息屏的话，日用续航显示大概4小时左右，EU版官方网站👉 Unofficial Xiaomi European Community\nEU版的系统一般都是把国行版的系统进行清理优化做出来的包，最主要的就是把国行版系统内置的广告都给清理干净了，相比于国际版仅保留了基础的谷歌服务。\nRedmiNote12Turbo 国际版机型叫做 POCO F5，所以EU版的包刷入完成后手机机型就会变成POCO F5\n优点：\n\n系统无广告\n没有云控，刷完包机型也变更为了国际版的命名\n增加了老大哥窃取你隐私的麻烦程度，隐私性比国内版的强\n\n缺点：\n\n原内核非常耗电，重新刷个内核会好点（个人刷的是KSU内核，更换后有了动态刷新率，可以以1帧来进行息屏显示，延长了续航时间。）\n国内版特有的某些功能有所缺失\n\n\n\t\n\t\n\n\n主题主题：miku主题\n模块作者：poi盛夏阳光 | 爱发电\n其实原先模块是免费的，但是因为倒狗的缘故，作者后面就改为赞助获取了，虽然本人用的是收费前的免费版本，但还是不放链接了。\n\n开机动画：BA的游戏开发部\n模块相信我，一定要先刷救砖模块再刷入其他模块😎\nXposed模块仓库官网： Browse Modules - Xposed Module Repository\n面具模块主要来源都是酷安\n音效：哈曼卡顿模块\n震动：MIUI震感增强\n相机：徕卡相机 || 谷歌相机\n软件只要是最新版本 Google，直接去设置里开启 Gemini 就行了，而且是国际版MIUI是系统原生支持全局快捷调用 Gemini 的。\nGoogle的Gemini，那水平比国内厂商手机内置的大模型不知道高到哪里去了。不该问的都可以问，不该知道的都可以知道😋\n\n\n传送门？下载全局复制: Universal Copy\n划圈搜索？直接在 MIUI 启用谷歌的划圈搜索: parallelcc&#x2F;MiCTS\n游戏玩烤，不开高画质3DMV的话无压力全程120帧，高画质3DMV的话帧率则不能全程稳定120帧。室温30度，CPU、GPU全程跑满不降频。基本算是把芯片性能压榨完了。\n\n","categories":["玩机"],"tags":["玩机","教程"]},{"title":"划词翻译样式分享","url":"/2025/05/18/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/","content":"浏览器插件：划词翻译\n个人自用样式分享\n:root &#123;  --background-img: url(&quot;https://s2.loli.net/2023/12/30/3FovXfsi1JA29rS.jpg&quot;);  --textarea-background-color: linear-gradient(    to bottom,    rgba(76, 108, 179, 0.6),    rgba(57, 197, 187, 0.6) 150%  );  --textarea-color: #ebe1a9;&#125;/* 网页划词隐藏输入框 */#app #popper-container .query-text &#123;  display: none;&#125;#translate-panel,.bp5-dark #translate-panel &#123;  border-radius: 10px;  font-size: 15px !important;  font-family: &quot;萝莉体 第二版&quot; !important;  h6.bp5-heading &#123;    font-size: 15px !important;    color: #fff;  &#125;  /* 输入框背景 */  textarea.bp5-input &#123;    background: var(--textarea-background-color) !important;    font-family: &quot;萝莉体 第二版&quot; !important;    color: var(--textarea-color);  &#125;  textarea.bp5-input:focus &#123;    box-shadow: inset 0 0 0 1px #39c5bb, inset 0 0 0 1px #39c5bb,      0 0 0 2px rgba(244, 179, 194, 0.3);  &#125;  textarea.bp5-input::-webkit-input-placeholder &#123;    color: #5a79ba;  &#125;  /* 翻译框 */  .bp5-card &#123;    background: linear-gradient(      to right bottom,      rgba(153, 94, 137, 0.7),      rgba(0, 148, 200, 0.7) 150%    ) !important;  &#125;  /* 输入框 */  .query-text textarea.bp5-input &#123;    min-height: 80px;  &#125;  .query-text .clear-btn .bp5-icon-cross &#123;    color: skyblue;  &#125;  /* 滚动条 */  .body &#123;    overflow-x: hidden;  &#125;  .body::-webkit-scrollbar-thumb &#123;    background: linear-gradient(      to bottom,      rgba(57, 197, 187, 0.7),      rgba(0, 148, 200, 0.7) 150%    ) !important;  &#125;  /* 词性&amp;来源 */  .result-block &#123;    color: #f3f3f3 !important;    .lang-select.bp5-popover-target &#123;      white-space: nowrap;    &#125;  &#125;  .result-block .dict-pos &#123;    margin-right: 5px;    color: #f08300;  &#125;  .bp5-button .bp5-icon,  .bp5-button .bp5-icon-large,  .bp5-button .bp5-icon-standard &#123;    color: #1e50a2;  &#125;&#125;#translate-panel &#123;  /* 浅色模式下的面板样式 */  background: linear-gradient(to right bottom, pink, skyblue);  background: var(    --background-img,    url(&quot;https://s2.loli.net/2023/12/30/3FovXfsi1JA29rS.jpg&quot;)  ) !important;  background-repeat: no-repeat !important;  background-position: top center !important;  background-size: cover !important;&#125;.bp5-dark #translate-panel &#123;  /* 深色模式下的面板样式 */  background: linear-gradient(to right bottom, pink, skyblue);  background: var(    --background-img,    url(&quot;https://s2.loli.net/2023/12/30/3FovXfsi1JA29rS.jpg&quot;)  ) !important;  background-repeat: no-repeat !important;  background-position: top center !important;  background-size: cover !important;&#125;/*自动折行*/#translate-panel &#123;  .bp5-elevation-0 &#123;    margin: 0;  &#125;  .body &#123;    display: flex;    flex-wrap: wrap;    column-gap: 10px;    row-gap: 10px;  &#125;  .result-block &#123;    min-width: 220px;    min-height: 45px;    flex: 1;  &#125;  .external-translators &#123;    margin-top: 5px;    display: flex;    width: 100%;    justify-content: center;    gap: 10px;    &gt; * &#123;      margin:0;    &#125;  &#125;    .quick-links &#123;    display: flex;    width: 100%;    justify-content: center;  &#125;&#125;\n\n","categories":["编程"],"tags":["分享"]},{"title":"jQuery 学习笔记","url":"/2023/07/06/jQuery/","content":"第三方库介绍\n什么是第三方库？前端的第三方库往往是用JS语言封装好的一些工具，提供一些API供开发者使用，以提升开发效率一个完整的中型项目中，往往会直接或间接的依赖上千个第三方库\n\n为什么要学习第三方库？提升开发效率\n降低开发难度\n面试中会通过第三方库的熟悉程度考察项目经验\n\n第三方库要学习到什么程度？某些第三方库需要单独作为课程学习，比如jQuery、Bootstrap等大型第三方库\n某些第三方库需要在学习其他工具、框架时融合的学习，比如webpack、node、vue、react中涉及的大量第三方库\n某些第三方库需要在项目实战开发中边学边练，比如validator、md5、jsonwebtoken等\n你需要对大部分第三方库有原理层面的认识\n你需要对一些第三方库有源码层面的认识\n\n前端有哪些常用的第三方库？下面列出前端开发中常用的第三方库\njQuery：传统的dom处理解决方案\nLodash：前端实用函数工具箱\nMockJS：数据模拟\nBootStrap：快速中后台UI库（可部分用于前台）\nmoment：时间、日期处理\ndate-fns：时间、日期处理\nvalidator：数据验证\nasync-validator：异步数据验证\naxios：跨平台的远程通信\numi-request：跨平台的远程通信，并可以跟umi更好的融合\nbabel：支持JS Next，并对其做兼容处理\npostCSS：支持css Next，并对其做兼容处理\nejs：模板引擎\nwebpack：基于模块化的构建工具\nwebpack家族中涉及成百上千的第三方库，其中常用的20个以上\nvue：JavaScript框架\nvue全家桶中涉及十来个常用第三方库，用于解决项目中的常见问题\nreact：降低前端UI复杂度的库\nreact全家桶中涉及大大小小几十个第三方库，用于解决项目中的常见问题\nnode：前端的服务器环境\nnode中涉及大量的第三方库，用于解决服务器中的常见问题\n……\n\n\njQuery介绍jQuery: 一个js类库作用: 简化原生DOM操作，提供很多工具方法\n\nJavaScript库(第三方库)仓库： 可以把很多东西放到这个仓库里面。找东西只需要到仓库里面查找到就可以了。\nJavaScript库：  即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。\n比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。\n\njQuery的概念jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。\nj 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。\njQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。\n学习jQuery本质： 就是学习调用这些函数（方法）\njQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。\n\njQuery的优点\n轻量级。核心文件才几十kb，不会影响页面加载速度。\n跨浏览器兼容，基本兼容了现在主流的浏览器。\n链式编程、隐式迭代。\n对事件、样式、动画支持，大大简化了DOM操作。\n支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。\n免费、开源。\n\n\n\njQuery的基本使用引入本地jQuery库 也就是把jQuery.js文件下载到本地电脑中\n&lt;script src=&quot;./js/jquery-3.6.3.min.js&quot;&gt;&lt;/script&gt;\n\n\n引入在线的jQuery库 一般某些网站提供的jQuery库\nbootcdn网 https://www.bootcdn.cn/\nstaticfileCDN网 https://staticfile.org/\n\n\n&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.3/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n\njQuery(javascript Query) 理念:  写得更少,做的更多\n\nx.x开头的版本兼容IE浏览器\n\nx.x和3.x.x就不兼容IE浏览器\n\n\n\n下载jQuery,从官网下载即可\n官网:  https://jquery.com/\n\n成功引入jQuery以后,全局会多出一个$, 这个$等同于jQuery  使用$更多,因为$更简单\n\n\nconsole.log($);console.log(jQuery);console.log($ === jQuery);console.log(window.$);console.log(window.jQuery);console.log(window.$ === window.jQuery);\n\n\n$(“带符号的css选择器”)就可以获取jQuery对象, jQuery对象才可以使用jQuery库提供的api\n\n$(&quot;.div1&quot;).click(function () &#123;    console.log(111);&#125;);$(&quot;div&quot;).click(function () &#123;    console.log(&quot;哈哈&quot;);    $(this).css(&quot;backgroundColor&quot;, &quot;skyblue&quot;).siblings(&quot;div&quot;).css(&quot;backgroundColor&quot;, &quot;pink&quot;);    console.log($(this).index());    $(this).animate(&#123;        width: 300    &#125;).siblings(&quot;div&quot;).animate(&#123;        width: 120    &#125;);&#125;);\n\njQuery的入口函数\n入口函数可以解决获取jQuery对象, DOM结构还未渲染完毕问题\n入口函数类似之前学习过的window.onload或者DOMContentLoaded事件   \njQuery入口函数更接近DOMContentLoaded事件,因为jQuery入口函数只要DOM结构加载完毕以后就会调用\n\n入口函数写法一   $(匿名函数)   推荐写法\n\n$(function () &#123;    console.log(&quot;入口函数写法一&quot;);    console.log($(&quot;div&quot;));    // jQuery对象的属性    // length: 选择器返回jQuery对象中元素的个数    console.log($(&quot;div&quot;).length);    console.log($(&quot;p&quot;).length);    console.log($(&quot;h2&quot;).length);    console.log(&quot;&quot;);&#125;);\n\n\n入口函数写法二  document文档对象的ready事件\n\n$(document).ready(function () &#123;    console.log(&quot;入口函数写法二&quot;);    console.log($(&quot;p&quot;));    console.log(&quot;&quot;);&#125;)\n\njQuery对象和DOM对象的区别和转换jQuery对象和DOM对象的区别通过 $() 或者 jQuery对象的api以后,都会得到jQuery对象  jQuery对象只能使用jQuery对象的API 不能使用DOM的api\n$(&quot;.div1&quot;).css(&quot;color&quot;, &quot;red&quot;);$(&quot;.div1&quot;).style.backgroundColor = &quot;orange&quot;; // 报错 $(&quot;.div1&quot;)是jQuery对象\n\n通过原生document方式(获取DOM对象的方法)获取的就是DOM对象, DOM对象只能使用DOM对象提供的方法和属性,  不能使用jQuery对象提供的api\nvar div2 = document.querySelector(&quot;.div2&quot;);div2.css(&quot;color&quot;, &quot;red&quot;);// 报错, div2是DOM对象div2.style.backgroundColor = &quot;orange&quot;;\n\njQuery对象和DOM对象的转换\njQuery对象转成DOM对象的方式有两种第一种: jQuery对象[索引号]\n第二种: jQuery对象.get(索引号)\n\n\nvar $p = $(&quot;p&quot;); // jQuery对象的变量名一般我们可以以$开头  这样可以更好的跟DOM对象区分console.log($p);console.log($p[0]);console.log($p.get(0));console.log(document.querySelector(&quot;.p1&quot;));$p[0].innerText = &quot;我是段落1&quot;;\n\n\nDOM对象转成jQuery对象的方式  使用$()包裹DOM对象, 就可以得到jQuery对象    $(DOM对象)\n\nvar p1 = document.querySelector(&quot;.p1&quot;);console.log(p1);console.log($(p1));$(p1).css(&quot;fontSize&quot;, &quot;30px&quot;);\n\n注意: jQuery绑定的事件中,this对象是DOM对象,不是jQuery对象,所以我们可以$(this) 把this的DOM对象转成jQuery对象\n$(&quot;button&quot;).click(function () &#123;    console.log(&quot;this=&gt;&quot;, this);    this.style.backgroundColor = &quot;orange&quot;;    console.log(&quot;$(this)=&gt;&quot;, $(this));    $(this).css(&quot;backgroundColor&quot;, &quot;pink&quot;);&#125;);\n\njQuery选择器语法：$(“要带符号的CSS选择器”)  获取”所有”符合CSS选择器的元素,得到jQuery对象\n$(“CSS选择器”)  里面选择器直接写 CSS 选择器即可，但是要使用引号包括CSS选择器,另外CSS选择器需要带符号\n基础选择器\n\n\n名称\n用法\n描述\n\n\n\nID选择器\n$(&quot;#id&quot;)\n获取指定ID的元素\n\n\n全选选择器\n$(&quot;*&quot;)\n匹配所有元素\n\n\n类选择器\n$(&quot;.class&quot;)\n获取同一类class的元素\n\n\n标签选择器\n$(&quot;div&quot;)\n获取同一类标签的所有元素\n\n\n并集选择器\n$(&quot;div,p,li&quot;)\n获取多个元素\n\n\n交集选择器\n$(&quot;li.current&quot;)\n获取交集元素\n\n\n层级选择器层级选择器最常用的两个分别为：后代选择器和子代选择器。\n\n\n\n名称\n用法\n描述\n\n\n\n子代选择器\n$(&quot;ul&gt;li&quot;)\n使用&gt;号，获取亲儿子层级的元素；注意，不会获取孙子层级的元素\n\n\n后代选择器\n$(&quot;ul li&quot;)\n使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等\n\n\n属性选择器$(&#x27;[type=email]&#x27;) // 含有type属性,并且属性值为email的元素console.log($(&quot;input&quot;));console.log($(&quot;input[type=&#x27;text&#x27;]&quot;));console.log($(&quot;input[type=&#x27;radio&#x27;]&quot;));console.log(&quot;&quot;);console.log(&quot;&quot;);$(&#x27;input[checked]&#x27;) // 获取有checked属性的input元素console.log($(&quot;input[checked]&quot;));$(&#x27;input[name=&quot;first_name&quot;]&#x27;) // name属性为first_name 的 input元素console.log($(&quot;input[name=&#x27;first_name&#x27;]&quot;));$(&#x27;input[name!=&quot;first_name&quot;]&#x27;) // name属性不等于first_name的元素console.log($(&quot;input[name!=&#x27;first_name&#x27;]&quot;));$(&#x27;input[name^=&quot;first&quot;]&#x27;) // name属性以first开头的元素$(&#x27;input[name$=&quot;name&quot;]&#x27;) // name属性以name结尾的元素$(&#x27;input[name*=&quot;name&quot;]&#x27;) // name属性包含name的元素console.log($(&quot;input[type^=&#x27;r&#x27;]&quot;));console.log($(&quot;input[type$=&#x27;t&#x27;]&quot;));console.log($(&quot;input[type*=&#x27;o&#x27;]&quot;));\n\n表单选择器// ❤$(&quot;:input&quot;) ：匹配所有 input, textarea, select 和 button 也就是所有的表单元素console.log($(&quot;:input&quot;));// $(&quot;input&quot;) ：匹配所有 input标签元素console.log($(&quot;input&quot;));// $(&quot;:text&quot;) ：匹配所有的单行文本框console.log($(&quot;:text&quot;));// $(&quot;:password&quot;)：匹配所有密码框console.log($(&quot;:password&quot;));// $(&quot;:radio&quot;)：匹配所有单选按钮console.log($(&quot;:radio&quot;));// $(&quot;:checkbox&quot;)：匹配所有复选按钮// $(&quot;:file&quot;)：匹配所有上传框// $(&quot;:submit&quot;)：匹配所有提交按钮// $(&quot;:reset&quot;)：匹配所有重置按钮// $(&quot;:button&quot;)：匹配所有button按钮标签// ❤$(&quot;:checked&quot;): 查找所有选中的单选按钮,复选框以及option元素console.log($(&quot;:checked&quot;));// ❤$(&quot;:selected&quot;): 匹配所有选中的option元素console.log($(&quot;:selected&quot;));// $(&quot;:disabled&quot;): 匹配所有不可用元素,也就是被禁用的元素console.log($(&quot;:disabled&quot;));\n\n\n01-jQuery属性选择器与jQuery表单选择器.html \n\n筛选选择器筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。\n常见如下 :\n\n\n\n语法\n描述\n举例\n\n\n\n:first\n获取第一个li元素\n$(&quot;li:first&quot;)\n\n\n:last\n获取最后一个li元素\n$(&quot;li:last&quot;)\n\n\n:eq(index)\n获取索引号为2的li元素\n$(&quot;li:eq(2)&quot;)\n\n\n:odd\n获取索引号为奇数的li元素\n$(&quot;li:odd&quot;)\n\n\n:even\n获取索引号为偶数的li元素\n$(&quot;li:even&quot;)\n\n\n筛选方法\n\n\n方法\n描述\n举例\n\n\n\nparent([selector])\n获取最近一级的父元素\n$(element).parent(selector)\n\n\nchildren([selector])\n获取子元素\n$(element).children(selector)\n\n\nfind(selector)\n获取后代元素\n$(element).find(selector)\n\n\nsiblings([selector])\n获取除自身之外的所有兄弟元素\n$(element).siblings(selector)\n\n\nnextAll([selector])\n查找当前元素之后所有的同辈元素\n$(element).nextAll(selector)\n\n\nprevAll([selector])\n查找当前元素之前所有的同辈元素\n$(element).prevAll(selector)\n\n\nhasClass(&quot;类名&quot;)\n是否含有指定类名\n$(element).hasClass(&quot;类名&quot;)\n\n\neq(index)\n获取指定索引号的元素，索引号从0开始\n$(element).eq(index)\n\n\n注意: .eq(index)会比:eq(index)使用的更频繁\nvar myIndex = 4;$(&quot;ul li:eq(&quot; + myIndex + &quot;)&quot;).css(&quot;color&quot;, &quot;blue&quot;);$(&quot;ul li&quot;).eq(myIndex).css(&quot;font-style&quot;, &quot;italic&quot;);\n\n过滤方法与过滤选择器\n\n\n方法\n描述\n示例代码\n\n\n\n.first()\n找到第一个元素\n$(&quot;ul li&quot;).first().css(&quot;backgroundColor&quot;, &quot;pink&quot;);\n\n\n.last()\n找到最后一个元素\n$(&quot;ul li&quot;).last().css(&quot;backgroundColor&quot;, &quot;skyblue&quot;);\n\n\n:contains(&quot;文本内容&quot;)\n找到包含指定文本内容的子代或后代元素\n$(&quot;ul li:contains(&#39;傻瓜&#39;)&quot;).css(&quot;color&quot;, &quot;red&quot;);\n\n\n.next([选择器])\n获取匹配的元素集合中每一个元素下一个同辈元素的元素集合。如果提供一个选择器，那么只有紧跟着的兄弟元素满足选择器时，才会返回此元素。\n$(&quot;ul li&quot;).eq(2).next().next().css(&quot;backgroundColor&quot;, &quot;orange&quot;);\n\n\n.prev([选择器])\n获取一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。如果提供一个选择器，那么只有紧跟在前面的兄弟元素满足选择器时，才会返回此元素。\n$(&quot;ul li&quot;).eq(2).prev().css(&quot;backgroundColor&quot;, &quot;orange&quot;);\n\n\n\n.slice( start [,end] )根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。参数说明:start 一个整数，从 0 开始计数的下标。代表将要被选择的元素的起始下标。如果指定的下标是一个负数，那么代表从末尾开始计数。\nend (可选) 一个整数，从 0 开始计数的下标。代表将要被选择的元素的结束下标（不包含end）。如果指定的下标是一个负数，那么代表从末尾开始计数。如果忽略此参数，则选择的范围是从 start 开始，一直到最后。 \n$(&quot;ul li&quot;).slice(2).css(&quot;fontWeight&quot;, &quot;bold&quot;);$(&quot;ul li&quot;).slice(2, 4).css(&quot;fontWeight&quot;, &quot;bold&quot;);$(&quot;ul li&quot;).slice(-3).css(&quot;fontWeight&quot;, &quot;bold&quot;);$(&quot;ul li&quot;).slice(-5, -3).css(&quot;fontWeight&quot;, &quot;bold&quot;);\n\n:gt与:lt  选择匹配集合中所有大于&#x2F;小于给定index（索引值）的元素。索引值可以为负$(&quot;ul li:gt(3)&quot;).css(&quot;font-style&quot;, &quot;italic&quot;);$(&quot;ul li:lt(3)&quot;).css(&quot;font-style&quot;, &quot;italic&quot;);\n\njQuery操作jQuery样式操作jQuery中常用的样式操作有两种：css() 和 设置类样式方法\n方法1: css方法jQuery 可以使用 css 方法来获取设置设置元素样式\n常见以下几种形式:\n1.参数只写属性名，则是返回属性值\n获取第一个div元素的单个color属性值\nvar strColor = $(&quot;div&quot;).css(&#x27;color&#x27;);\n\n获取第一个元素的多个css属性样式值\nvar strColor = $(&#x27;div&#x27;).css( [&quot;width&quot;, &quot;height&quot;, &quot;color&quot;, &quot;background-color&quot;] );\n\n\n参数是属性名,属性值,逗号分隔,是设置一组样式,属性名必须加引号,属性值如果是数字可以不用跟单位和引号\n\n$(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;);\n\n\n参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开,属性名必须加引号，如果是数字可以不用跟单位和引号;\n\n$(&quot;div&quot;).css(&#123;    &quot;backgroundColor&quot; : &quot;skyblue&quot;,    &quot;fontSize&quot; : &quot;20&quot;,    &quot;fontWeight&quot; : &quot;bold&quot;&#125;);\n\n注意: 如果是复合属性可以采取驼峰命名法,比如font-size写成fontSize;如果属性值不是数字，则需要加引号\n**注意：**css() 多用于样式少时操作，多了则不太方便。\n$(&quot;button&quot;).eq(0).click(function () &#123;    console.log($(&quot;div&quot;).css()); // 报错, .css()方法中至少需要一个参数&#125;);$(&quot;button&quot;).eq(1).click(function () &#123;    console.log($(&quot;div&quot;).css(&quot;width&quot;));    console.log($(&quot;div&quot;).css(&quot;height&quot;));    // 属性名可以使用驼峰法或者短横杠连接法    console.log($(&quot;div&quot;).css(&quot;background-color&quot;));    console.log($(&quot;div&quot;).css(&quot;backgroundColor&quot;));&#125;);$(&quot;button&quot;).eq(2).click(function () &#123;    $(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;);    $(&quot;div&quot;).css(&quot;text-align&quot;, &quot;center&quot;);    // 属性名可以使用驼峰法或者短横杠连接法    // $(&quot;div&quot;).css(&quot;font-size&quot;, 20);    $(&quot;div&quot;).css(&quot;fontSize&quot;, &quot;20px&quot;);&#125;);$(&quot;button&quot;).eq(3).click(function () &#123;    // 注意: 如果属性名有短横杠,那么需要加上引号; 或者直接使用驼峰法,驼峰法可以不写引号  属性值如果单位是px的话,可以省略px,写数值即可  也可以写 &quot;数值px&quot;    $(&quot;div&quot;).css(&#123;        color: &quot;red&quot;,        &quot;text-align&quot;: &quot;center&quot;,        fontSize: 20    &#125;);&#125;);\n\n方法2: 操作类名方法jquery常用的三种设置类样式方法：\n\n\n\n方法\n描述\n\n\n\njQuery对象.addClass(&quot;类名&quot;)\n添加类到元素\n\n\njQuery对象.removeClass(&quot;类名&quot;)\n从元素中删除类\n\n\njQuery对象.toggleClass(&quot;类名&quot;)\n切换元素的类，如果存在则删除，不存在则添加\n\n\njQuery文本内容操作常见操作有三种：html() &#x2F; text() &#x2F; val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。\n\n普通元素内容html()    相当于原生innerHTMLhtml(&quot;&quot;) // 获取元素的内容html(&quot;内容&quot;) // 设置元素的内容console.log($(&quot;div&quot;).html());\n\n普通元素文本内容text()   相当于原生innerTexttext() // 获取元素的文本内容text(&quot;内容&quot;) // 设置元素的文本内容console.log($(&quot;div&quot;).text());\n\n表单的值val()     相当于原生valueval() // 获取表单的值val(&quot;内容&quot;) // 设置表单的值console.log($(&quot;div&quot;).val());\n\n**注意：**html() 可以解析HTML标签，text() 无法解析标签。\njQuery属性操作\n自定义属性一般以 data- 开头\n操作元素固有属性(自带属性)使用prop()方法注意: prop()方法只能操作自带属性,不能操作自定义属性\n\n操作元素自定义属性使用attr()方法注意: attr()方法可以操作自带属性,也可以操作自定义属性,更推荐attr()只操作自定义属性\n\njQuery对象.removeAttr(“属性名”)  可以删除自定属性也可以删除自定义属性\n\n\n$(&quot;button&quot;).eq(0).click(function () &#123;    // 获取自带属性    console.log($(&quot;div&quot;).prop(&quot;class&quot;));    console.log($(&quot;div&quot;).prop(&quot;id&quot;));    console.log($(&quot;div&quot;).prop(&quot;data-index&quot;));&#125;);$(&quot;button&quot;).eq(1).click(function () &#123;    // 设置自带属性    $(&quot;div&quot;).prop(&quot;class&quot;, &quot;myDiv&quot;);    $(&quot;div&quot;).prop(&quot;id&quot;, &quot;qwe&quot;);    $(&quot;div&quot;).prop(&quot;data-nav&quot;, 30);&#125;);$(&quot;button&quot;).eq(2).click(function () &#123;    console.log($(&quot;div&quot;).attr(&quot;class&quot;));    console.log($(&quot;div&quot;).attr(&quot;id&quot;));    console.log($(&quot;div&quot;).attr(&quot;data-index&quot;));&#125;);$(&quot;button&quot;).eq(3).click(function () &#123;    $(&quot;div&quot;).attr(&quot;class&quot;, &quot;myDiv&quot;);    $(&quot;div&quot;).attr(&quot;id&quot;, &quot;qwe&quot;);    $(&quot;div&quot;).attr(&quot;data-index&quot;, 12);    $(&quot;div&quot;).attr(&quot;data-nav&quot;, 30);&#125;);$(&quot;button&quot;).eq(4).click(function () &#123;    // jQuery对象.removeAttr(&quot;属性名&quot;)   可以删除自定属性也可以删除自定义属性    $(&quot;div&quot;).removeAttr(&quot;class&quot;);    $(&quot;div&quot;).removeAttr(&quot;id&quot;);    $(&quot;div&quot;).removeAttr(&quot;data-index&quot;);&#125;);$(&quot;button&quot;).eq(5).click(function () &#123;    // 获取复选框的选中状态    console.log($(&quot;input&quot;).prop(&quot;checked&quot;));    console.log($(&quot;input&quot;).attr(&quot;checked&quot;));    console.log(&quot;&quot;);&#125;);$(&quot;button&quot;).eq(6).click(function () &#123;    $(&quot;input&quot;).prop(&quot;checked&quot;, false);    // $(&quot;input&quot;).attr(&quot;checked&quot;, false);&#125;);\n\n\n09-jQuery属性操作.html \n\njQuery元素操作\n创建元素  “会返回jQuery对象”$(“&lt;标签名&gt;&lt;&#x2F;标签名&gt;”)\n$(“&lt;标签名&gt;标签内容&lt;&#x2F;标签名&gt;”)\n\n内部添加(内部添加元素,生成之后,它们是父子关系)\n\n\n方法\n描述\n\n\n\nappend()\n把内容放入匹配元素内部最后面,类似原生中的appendChild\n\n\nprepend()\n把内容放入匹配元素内部最前面\n\n\n\n外部添加(外部添加元素,生成之后,它们是兄弟关系)\n\n\n方法\n描述\n\n\n\nbefore(“内容”)\n把内容放入目标元素前面\n\n\nafter(“内容”)\n把内容放入目标元素后面\n\n\n\n\n注意: 在添加元素的时候, 如果元素已经在当前页面中存在, 那么实现的效果是移动, 不是新增\n\n删除元素与清空标签内容语法\n\n\n方法\n描述\n\n\n\n.remove()\n删除指定的jQuery元素本身\n\n\n.empty()\n删除指定的jQuery元素集合中所有的子节点\n\n\n.html(&quot;&quot;)\n清空指定的jQuery元素内容\n\n\n.text(&quot;&quot;)\n清空指定的jQuery元素内容\n\n\n.val(&quot;&quot;)\n清空指定的表单元素value值\n\n\n\n\n克隆元素jQuery对象.clone([true])  谁调用这个方法就会将当前的元素进行克隆一份\n参数说明： true：可缺省的，如果带true这个参数，表示克隆元素的本身的同时还会将该元素身上绑定的事件也会克隆.\n​\t\t\t但是如果没有带true这个参数或者参数为false，它只会克隆元素本身不会克隆其事件。\n替换元素jQuery对象.replaceWith( 提供的content内容 ) 用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合。\njQuery对象.replaceWith( 提供的content内容 ) 也即是将所有匹配的元素替换成指定的HTML或DOM元素。\n**语法：**jQuery对象.replaceWith(content) content接受一个用来插入的内容，可以是HTML字符串，DOM元素，或者jQuery对象。\n比如：$(&#39;div.second&#39;).replaceWith(&#39;&lt;h2&gt;New heading&lt;/h2&gt;&#39;);\n$(&quot;button&quot;).eq(0).click(function () &#123;    // content是一个普通字符串    // $(&quot;p&quot;).replaceWith(&quot;aaa&quot;);    // content是一个HTML字符串    $(&quot;p&quot;).replaceWith(&quot;&lt;h2&gt;我是标题2&lt;/h2&gt;&quot;);&#125;);$(&quot;button&quot;).eq(1).click(function () &#123;    // 获取b标签的DOM对象    var objB = document.querySelector(&quot;b&quot;);    // content是一个DOM对象    $(&quot;p&quot;).replaceWith(objB);&#125;);$(&quot;button&quot;).eq(2).click(function () &#123;    // content是一个jQuery对象    $(&quot;p&quot;).replaceWith($(&quot;i&quot;));&#125;);\n\n\n11-jQuery替换元素.html \n\njQuery尺寸操作jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。\n\n\n\n方法\n描述\n\n\n\n.width()\n获取匹配元素的宽度值，只计算内容区域的宽度（不包含padding、border）\n\n\n.height()\n获取匹配元素的高度值，只计算内容区域的高度（不包含padding、border）\n\n\n.width(值)\n设置匹配元素的宽度值，只计算内容区域的宽度（不包含padding、border）\n\n\n.height(值)\n设置匹配元素的高度值，只计算内容区域的高度（不包含padding、border）\n\n\n.innerWidth()\n获取匹配元素的宽度值，包含padding\n\n\n.innerHeight()\n获取匹配元素的高度值，包含padding\n\n\n.outerWidth()\n获取匹配元素的宽度值，包含padding和border\n\n\n.outerHeight()\n获取匹配元素的高度值，包含padding和border\n\n\n.outerWidth(true)\n获取匹配元素的宽度值，包含padding、border和margin\n\n\n.outerHeight(true)\n获取匹配元素的高度值，包含padding、border和margin\n\n\n注意:\n\n以上参数为空，则是获取相应值，返回的是数字型\n\n如果参数为数字，则是修改相应值\n\n参数可以不必写单位\n\n有了这套 API 我们将可以快速获取和设置的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。\n\n\n\n03-jQuery尺寸操作.html \n\njQuery位置操作jQuery的位置操作主要有三个： offset()、position()、scrollTop()&#x2F;scrollLeft() , 具体介绍如下: \n\noffset()”设置”或”获取”元素相对页面(body,文档)的偏移\n\nposition()”获取”元素偏移(一般是给定位元素使用的,会得到相对”非静态定位父辈元素”的偏移距离)\n\n\n\n04-jQuery位置操作(上).html \n\n\nscrollTop()&#x2F;scrollLeft() 设置或获取元素被卷去的头部距离和左侧距离\n\nscrollTop() 方法设置或返回被选元素被卷去的头部\n\n不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部\n\n\n\n\n\n04-jQuery位置操作(下).html \n\njQuery事件jQuery事件注册jQuery事件注册简单用法\njQuery对象.不带on的事件类型(匿名函数)\n比如\n$(“div”).click(function(){});\n$(“p”).mouseover(function(){});\n缺点1: 绑定之后, 通过动态添加的元素, 这种方法无法给这些新添加的元素绑定的\n缺点2: 并不是所有事件都可以使用这种方式绑定\n$(&quot;ul li&quot;).click(function () &#123;    $(this).css(&quot;backgroundColor&quot;, &quot;skyblue&quot;);&#125;);$(&quot;ul li&quot;).mouseover(function () &#123;    $(this).css(&quot;backgroundColor&quot;, &quot;lightgreen&quot;);&#125;);$(&quot;ul li&quot;).mouseout(function () &#123;    $(this).css(&quot;backgroundColor&quot;, &quot;pink&quot;);&#125;);var btn = document.querySelector(&quot;button&quot;);var objUl = document.querySelector(&quot;ul&quot;);btn.onclick = function () &#123;    var newLi = document.createElement(&quot;li&quot;);    newLi.innerText = &quot;李狗蛋&quot;;    objUl.appendChild(newLi);&#125;\n\njQuery对象中没有input()这个方法 ,所以使用的时候,会报错\n$(&quot;input&quot;).input(function () &#123;    console.log(this.value);&#125;); //报错$(&quot;input&quot;).on(&quot;input&quot;, function () &#123;    console.log(this.value);&#125;);\n\njQuery事件注册 on()方法\n之前的jQuery绑定事件方式( jQuery对象.不带on的事件绑定) 有两个缺点\n\n某些事件无法绑定 比如 input事件$(&quot;input&quot;).input(function () &#123;&#125;)\n\non()方法可以给input文本框绑定oninput事件\n$(&quot;input&quot;).on(&quot;input&quot;, function () &#123;    console.log($(this).val());&#125;);\n\n动态创建的新元素,无法绑定事件\n\n\n使用on()方法给jQuery对象绑定事件,语法如下:jQuery对象.on(“不带on的事件类型” [, 后代或者子代元素或者要带符号的CSS选择器] , 回调函数 )\n\n\n注意: on()方法绑定多个事件的时候,可以使用对象形式传递参数\n$(&quot;div&quot;).on(&#123;    &quot;click&quot;: function () &#123;        console.log(&quot;div的click事件&quot;);    &#125;,    &quot;mouseover&quot;: function () &#123;        console.log(&quot;div的mouseover事件&quot;);    &#125;,    &quot;mouseout&quot;: function () &#123;        console.log(&quot;div的mouseout事件&quot;);    &#125;&#125;);\n\n注意: on()绑定事件的时候,如果多个事件的处理函数是相同的,可以把多个事件写在一起, “空格”隔开\n$(&quot;p&quot;).on(&quot;mouseover mouseout click&quot;, function () &#123;    console.log(&quot;鼠标移上或者移出p段落了&quot;);&#125;)\n\n注意: on()方法实现事件委托(事件代理)\n$(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function () &#123;    console.log(&quot;this=&gt;&quot;, this);    $(this).css(&quot;backgroundColor&quot;, &quot;pink&quot;).siblings(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;);&#125;)\n\none()方法绑定事件one()使用方式跟on()几乎一样,one()主要用于给jQuery对象绑定一次事件,总共只能触发一次\n$(&quot;p&quot;).one(&quot;click&quot;, function () &#123;            console.log(&quot;p被点击了&quot;);        &#125;);\n\noff()解绑事件\n\n\n语法\n描述\n\n\n\n$(&quot;p&quot;).off()\n解绑所有p元素的事件处理程序\n\n\n$(&quot;p&quot;).off(&quot;click&quot;)\n解绑p元素上的点击事件\n\n\n$(&quot;p&quot;).off(&quot;mouseover mouseout&quot;)\n解绑p元素上的指定多个事件（多个事件名称用空格隔开）\n\n\n$(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;)\n解绑事件委托（在ul元素上绑定的事件，并指定委托的子元素li）\n\n\n手动触发事件有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; \n\n\n\n语法\n举例\n\n\n\njQuery对象.不带on事件类型()\n$(“div”).click();\n\n\njQuery对象.trigger(&quot;不带on事件类型&quot;)\n$(“input”).trigger(“focus”);\n\n\njQuery对象.triggerHandler(&quot;不带on事件类型&quot;)\n$(“input”).triggerHandler(“focus”);\n\n\n注意: 语法一和语法二触发效果一样, 但是语法三triggerHandler模式不会触发元素的默认行为\n页面绑定滚动事件给页面绑定滚动事件(可以给document对象或者window对象绑定的页面滚动事件, 更推荐window对象绑定 )\nwindow.onscroll = function () &#123;    console.log(&quot;页面滚动中&quot;);&#125;;$(document).scroll(function () &#123;    console.log(&quot;页面滚动中&quot;);&#125;);\n\njQuery事件对象jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。\n语法\njQuery对象.on(events,[selector],function(event) {})\n阻止默认行为：event.preventDefault()\n阻止冒泡： event.stopPropagation()\n注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。\n隐式迭代**介绍：**对于原生 JS 来说，给某类元素设置样式需要使用循环逐个设置，而在 jQuery 中无需考虑这点，简单示例如下\n**概念：**因为大部分的jQuery方法都支持隐式迭代，隐式迭代的原理是方法的内部存在看不见的遍历，它会对匹配到的所有元素进行循环遍历，执行相应的方法，而无需我们再手动地进行循环，方便我们使用\njs方式 给所有div设置样式和事件\nvar divs = document.querySelectorAll(&quot;div&quot;);for (var i = 0; i &lt; divs.length; i++) &#123;    divs[i].style.backgroundColor = &quot;pink&quot;;    divs[i].onclick = function () &#123;        console.log(&quot;div被点击了&quot;);    &#125;&#125;\n\njQuery方式 给所有div设置样式和事件\n$(&quot;div&quot;).css(&quot;backgroundColor&quot;, &quot;pink&quot;);$(&quot;div&quot;).click(function () &#123;    console.log(&quot;div被点击了~~~&quot;);&#125;);\n\njQuery获取索引号 index()\njQuery对象.index( [selector] )搜索匹配的元素，并返回相应元素的索引值，从0开始计数。\n如果不给 .index() 方法传递参数，那么返回值就是这个jQuery对象集合中第一个元素相对于其同辈元素的位置。\n如果参数是DOM元素或者jQuery对象，那么返回值就是传递的元素相对于原先集合的位置。\n\n注意细节:\n1、不传递参数,返回这个元素在同辈(所有类型的兄弟元素)中的索引位置( 不传递参数这种方式用的最多 )\n2、传递一个DOM对象,返回这个对象在原先集合中的索引位置\n3、传递一个jQuery对象,返回这个对象在原先集合中的索引位置\n4、传递一组jQuery对象,返回这组对象中第一个元素在原先集合中的索引位置\n\n\n// 1. index()前面的jQuery对象是&quot;单个&quot;console.log($(&quot;#bar&quot;).index());console.log(&quot;&quot;);console.log(&quot;&quot;);// 2. index()前面的jQuery对象是&quot;一组&quot;console.log($(&quot;ul li&quot;).index());console.log(&quot;&quot;);console.log(&quot;&quot;);// 3. 传递一个DOM对象,返回这个对象在原先集合中的索引位置var baz = document.querySelector(&quot;#baz&quot;);console.log($(&quot;ul li&quot;).index(baz));console.log(&quot;&quot;);console.log(&quot;&quot;);// 4. 传递一个jQuery对象,返回这个对象在原先集合中的索引位置console.log($(&quot;ul li&quot;).index($(&quot;#bar&quot;)));console.log(&quot;&quot;);console.log(&quot;&quot;);// 5. 传递一组jQuery对象,返回这组对象中第一个元素在原先集合中的索引位置console.log($(&quot;ul li&quot;).index($(&quot;.abc&quot;)));console.log(&quot;&quot;);console.log(&quot;&quot;);$(&quot;ul li&quot;).click(function () &#123;    // console.log(&quot;this=&gt;&quot;, this);    // console.log(&quot;$(this)=&gt;&quot;, $(this));    console.log($(this).index());&#125;);\n\njQuery动画效果jQuery 给我们封装了很多动画效果，最为常见的如下：\n\n\n\n方法\n描述\n\n\n\nshow()\n显示元素\n\n\nhide()\n隐藏元素\n\n\ntoggle()\n切换元素的显示和隐藏状态\n\n\nslideDown()\n滑动方式显示元素\n\n\nslideUp()\n滑动方式隐藏元素\n\n\nslideToggle()\n切换元素的滑动显示和隐藏状态\n\n\nfadeIn()\n淡入显示元素\n\n\nfadeOut()\n淡出隐藏元素\n\n\nfadeToggle()\n切换元素的淡入淡出状态\n\n\nfadeTo()\n将元素的透明度动画过渡到指定的值\n\n\nanimate()\n在元素上执行自定义动画效果，如位置、大小、颜色等\n\n\nxxxxxxxxxx     &#x2F;&#x2F; 与v-for同级的ref 返回值都是列表渲染出来当前元素数组集合            &#x2F;&#x2F;v-for 内部的ref 返回值也是列表渲染出来当前元素数组集合        -span        没用的a                &lt;button @click&#x3D;”showRefList”&gt;click​    new Vue({        el: &#39;#app&#39;,        data: {            arr: [1, 2, 3, 4, 5]        },        methods: {            showRefList() {​                console.log(this.$refs.numList,                            this.$refs.spanList)                // [p,p,p,p,p] , [span,span,span,span,span]              }        }    })html\n\nspeed 动画速度,动画时长的毫秒数值 (如：1000)  取值三种预定速度之一的字符串(“slow”,”normal”, or “fast”)或表示动画时长的毫秒数值\neasing 指定切换效果，默认是”swing”，可用参数”linear”\nfn 在”动画完成时”执行的函数，每个元素执行一次。\n\n显示隐藏$(&quot;button&quot;).eq(0).click(function () &#123;    // $(&quot;div&quot;).show();    // $(&quot;div&quot;).show(&quot;slow&quot;);    // $(&quot;div&quot;).show(&quot;fast&quot;);    // $(&quot;div&quot;).show(2000);    // $(&quot;div&quot;).show(2000, &quot;linear&quot;);    /* $(&quot;div&quot;).show(function () &#123;                console.log(&quot;显示完毕&quot;);            &#125;); */    $(&quot;div&quot;).show(2000, &quot;linear&quot;, function () &#123;        console.log(&quot;显示完毕&quot;);        $(this).css(&quot;backgroundColor&quot;, &quot;skyblue&quot;);    &#125;);&#125;);$(&quot;button&quot;).eq(1).click(function () &#123;    $(&quot;div&quot;).hide();&#125;);$(&quot;button&quot;).eq(2).click(function () &#123;    // $(&quot;div&quot;).toggle();    // $(&quot;div&quot;).toggle(500);    // $(&quot;div&quot;).toggle(500, &quot;linear&quot;);    $(&quot;div&quot;).toggle(500, &quot;linear&quot;, function () &#123;        console.log(&quot;切换完毕~&quot;);    &#125;);&#125;);\n\n\n[16-jQuery 动画效果-显示与隐藏.html](....\\web\\每日代码\\32_jQuery\\16-jQuery 动画效果-显示与隐藏.html) \n\n滑入滑出// jQuery对象.slideUp( speed, ease , fn );// jQuery对象.slideDown( speed, ease , fn );// jQuery对象.slideToggle( speed, ease , fn );$(&quot;button&quot;).eq(0).click(function () &#123;    // $(&quot;div&quot;).slideUp();    // $(&quot;div&quot;).slideUp(800);    // $(&quot;div&quot;).slideUp(800, &quot;linear&quot;);    $(&quot;div&quot;).slideUp(2000, &quot;linear&quot;, function () &#123;        console.log(&quot;上滑完毕&quot;);    &#125;);&#125;);$(&quot;button&quot;).eq(1).click(function () &#123;    $(&quot;div&quot;).slideDown(400, &quot;linear&quot;, function () &#123;        console.log(&quot;下滑完毕&quot;);    &#125;);&#125;);$(&quot;button&quot;).eq(2).click(function () &#123;    $(&quot;div&quot;).slideToggle(400);&#125;);\n\n\n01-jQuery动画效果-上滑下滑.html \n\n淡入淡出// 淡入 jQuery对象.fadeIn( [speed, easing, fn] )// 淡出 jQuery对象.fadeOut( [speed, easing, fn]  )// 淡入淡出切换 jQuery对象.fadeToggle( [speed, easing, fn] )// 指定透明度 jQuery对象.fadeTo( speed, opacity [,easing, fn] )$(&quot;button&quot;).eq(0).click(function () &#123;    $(&quot;div&quot;).fadeIn();&#125;);$(&quot;button&quot;).eq(1).click(function () &#123;    // $(&quot;div&quot;).fadeOut();    // $(&quot;div&quot;).fadeOut(1000);    $(&quot;div&quot;).fadeOut(1000, &quot;linear&quot;, function () &#123;        console.log(&quot;淡出完毕&quot;);    &#125;);&#125;);$(&quot;button&quot;).eq(2).click(function () &#123;    $(&quot;div&quot;).fadeToggle();&#125;);$(&quot;button&quot;).eq(3).click(function () &#123;    // $(&quot;div&quot;).fadeTo(0.5); // 无效,至少需要前两个参数    // $(&quot;div&quot;).fadeTo(400, 0.5);    $(&quot;div&quot;).fadeTo(400, 0.2);&#125;);\n\n\n02-jQuery动画效果-淡入淡出.html \n\n事件切换hover以及停止动画队列jquery对象.hover(函数1, 函数2)   鼠标移上触发函数1, 鼠标移出触发函数2\n/*jquery对象.hover(function()&#123;&#125;, function()&#123;&#125;)*/$(&quot;div&quot;).hover(function () &#123;    console.log(&quot;鼠标移上div了&quot;);&#125;, function () &#123;    console.log(&quot;鼠标移出div了&quot;);&#125;);\n\njquery对象.hover(函数)  鼠标移上或者鼠标移出都触发这个函数\n/*jquery对象.hover(function()&#123;&#125;)*/$(&quot;div&quot;).hover(function () &#123;    console.log(&quot;鼠标移上或者鼠标移出div了&quot;);&#125;);\n\njQuery中, 如果有多个动画需要执行,这多个动画就会形成一个动画队列, 按动画队列的顺序依次执行 默认需要上一个动画执行完毕才可以执行下一个动画\njQuery对象.stop() 清除之前的动画队列  一般stop()需要写在动画函数的前面\n$(&quot;.nav &gt; li&quot;).hover(function () &#123;    // $(this).find(&quot;ul&quot;).toggle();    // $(this).find(&quot;ul&quot;).slideToggle();    // $(this).find(&quot;ul&quot;).fadeToggle();    // $(this).find(&quot;ul&quot;).slideToggle().stop();    $(this).find(&quot;ul&quot;).stop().slideToggle();&#125;);\n\n\n03-事件切换hover以及停止动画队列.html \n\n自定义动画自定义动画animate语法\njQuery对象.animate( obj [, speed, easing, fn] )\n注意: 参数1 obj 是需要做动画的 css 属性键值对,obj参数的取值是一个”对象”\n$(&quot;div&quot;).click(function () &#123;    $(&quot;div&quot;).animate(&#123;        width: 400,        height: 100    &#125;, 1000, &quot;linear&quot;, function () &#123;        $(&quot;div&quot;).css(&quot;textAlign&quot;, &quot;center&quot;);        $(&quot;div&quot;).animate(&#123;            &quot;background-color&quot;: &quot;rgb(0,255,0)&quot;,            &quot;border-color&quot;: &quot;purple&quot;,            color: &quot;purple&quot;,            fontSize: 50        &#125;)    &#125;);&#125;);\n\n注意: 默认animate()方法也是不支持颜色相关属性值的动画变化 但是引入一个jQuery插件(jQuery插件就是基于jQuery开发的增强功能的第三方库)  jquery.color.js只能解决部分颜色的动画问题,不是所有颜色\n&lt;script src=&quot;./js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 注意: jquery.color.js是基于jQuery.js的,所以需要在jQuery引入之后引入 --&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery-color/2.1.2/jquery.color.min.js&quot;&gt;&lt;/script&gt;\n\n带有动画的返回顶部\n\n\n方法\n描述\n\n\n\nscrollTop()\n页面直接回到Y轴指定位置(不带动画)\n\n\nscrollLeft()\n页面直接回到X轴指定位置(不带动画)\n\n\n$(&quot;button&quot;).click(function () &#123;    // 页面直接回到指定位置(不带动画)    // $(window).scrollTop(数值);    // $(window).scrollTop(500);    // $(window).scrollLeft(数值);    // $(window).scrollLeft(200);    // 页面动画滚动,需要使用html标签对象    $(&quot;html&quot;).stop().animate(&#123;        scrollTop: 500,        scrollLeft: 200    &#125;);&#125;);\n\n\n 05-带有动画的返回顶部.html \n\njQuery遍历元素(难点,重点)jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。\njQuery对象.each( 函数 )方法遍历匹配每一个元素,主要用于DOM处理\n// 参数index是当前正在遍历索引号, domElement是正在遍历dom对象  this是正在遍历dom对象$(&quot;div&quot;).each(function (index, domElement) &#123;    // console.log(&quot;index=&gt;&quot;, index);    // console.log(&quot;domElement=&gt;&quot;, domElement);    // console.log(&quot;this=&gt;&quot;, this);    // console.log(&quot;&quot;);    console.log($(domElement).html());    console.log($(this).html());    console.log($(this).css(&quot;backgroundColor&quot;));    console.log(&quot;&quot;);&#125;);\n\n\n12-jQuery遍历元素(难点,重点).html \n\n$.each()方法 用的不多$.each()是jQuery构造函数的静态方式\n$.each( object , function( index , element ) {} )方法 主要用于遍历数据(遍历数组或者自定义对象或者jQuery对象) \n// 使用$.each()遍历数组var arr = [10, 20, 50, 75, 62];$.each(arr, function (index, item) &#123;    console.log(&quot;index=&gt;&quot;, index);    console.log(&quot;item=&gt;&quot;, item);    console.log(&quot;&quot;);&#125;);// 使用$.each()遍历自定义对象var obj = &#123;    id: 2,    uname: &quot;zhangsan&quot;,    age: 23,    sex: &quot;男&quot;&#125;;$.each(obj, function (key, val) &#123;    console.log(&quot;key=&gt;&quot;, key);    console.log(&quot;val=&gt;&quot;, val);    console.log(&quot;&quot;);&#125;);// 使用$.each()遍历jQuery对象$.each($(&quot;button&quot;), function (index, domElement) &#123;    console.log(&quot;index=&gt;&quot;, index);    console.log(&quot;domElement=&gt;&quot;, domElement);    console.log(&quot;&quot;);&#125;);\n\n\n13-$.each()方法 用的不多.html方法 用的不多.html) \n\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"前端各个包管理器的优缺点","url":"/2025/03/04/%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","content":"在前端项目中，包管理器的选择会影响依赖管理、构建速度、磁盘空间占用等方面。下面是 npm、pnpm、yarn、bun、deno 的优缺点对比，以及推荐的使用场景。\n\n📌 1. npm（Node Package Manager）📌 Node.js 默认自带的包管理器，从 npm 5+ 开始支持 package-lock.json 以提高一致性。\n✅ 优点\n官方默认，无需额外安装，生态最完善。\nnpm 7+ 支持 workspaces（多包管理）。\nnpx 允许临时执行 npm 包，无需全局安装。\nnpm audit 提供安全检查。\n\n❌ 缺点\n安装速度较慢（相较于 pnpm、bun）。\n文件重复占用空间大，node_modules 体积大。\npackage-lock.json 可能导致版本不一致问题（npm 6 以前）。\n\n🚀 适用场景✅ 适合小型项目或默认情况下使用，不需要额外安装包管理器。\n\n📌 2. pnpm（Performant NPM）📌 基于 npm，使用符号链接（symlink）和全局存储，加速依赖管理。\n✅ 优点\n安装速度快（使用 hard link 和 symlink，无需重复下载相同依赖）。\n节省磁盘空间（不同项目共享依赖）。\n更快的 node_modules 解析（相比 npm 和 yarn）。\n严格模式，防止“幽灵依赖”（比如 A 依赖 B，而你直接使用 B，但没有在 package.json 里声明）。\n\n❌ 缺点\n由于 node_modules 结构特殊，有些旧的 npm 包（特别是某些 postinstall 脚本）可能不兼容。\n不兼容 npm link 方式管理本地依赖（需要 pnpm link）。\npnpm lockfile 格式与 npm&#x2F;yarn 不兼容，如果团队成员混用 npm&#x2F;pnpm 可能会导致问题。\n\n🚀 适用场景✅ 适合大型项目、monorepo（多包管理），尤其是 Vue&#x2F;React 现代前端项目。\n\n📌 3. yarn（Yet Another Resource Negotiator）📌 Facebook 开发的 npm 替代品，主要用于解决 npm 早期的性能问题。\n✅ 优点\n并行安装，比 npm 6 以前快很多。\n缓存优化，已安装的包不会重新下载。\nYarn 2+（Berry）支持 Plug’n’Play（PnP），省去 node_modules，优化解析速度。\n支持 workspaces（monorepo 多包管理）。\n\n❌ 缺点\nYarn 2（Berry）默认不使用 node_modules，可能会导致部分旧库不兼容。\nyarn.lock 和 package-lock.json 不兼容，混用 npm&#x2F;yarn 可能会有问题。\n相比 pnpm，磁盘占用优化不如 pnpm。\n\n🚀 适用场景✅ 适合 使用 Monorepo、Next.js 等项目，或者喜欢 Yarn 生态（比如 yarn workspaces）。\n\n📌 4. Bun📌 全新 JavaScript 运行时（Bun.js），自带超快的包管理器，基于 Zig 编写，速度极快。\n✅ 优点\n安装速度最快，比 npm、pnpm、yarn 还要快 🚀。\nBun 直接替代 Node.js 运行环境，可以运行 JavaScript 代码。\nBun 内置 TypeScript 解析，不需要 tsc。\n自动支持 .env 文件，内置环境变量解析。\n支持 ESM 和 CommonJS，比 Deno 更兼容 Node.js 生态。\n\n❌ 缺点\n生态尚未完善，部分 npm 包可能不兼容。\nMac 和 Linux 支持更好，Windows 仍在改进。\n相对较新，不稳定性和 Bug 可能比 npm&#x2F;pnpm&#x2F;yarn 多。\n\n🚀 适用场景✅ 适合新项目、追求极致性能的开发，特别是 使用 Bun 作为运行时时。\n\n📌 5. Deno📌 Node.js 的竞争对手，默认安全、原生支持 TypeScript，但不兼容 node_modules 生态。\n✅ 优点\n默认支持 TypeScript，无需 tsc。\n安全沙盒机制，默认无网络&#x2F;文件访问权限，提高安全性。\n内置 fetch、Web API，原生支持 HTTP 服务器。\n不使用 node_modules，不需要 package.json，直接 import 远程模块。\n\n❌ 缺点\n不兼容 npm 生态（虽然可以用 deno npm 兼容，但仍有部分问题）。\n社区生态比 Node.js 小，许多库没有官方 Deno 版本。\n包管理方式和 Node.js 不同，上手需要学习新概念。\n\n🚀 适用场景✅ 适合 新技术探索、想要内置 TS 支持、安全性要求高的项目，但不适合传统 npm 项目。\n\n📌 6. 选择哪一个？（总结对比）\n\n\n包管理器\n安装速度\n磁盘占用\n兼容性\n适用场景\n\n\n\nnpm\n较慢\n大\n100% 兼容\n小型项目，默认方案\n\n\npnpm\n🚀 超快\n🔥 最省空间\n99% 兼容\n大型项目、Monorepo\n\n\nyarn\n快\n中\n99% 兼容\nMonorepo，Next.js 项目\n\n\nbun\n🚀🚀🚀 最高\n中\n80% 兼容\n追求极致性能的新项目\n\n\ndeno\n🚀 快\n小\n低\n需要 TypeScript 原生支持、新技术\n\n\n\n📌 最推荐哪一个？\n如果你是普通 Node.js&#x2F;Vue&#x2F;React 项目，✅ pnpm（更快、更省空间）。\n如果你是 Monorepo 项目（多个 npm 包），✅ pnpm 或 yarn。\n如果你想试试新技术，追求极致速度，✅ bun（但还不稳定）。\n如果你不想折腾，默认即可，✅ npm（但不推荐 npm install，可以 npm ci）。\n\n🎯 结论：大多数情况下，推荐 pnpm！ 🚀\n","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"新世纪🀄文学习指南💯","url":"/2024/12/13/%E6%96%B0%E4%B8%96%E7%BA%AA%E4%B8%AD%E6%96%87%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","content":"\n  f1361f5d8850aea0e378713933613951c3bfacb10f1d4a0ee323dd45d4a617a35377708b12003bdb480101d606d05e89e083deeea1b54b9a696a026d2a966fdcafb6b26b4f89970dc879ac48cbe3fa86da5dacc6be1d623d00d23853bba9f3948d31e960b82b06d95b55543db87761b67a6f819f19d224fcb0da024254f20814b97acfc0cf9f4607cebd0e617dd263e757f06e953e277f1510821eba73494ad074ff610f3274fe49886656e8faccc9c1f6922e251cc59dfb7e4e6682bbfa67b0bfd6d7e2c5cfee391eefa36a0e63a73d442edfbec289d9cdadab02598cfed8e7de9e90ef6a84e5b7c9e1a84320a063cfd7a6f57164848ad27c0c7ef47f0ea5a9187bff0be5b944bf9a02e2edc20387138651af22e3edd1635266ece97b33fc703e23fd4520a04ae97653e0278603b65a12d98547b84061b247763aa541fa8018bbbb5b77b758f46e633b2caab083a3234f1a5717da8b0755fc4506bca9e642d96d19d45ce7a1814e43908c392cc625987011de936536e7fab5185eb22213ab21d8bbf417bb08933137565ddb78313a3b464c9cc5b13d28adca0d5285b2a99d57ddbe1220f557be9068d84fc8d3bfa8236b859001677157925e608cddd751aa6c10f8d26558b4e80afb87da4684b19e5982c55fe62424e3cd0e7def4610b4ca5972e0fd722dd753c25d6ca2b7572de5ae21c2c74d0dc11947d36872a4dea48997304f364c243e661d016ff87fdcc94e7079a3640939bcf26045fa2d47e1fd9b05ddc1c9f84fcbe0f49ab21b098a7c2b95db5a7c67f7dc7c6989d5696878dcf09806292dd21ef777837116884e179e28efca193bf32cf82d281954346459890ab15f655628959ddd854386b89b8c8b933aa487ed08f4be94480bcbd7bb83a8999aa6d1f45caac6386b48e2c33993eb20c5e3d12175806d0af3c6f4368eb3f0291379138359a63699bece97872de1e32f7e2b7949c9c725849bf618f5fb0853565d42908ff07d471481476b767ca02d174082e7604000a940ec801465bda0e1dadd9f7cc450d74b46791a411150296437cc2c0a2c453a2b2b01477e51f80a52dd11937428140dbd3c0ab303ff03832142d68ab6cf0e8b3a7cd231a13d2ee6abb752bddae8964d7717a85cef229c0e84c661dd3b1c273b47f7ebfcfee4d459e5c10fe9da41b91947a8e8410b6ac0dc1ee5f54e997b366dbec1ac28e8e9774de84792274c9769be7242a1a22eb699228dc9570eb7d8c200a79a7213ba766d9999cdb93861ae4ec1c5b974cf4b18f2780d0953e9419b5dacd8f109cc0eecc5d851f6680b88f0e29f351f1adc59b0e51a957ae3adc089c425731a42a2188f7dd89f56989b156efa55c35e104fcb81a73270d8de1a47c58e800e45c28b298afb4e5f37a40b10a1f264dabe623116ebe31e0bc4d972f111f7677abc92e6e671e276efcd05b93145283d000bed401b9295ec591132957a95f3bb9e08e7f5735b0742dba47ddcac49b6f2cbc294ea4de0c81d72ad963f3d5b534861fcaf4e3aff698a668da2100426efe48345074de1c37bd3f2212ef6aa6f0c9a79e287771789548d6778fac26ecf9f8974792045c806a7c415423321bc9ef3704812ea1a3e90a30858a62d0e247edc851c2d54a1b07ffe32a35dd9eec0781ea0ac4da2b841c046ec49bb6d91ef304866ea1227c35739855df40bd036d876d0bfa2d9c772d9e2237d6dcd446e5fc144fe3434c27dbdc964275e13d62f3b655d4470fee34dc0259895891d8860789885f8f0b70ab99564292ca2e9b2f9f14c567753983fd164412cda25cbc196855723b493ce7d2859aa9e0c2b463ddb2017ca331deb5acace8fd7d25442841f37106c1530cbb5921af10456aac07b58aa3ec356cac24cc2ebf636e53b631ebbd96b58f446e4eef6f42e5d8e03873dee5fe3cfcd8fe59f53e091f6fc668478d255c5f2a2c93361ad1a0a895490e55d3db25db764dc4fc2c98b08b1dcb51e739815a0172cbb9b3b81eee76de4708e68c1ea4eb2084aa4bbcf4932ee78fc0e24bb20aaafc045bc28a7d1d25ef2152ddf2274c028ef71f70ea042f4bae2b4c85085198eef2798e10541e358b634c7db363335a7690099488e6746acbab21a9b93f66ecd939f88c55fc7844ff7c9c0198750807938cdbadebaffcd901e89859970dd332833a2a5793f6c0f04c6bbcd96011e27087ad1cb52a5ac7874a9f97ee82bd00775e1d5b7e33a9890208703b98d0c90d74d2132ccebdd62b4f80dc6b67771c668fde9778857c3575999511a4a810e6669ba99866e50d966621186fa48ca6c877b83ea68f142f1be80094d8b585ad0e919e250cd1b21744b85c1d654bc4fc02bc5d499478710e2415303d8d53e63b02f4c59c45062a5f1579bad47f0a909d181bf41289c092a7d08b1a3a3b88f9b78e2477d5bc1ed924ffff180c8e271455199ecd1928cae7319e8ab8c7ce09b74f13c92116c79874c4d9314a7e344a13412d0515e53623af906dd1e2626c9494f19ed9362c4384528363fba4ec25b11e54a61343f2b19ec6a6ea841ab993f13e68582eadffcc449175f125bc49eaeb8f3eb7096f1333907620586a911f4398829aaf022c249b0309e4cd112108e8721282087fd74d6c1b2dc476d0cccfc816207a4f5217b04de508ef921fc213a1089495f5aff56ad397a606b0c8f9df395027e9f5c6958f8ec4e8a523579e9d0ccfde6f8b4e38c30d3267b92eb73da802c3e7eaa4e8f856d2b204803817a2f7b6f65bed3eb9cd26378ddb363f382be5472c2c79b9a76ea9a991d7bfca185c6f1821809660e15dd0edac76a34d325d8766be553d6a418c88cfa7bae80e19731115eaaae31d0be6cb2dc0e0e48524160ecfd520fe1badf52eef50ffa91433670e0ca7e54b83c64a245807f86f50a753ccb27b4272388007b2520dee8bcfd433dddcbfc6c42ef0210e93fab9c45cb882a636e51d9a81c9f8f98dfc1d735a3b81e704eab6e4d041a8c81cb90c73cc484adeafd719b5eaaa5be4ade5f24d808cacf92a31ef6afb701d21547438ae0214eb6cef79a2575a5bd5fb30d44602385b8eda566ef62f71d4ebab2e20d57a52e70384ab1410bf4975a92b4d0beae174ecc661760482872b63859f04c476679517e18d603de3ad57a6a7369bd179ea7129cd37763cd3890784976037e636beb34a61ef5290bb95960a62a8aa9aafaab572e830af3e244a3584eef8042d91e537e5d170ebec247235fb6531d8833eaf1510f2b94c0623eea23e69fc28df873cd321a0b7496e6c47beeb9a46ab23a9edf110e24f2d9b0b4f094047d1ad9dd4a7859eceec98a223ed4815a7a6d649585f7399e844d9a0044589c83e0ef1d8b3be76f61a8429f1554bd3968105fe8c65dbd6bc1a5e90f85a70ed11a28610afdb8f6a74c0001b42c53619dc529be10b1cdd0c91392b481767eb6627b7842cb1a68f1c7f546f87c78689946693681285e9999bbd533e22b21b621685677127fbab864dcd98a69ad3ac3e8f3d2b6ce17046195dc6ab1ec860ebd0c79a5b7a8818cd5b1f9444609197c60cae9e3c34dff7dd509ea239e168a5ab5d9c78c7224999bcb4a23fae716d0133bb8781273f19c351e8cd2abc3f5d3a51055c312531b26a8e9779df29878fe6fcdeb3eabfc20b824bb4058b32b99d76007381ecaa323da57e3aeca1a4e3c6a9564c654a6a8f45d4c2a7fcf1bf10706f4bd6da5fed6a02c3765f102dab238a05754f6ccafbf64f742f9cb83d45c26bd22a6a20dfb40b7d2846ce5ba3276291603b5f45107e9b8003228ff3c8423265564a7bf2fd024c82bfb87981d3be65dab7ada6d0d55d2f0a29f40bfee480fcd9fb200729c3fdbc6d31dece1a49148761766010df6f0d8c831d04d47a58053fb546e7eb86d127e8943754ba4f3a7b715658fb9b3e66739c8106b91794b4b47ecf8df1ba262097bc5468e3511217f2d9abf79fc88dc7cd4fce57072c04efa9b31fd2f44c4e85ebd3d918372c6b54494d3a09cb0574f82e33e9f8c3903708e4c7ab0255d61f7c6c4e3a037322366bb32575d5ebfd99544a0196d24bf903f8ac14dbd10a65c15b63f7d74e80d05f202dded4a34f0e1f7c639839986ff9d02d5df9e151c5e72eb7d60e32be2ebd57f3c0915e089e8de7e681e4e5ca8a981bf224037b899a3743a4016111062e05ef4fde9725be1554d9a8cfa27d848b10ea4ec108e91c90199caefb901bf011a5398238a9e66058d003741c3fb1ac88ccd6654c482f5755f8076fef93f0907f3f8c347b3f98453e1e532dd36619ba692f92af0ede2fb1093bb469e8c692da43429a91e6544e18517e7f65ee2d9826e747f58db15ba4ef15f4d6bfa83d4a606ca77172313638291bf25d4e303868e1b6f27a501b8ff7620edb93685cd157aac949da91aa7940e6d4eb4068d2d18fce1b2df18f5fd0982d8ba71d1c4fa4abe2903d062aeaa9aad72ddaa89a22ea22f06cddfaa7c32e538d839fa4f04208371627759b89f159348f7e061cc6ebcb92a598927cbb73641d2d568ed700ae0e8ea5ef72228aed3ceb7fbb292949fe45d3d52d7766ad92827ed2a4fdcd49564dfc08776dbcc9b46cf82bd4b443eb20511a1830159ece0c722fc2c1c10796609cfaaf4f6425490be9189f351f4666e53a9a972d2936b61e683c3b641f8a24345a4a6bfe84e6e5bfc0a6c9096caec7e49b527599a7f52a7fb54067d9471955693ceae4fd123a915fc4f25ab9011858bf4c5686140e0149c49fe485ada6b70aef978ddfc1be93fb42825eb27d767adf7a090bf7220c9889a19b6e143f36381d0a69700af695cbd85fcd8fc1d3bb34ebb186f31755cd28c593686cf3176ddfcecfbcdb2b44ceafae16760e20c2384edfaed4c9e0050dc630ccb1f6cb9ad7031fca97bd36a01bb2ab6ad74f2b9bd7ea45e228eee950b51f6413d6154f047ad1a2be9144a53884a735d373fc969c64a0a3aea791383fa3dc4f0f37d5dcca53b32fed599488fd17a91d1d14f68fa72cb12703ebb27e4ba59b18144e157fbacf6edc1a1eb5be5038a0237f1d3ba77aa6c11a293aa601deb65907795c5be0c9c0667a33b58410451e1fc04141c5be59888d6c7d1525983f9de67212822b3c2ee25904f88f86b4f82a530e4febe68538d117ad3e416de2b558afb19441f24d60da2933f1f16a433e372f748579601bfd6f4ce2ba63a354c4643870d4c95a2fd404427443d0ad0761c7dfac709b5f34507bb107a733a5b855f3bd3ee4b372825c1f3d0c5cead6611ac715cfd290b7d7fb35854ac5cede266bfc9a4aa14d61b2111838b6ed3fbd9fa35c763a977f40b9bb3dac52a389340ab0d52d94a2b21d6d36b904d59db5b9e78f5e38fede08f64833444a359168c3540f309ea60343e61c9c9d1527941851674bd4479dab5497010d2b1bc6c361ad4a00b709b23f3b7f61726a9c2869023524bfa5b6ea53f134574873e9df8df720d5e1bf77f09c704979744f0bcb9e14188b2a00ffc87edbc4ac3d9b421adf5cee9633a4419f216f86144e7b6d221a8373ad0031425da5fb7903897d6c8ee1819e18e4c4867c5c5735aa30eedc15ecfaef50a597307401b77df0e71f1dba354b6ac19b2f9c12de7ed979f87ba0b6d3fb97793ac3f3efb609a871f31e8f5454d08d1cf90ce161a6245bf5fb2ecddf684aed1544a9ba8b2a9dc42acf0f71d0722c926fecd65d96862bdc90847fb93f8e173dc5201d6085685d02e5bd06b42ec24b99c4985128e444ee24f91d5ae430f9fb5e7961f8cec083006d930fd7ea285378cd30ce0577eb1d4535ccc80427e027751270ababf9e5684775abd47ac230b66608d00459f67e248be8d4aeac4d93569a51b56009103fb3118a21c9f422fc676c7ae4030fb1d3b0c8dc01df2b780c0d1f91b87ef1d510044563f761b07d143dea737e1cb5452ba835c317005004a3819139edbe597b0d4fb1f9050d5fa95b7c34b82894caa34f1490d0de5b4901396b6315fa8b431ef5ff3c8cf19ffb8cdc04b27f44aa44772bcc921efd93cbf84232d560d084b54a1e2a63be4c036050c654029d16da2f8769aaced6d6eb970ddfab50a0b4ec2ce5407487e1aab77a30d70fac7c9d62bdcc5d78f8a77eefb3165ecd0e7ea5c740fc26de124e790602936c419f7bf7da1fbc7d696a914c61e1dde6bc852176389baaadafa21115dbad06878be1c03bc4a77135848145cef51e3bc039c06b65ac12d0224fd21567d352d55c866607a64002ef1396b37696f1eecaba457834a956077ed8715079eb3c569da1b0be9c5e1c9203c274a2b7c89612eaa8ac5af22e2d220cb513ade6f11c98a6f26672ce47e6cec3ae89a76ac755ea77005d27e108a61d56966e4a700745c26aaa0888c842de54489162c84845d7d62b03d39377ad328cd5391694efe65cb9884b3ff9fd78eebcf326b4492c3796a5c662a11df2eff3d8d2625cc8168af5651381e2161acd001342c7fea2af695dd3e4602b3300598e7d24830a34fe6dffdae340484e89d5be4846e34bab633a1a07383319082661e1bcd2a3f293f72ec4a03973a3a9a3b5a30ea3c20eaecbe63c1e4a513b20b279a8d8c250943248d18a038a677696de7ca8ef51889ae2ba5d7108e6d95f9e404c3d37b65a1dcfd068cbd7e1b9a03bf29742799d945b5510f589f0f7cc049f6a956464e4357a5f374979f4975ba838bb1daad2e4d7dbe215918705cad84b233dde90a82ce5367665492929e91d1a1210b7be2bb91349455cb3c1a50eb6c1f78627e2eb6d7b3a362b2591c580722547c6f2ac05ebb693cdfe6b0036ac81c61d83cc5ae24cac84e2ddfdd8fc5e87c5cf60a213297d291d0d52b1a8b7fa0f999a3bb3e04d198d969bb5d2239d2f7f69ca418f611e17aa02dee67d26b4d99be043f0eac288e5d77740431faaf4a028369e7cbd96643baa8b33716aba15f42d9596b8649ffa23292ecbf37d6334a1fa4ac16a7ada8733e5c30606bb7fd4fba81c926da602b2e1385972dd70b2ce5fedc087b626cc04139e56a7a4a99e7cbe2a1a6730e6dcd48b8a271d19f9cf1c57cf17e22cf517cc527f1a3325364daaec00fbe46d8bcb5736cba57c17cc990fd8fa01610b1cf54615ded8116488dbb2de51e07240f7290e62ad2d9799e7216a6b0c8ac4769936727a01e9ffc9da8806cb12d9aa6cdc9b3cdccd0db3bad1e263f\n  \n    \n      \n      \n        您好, 这里需要密码.\n      \n    \n  \n\n","categories":["语言"],"tags":["教程","分享","语言学习"]},{"title":"无损音乐下载收听指南 p😭q","url":"/2024/12/13/%E6%97%A0%E6%8D%9F%E9%9F%B3%E4%B9%90%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%8D%97/","content":"下载富哥实体CD直接买实体CD，再扫盘提取为数据格式即可。你问我该怎么扫盘提取？我又没钱买CD😅\n单曲购买下载示例网站： しぐれうい &#x2F; まだ雨はやまない - OTOTOY\n国内音乐平台下载花小钱充个vip下载就能解决的问题，什么？花了钱下载下来还是加密格式的，vip过期就听不了了，所以就剩下两个选择了😤\n继续花钱续费 💲花钱是解决问题的最简单方式，钱不是万能的，能直接花钱解决的问题为什么要动脑子呢？🤑\n加密音乐解锁 🧐官网解锁 👉 音乐解锁 - Unlock Music\n官网解锁有可能会解锁失败，这时候就需要用到源代码来解锁。原来的GitHub仓库因为一些神秘因素下架了，这个是官方搭建的第三方仓库。 👉 Unlock Music Project\n有条件直接进官方电报群组防丢失 👉 音乐解锁 \n解密后的音乐标签信息缺失👉 音乐标签信息\n磁力下载磁力下载的的种子来源一般为方案一的富哥流媒体购买或者扫盘提取出来的文件。\n磁力搜索磁力下载的做种的一般是为整个专辑，只要搜索专辑名称，再选择下载自己所需要的歌曲就行了\n磁力聚合搜索下载 👉 AIO Search - Search Torrents Sites\n磁力下载找到磁力链接后，尽量不要用迅雷下载，常见的 BT 客户端为以下两个：\n\nqBittorrent Enhanced：一个轻量级的磁力下载客户端，界面简洁且没有广告。\nBitComet：传统的磁力下载工具，支持多种协议。\n\n添加 tracker 👉 XIU2&#x2F;TrackersListCollection\n磁力下载的速度通常取决于资源的种子数和你的网络连接，tracker 可以帮助你链接到更多的用户\n第三方网站下载用户自发以网盘方式分享的音乐平台。代表网站👉 ACG漫音社\n数据来源为解析国内各大音乐平台，下载下来的源文件已经解密后的了。 代表网站👉 无损生活\n补充如果遇到各大平台甚至磁力资源都没有无损资源的所谓的‘失传媒体’，可以去互联网档案馆或者电报之类的地方摸摸奖\n如果懒得下载，对音质什么的也没要求，可以去淘宝之类的直接买车载音乐U盘\n收听音源判断这里我们可以使用声谱分析软件 Spek Download 进行分析，项目Github地址：alexkay&#x2F;spek: Acoustic spectrum analyser\n标准MP3声谱正常的mp3有损音频，高频段（15kHz 以上）缺失，声谱有明显的高频缺失，音源仅保留了人耳易察觉的部分\n\n无损音乐声谱\n1. 文件信息位置: F:\\Music\\jp\\しぐれうい - 鳴聖!! ロリ神レクイエム☆.flac格式: FLAC（Free Lossless Audio Codec，无损音频格式）采样率: 48,000 Hz比特深度: 24 位声道: 立体声（Channel 1&#x2F;2）窗口大小与窗函数：W:2048, F:Hann\n这些信息告诉我们，这是一首由 しぐれうい（时雨羽衣） 演唱的歌曲，采用 FLAC 编码，采样率为 48kHz，说明其高频部分理论上可以达到 24kHz（根据 Nyquist 采样定理，最高可还原 采样率&#x2F;2 的频率）。比特深度 24-bit 表示音频动态范围更大，通常用于高质量音频。分析过程中使用的 FFT 窗口大小 为 2048，使用 Hann 窗函数 进行频谱平滑处理。\n2. 频谱图基本构造X 轴（水平方向）: 时间 (0:00 - 4:33)\n\n代表音频的时间进度，从 0:00 到 4:33，即整个音频文件的时长。\n\nY 轴（垂直方向）: 频率 (0 kHz - 24 kHz)\n\n从 0 kHz（低频）到 24 kHz（高频），用于表示声音的频率范围。\n人耳的听觉范围一般在 20 Hz - 20 kHz，高于 20 kHz 的部分通常对人耳不可闻。\n\n颜色（强度）:\n\n黄色&#x2F;白色：表示信号较强（接近 0 dB），音量较高。\n红色：表示中等强度（约 -40 dB 至 -60 dB）。\n蓝色&#x2F;紫色&#x2F;黑色：表示较弱或无信号（-80 dB 以下）。\n\n3. 具体频谱分析\n低频（0 - 5 kHz）\n该部分主要包含 鼓点、贝斯、低音人声，通常是音轨的核心基础。\n这里可以看到密集的红色和黄色区域，说明有较强的低频信号。\n\n\n中频（5 - 15 kHz）\n这部分是 人声、乐器（如吉他、钢琴） 主要频率所在区域。\n这里有大量红色和紫色的区域，说明该音频文件有人声和乐器的丰富细节。\n\n\n高频（15 - 24 kHz）\n这里通常是 金属乐器、环境氛围、空气感 的频率范围。\n可以看到高频仍然有信号（紫色、红色部分），但比中低频弱，说明音频质量较高，并未因有损压缩导致高频损失。\n\n\n\n4. 结论\n音频质量\n该文件采用 FLAC 格式，无损音质，没有明显的高频削减，说明其来源质量较高。\n高频段（15kHz 以上）仍然有较多信息，没有像 MP3 等有损格式那样严重衰减，符合 48kHz 采样率的特性。\n\n\n歌曲动态\n频谱分布均衡，说明混音处理得当，保留了较多高频和低频信息。\n中高频段清晰，符合 J-POP 或 VTuber 曲风 的特点，即强调人声和电子乐器。\n\n\n\n*根据歌曲的类型不同，无损音乐的声谱也会有所差异，比如歌曲本身就是抒情慢歌，声谱断断续续的也是正常的\n\n真假无损真无损和假无损声谱对比，假无损的声谱高频采样的范围中有明显的横向截断，为人为以mp3升频假冒的无损音乐\n\n\n本地播放器推荐PC​\t个人首推的就是QQ音乐\n\n优点：桌面歌词有逐字对照，日语歌词还有片假名标识，对于语言学习有一定的帮助\n例：\n未播放色号：#F49500\n已播放色号：#00D1FE\n\n缺点：直接把你电脑当成了服务器，后台偷跑带宽，浪费流量\n\n解决方法：下载软件 NetLimiter 来对QQ音乐进行上传限制，这样就是PC最好的播放器了。老版本的下载的音乐的加密也并不严格。\n\n\n其它的比如什么 MusicPlayer2，Splayer，foobar2000 什么的个人觉得其实功能都大差不差，主要是界面的不同。\n我认为光是桌面歌词这一点QQ音乐就完胜其它播放器了，QQ音乐还会对本地歌曲和云端歌曲自动进行对照匹配，自动获取到对应歌词\nAndroid个人首推的就是 SaltPlayer 了，页面简洁美观，功能全面，非常好用。\n音乐标签信息如果你是像哥们一样有追求的人的话，对信息缺失、标签空白的歌曲难以忍受的话，可以用软件 音乐标签pc版 来添加和修正标签信息，确保每首歌都有完整的曲目信息。\n\n歌词搜索\n本地批量获取歌词： ZonyLrcToolsX\n个人自用下载命令，详情可以去看文档\n.\\ZonyLrcTools.Cli.exe download -d &quot;F:\\Music\\jp&quot; -l -n 2\n\n本地单独获取歌词： 163MusicLyrics\n输入歌曲id获取到对应的歌词，详情可以去看文档\n\n\n本地备份同步PC端直接用 FreeFileSync 即可\n\n硬件推荐鄙人只是个木耳穷哥们，下载音乐只是出于兴趣爱好，声卡小尾巴什么的感觉就是割发烧友韭菜的，烧不起烧不起，直接买原道就行了。p😭q\n佩戴舒适度：⭐⭐⭐⭐⭐\n音质：⭐⭐⭐⭐\n功能性：⭐\n性价比：⭐⭐⭐⭐⭐\n","categories":["教程"],"tags":["教程","分享","下载","资源检索"]},{"title":"Vue 学习笔记","url":"/2023/08/06/Vue/","content":"Vue介绍\nVue是一套基于MVVM设计模式用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。\nVue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\nMVVM设计模式在学习认识MVVM设计模式之前，我们先来了解下MVVM的发展历史：\n1995年，JavaScript在浏览器上首次设计实现。之后，浏览器就可以通过JavaScript，对页面进行一些修改。如操作HTML的DOM结构和修改CSS来实现一些动画效果。自此JavaScript经历了若干发展阶段：\n\n阶段一：直接用JavaScript操作DOM节点，使用浏览器提供的原生API\n阶段二：为了便捷开发并考虑浏览器兼容问题，jQuery以“write Less，Do More”宗旨迅速占领市场：\n阶段三：配合服务器端实现MVC设计模式\n现在：随着前端页面越来越复杂，用户对于交互性要求也越来越高，散乱的代码将使项目变得难以维护，仅仅用jQuery是远远不够的。MVVM模型应运而生。\n\n\nMVVM本质上就是MVC 的改进版最早由微软提出，它立足于原有MVC架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。\n\n认识MVCMVC全名是Model View Controller，是模型(model) － 视图(view) －控制器(controller) 的缩写，一种软件设计典范：\n\n在MVC中，Controller完全把Model和View进行了分离，主要的程序逻辑在Controller里实现。而且，Controller与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Controller的不变，即重用！ 不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Controller的测试–而不需要使用自动化的测试工具。 我们甚至可以在Model和View都没有完成时候，就可以通过编写Mock Object（即实现了Model和View的接口，但没有具体的内容的）来测试Presenter的逻辑。在MVC里，应用程序的逻辑主要在Controller来实现，其中的View是很薄的一层。\n在这个过程中，View是很简单的，能够把信息显示清楚就可以了。并且View绝不容许直接访问Model（注意：这个规范其实是MVP设计模式不是MVC）。\n认识MVVMMVVM全名是Model View ViewModel，是模型(model) － 视图(view) － 视图模型(view-model) 的缩写,其实 MVVM真实应该叫做MVCVM，MVVM设计模式的出现就是为了解决当今数据解析问题。\n数据解析问题:早期MVC年代前端应用的数据往往都比较简单，所以数据解析工作也非常简单。而如今前端应用功能越来越复杂，数据结构也越来越复杂，所以数据解析也就没那么简单了。\n如果我们继续按照MVC的设计思路，因为V和M层已经被明确定义不能承担数据解析功能，所以数据解析的部分只能放到了Controller里面。\n而今前端复杂数据结构也导致Controller负责数据解析后就将变得相当臃肿。并且相当重要的一点：Controller被设计出来并不是处理数据解析的：\n\n控制器从视图获取事件和输入;\n管理自己的生命周期;\n实现Controller容器;\n\n所以“数据解析”也不应该由Controller来完成。\n因为我们的MVC中，M、V、C都不应该处理数据解析。程序开发人员就专门为数据解析创建出了一个新的类：ViewModel。\n这种模式跟经典的MVC模式很相似，使用数据绑定技术为View量身定制model，这个model就是ViewModel。ViewModel包含所有由UI特定的接口和属性，并由一个 ViewModel 的视图的绑定属性，并可获得二者之间的松散耦合，所以需要在ViewModel 直接更新视图中编写相应代码。\n在MVVM中，Controller不再直接持有Model。而是由VM层直接持有Model并进行数据解析并把处理的结果给Controller。因为Controller只需要数据解析的结果而不关心过程，所以就相当于VM把“解析Model”给封装起来，而C甚至根本就不需要知道M的存在就能工作。那么MVVM中的持有关系就是：C持有VM，VM持有M\n这样Controller需要的数据由VM全权负责，所以VM层的Controller存在感被完全的降低这样MVCVM模式就被成为MVVM设计模式\nVue的安装\n方法一: 在html 文件中引入vue.js\n\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n\n\n方法二: 通过npm下载vue模块\n\nnpm install -s vue\n\n\n方法三: 通过Vue 官方脚手架 vue-cli 搭建vue组件化项目\n\n#全局安装 vue-cli 环境变量中npm install -g @vue/cli # 使用 vue-cli指令搭建单页面应用项目vue create hello-world\n\n起步实例化一个Vue对象介绍: Vue会为开发者提供一个名叫Vue的构造函数，开发人员可以通过new关键字创建Vue构造函数的实例对象（MVVM中VM层）。\n代码:\n&lt;!--引入Vue三方库--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!--创建一个DOM元素--&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;// 通过new关键字实例化一个Vue对象// Vue 构造函数接收配置对象new Vue(&#123;     el: &#x27;#app&#x27; // el 指定页面中DOM元素,Vue就会以这个DOM为挂载对象&#125;)&lt;/script&gt;\n\nVue实例配置选项\n在实例化Vue对象时，构造函数Vue可以接受一个Object作为实例配置对象，该对象中接受多个配置选项用来实现不同的效果。\n\nel: 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。挂载完毕后当前DOM内部渲染将会由当前Vue实例对象所管理与控制\nnew Vue(&#123;    el: &#x27;#app&#x27;&#125;)\n\ndata: (属性)存放当前Vue实例对象数据的配置。Vue 将会递归的将 data 的 property 转换为 getter&#x2F;setter，从而让 data 的 property 能够响应数据变化。\n\n对象必须是纯粹的对象 (含有零个或多个的 key&#x2F;value 对): 浏览器 API 创建的原生对象，原型上的 property 会被忽略。大概来说，data 应该只能是数据，不推荐观察拥有状态行为的对象。\n\n注意: data 对象自身可以被实例对象的$data属性所访问,并且在所有data直接子属性都可以被实例对象直接访问和修改。\nvar vm = new Vue(&#123;                    el: &#x27;#app&#x27;,                    data: &#123;                            name: &#x27;小明&#x27;,                            age: 18,                            detail: &#123;                                     tel: 138121345678,                            eMail: &#x27;helloworld@163.com&#x27;,                            address: &#x27;广州&#x27;        &#125;    &#125;,    mounted() &#123;        console.log(this.age)  // 18 实例对象可以直接访问    &#125;&#125;)vm.$data // data对象vm.age //18 等价于 vm.$data.agevm.detail.tel //138121345678 vm.$data.detail.tel // 实例对象的方法可以直接修改// 并且vm的data数据改变会引起页面的自动更新（数据的双向绑定）vm.age++ vm.detail.tel = 13193870000\n\n数据绑定技术概念: Vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的,Vue在初始化使用Object.defineProperty递归的将data的属性添加一个getter&#x2F;setter (监听器Observer)，用来劫持并监听所有属性（Vue 解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器即调用当前属性getter方法的元素就是订阅者）。Vue会把所有当前data的订阅者存放在一个dep名单中，如果有变动的，就通过dep名单通知所有订阅者。从而更新视图。\n\n模板语法双大括号文本差值概念: Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：vue使用 &#123;&#123;js表达式&#125;&#125; (双大括号语法) 将实例中的属性或者其他js表达式插值绑定到模板的任何文本节点中\n语法：\n&lt;div id=&quot;app&quot;&gt;        内部都由Vue实例对象管理         &lt;p&gt;姓名:&#123;&#123;name&#125;&#125;&lt;/p&gt;        &lt;p&gt;年龄:&#123;&#123;age&#125;&#125;&lt;/p&gt;    &lt;p&gt;状态:&#123;&#123;age &gt;= 18 ? &#x27;已成年&#x27;:&#x27;未成年&#x27;&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                name: &#x27;小明&#x27;,                age: 18            &#125;        &#125;)&lt;/script&gt;\n\n注意:双大括号语法会将内部的表达式以纯文本的形式插入到对应节点内部。这种模式可以预防xss攻击（注入攻击将一段恶意脚本发送到html页面从而获取用户的cookie信息）\n&lt;div id=&quot;app&quot;&gt;        &lt;p&gt;&#123;&#123;script&#125;&#125;&lt;/p&gt;         // 这里渲染的结果是&#x27;&lt;div&gt;hello world&lt;div&gt;&#x27;的文本节点,而不是一个dom元素&lt;/div&gt;&lt;script&gt;       let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                script: &#x27;&lt;div&gt;hello world&lt;div&gt;&#x27;            &#125;        &#125;)&lt;/script&gt;\n\n指令语法\n概念: Vue为开发者提供很多执行应用在虚拟DOM标签上以实现不同的效功能效果\n语法: 指令&#x3D;“js表达式”\n\n\n指令 v-html\n\n介绍: 可以将文本以html形式插入到指定节点内部而不用向上面一样插入一个纯文本。\n注意: 永远不要把这个方法暴露给用户\n&lt;div id=&quot;app&quot;&gt;        &lt;p&gt;&#123;&#123;script&#125;&#125;&lt;/p&gt;   // 纯文本        &lt;div v-html=&quot;script&quot;&gt;&lt;/div&gt; // h3dom元素&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                script: &#x27;&lt;h3&gt;hello world&lt;/h3&gt;&#x27;            &#125;        &#125;)&lt;/script&gt;\n\n\n指令 v-once\n\n介绍: 一次性地插值，当数据改变时，插值处的内容不会更新\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-once=&quot;str&quot;&gt;&lt;/p&gt;   // v-once插入的文本内容不会更新&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                str: &#x27;hello world&#x27;            &#125;        &#125;)setTimeout(() =&gt; vm.str = &#x27;hello Vue !&#x27;)     &lt;/script&gt;\n\nv-bind属性差值概念: 使用指令 v-bind:属性 &#x3D;“js表达式” 形式将实例中的data或者其他js表达式插值绑定到标签的任何属性节点中\n语法:\n&lt;div id=&quot;app&quot;&gt;   已成年&lt;input type=&quot;radio&quot; v-bind:checked=&quot;age &gt;= 18&quot;/&gt;   未成年&lt;input type=&quot;radio&quot; v-bind:checked=&quot;age &lt; 18&quot;/&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                age: 18,            &#125;        &#125;)&lt;/script&gt;\n\n注意:\n\nv-bind:指令可以简写成一个冒号 “:”\n\n&lt;div id=&quot;app&quot;&gt;   已成年&lt;input type=&quot;radio&quot; :checked=&quot;age &gt;= 18&quot;/&gt;   未成年&lt;input type=&quot;radio&quot; :checked=&quot;age &lt; 18&quot;/&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                age: 18,            &#125;        &#125;)&lt;/script&gt;\n\n\nv-bind 支持动态属性\n\n&lt;div id=&quot;app&quot;&gt;   &lt;a v-bind:[attrname]=&quot;link&quot;&gt; 百度 &lt;/a&gt;   &lt;!-- &lt;a src=&quot;http://www.baidu.com&quot;&gt; 百度 &lt;/a&gt; --&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                attrname: &#x27;src&#x27;,                link: &#x27;http://www.baidu.com&#x27;            &#125;        &#125;)&lt;/script&gt;\n\n\n注意:\n\n动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。\n空格和引号，放在 HTML attribute 名里是无效的\n\n&lt;a v-bind:[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt; // 错误\nv-bind绑定class1. 对象语法我们观察下面代码,我们给每一段歌词元素都绑定了一个class类。内部js表达式逻辑就是当currentIndex 与歌词下标匹配时，歌词元素的class值就会变成active，否则为空。但是我们发现，代码过于繁琐。Vue针对class提供对象语法来简化下面的代码\n&lt;div id=&quot;app&quot;&gt;        &lt;p v-bind:class=&quot;currentIndex === 0 ? &#x27;active&#x27;: &#x27;&#x27;&quot;&gt;            第一段歌词 0        &lt;/p&gt;        &lt;p v-bind:class=&quot;currentIndex === 1 ? &#x27;active&#x27;: &#x27;&#x27;&quot;&gt;            第二段歌词 1        &lt;/p&gt;        &lt;p v-bind:class=&quot;currentIndex === 2 ? &#x27;active&#x27;: &#x27;&#x27;&quot;&gt;            第三段歌词 2        &lt;/p&gt;        &lt;p v-bind:class=&quot;currentIndex === 3 ? &#x27;active&#x27;: &#x27;&#x27;&quot;&gt;            第四段歌词 3        &lt;/p&gt;        &lt;p v-bind:class=&quot;currentIndex === 4 ? &#x27;active&#x27;: &#x27;&#x27;&quot;&gt;            第五段歌词 4        &lt;/p&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;                el: &#x27;#app&#x27;,                data: &#123;                    currentIndex: 3                &#125;           &#125;)&lt;/script&gt;\n\nv-bind绑定的class支持对象写法: v-bind:class = &#123;class名: 判别式&#125;。当判别式为真时,保留该类名否则删除该类名\n上面的代码可以使用class对象语法简写为\n&lt;div id=&quot;app&quot;&gt;   &lt;p v-bind:class=&quot;&#123;active: currentIndex === 0&#125;&quot;&gt;第一段歌词 0&lt;/p&gt;   &lt;p v-bind:class=&quot;&#123;active: currentIndex === 1&#125;&quot;&gt;第二段歌词 1&lt;/p&gt;   &lt;p v-bind:class=&quot;&#123;active: currentIndex === 2&#125;&quot;&gt;第三段歌词 2&lt;/p&gt;   &lt;p v-bind:class=&quot;&#123;active: currentIndex === 3&#125;&quot;&gt;第四段歌词 3&lt;/p&gt;   &lt;p v-bind:class=&quot;&#123;active: currentIndex === 4&#125;&quot;&gt;第五段歌词 4&lt;/p&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;                        el: &#x27;#app&#x27;,                  data: &#123;                     currentIndex: 3                  &#125;         &#125;)&lt;/script&gt;\n\n2. 数组语法概念: Vue还支持v-bind:class=数组写法,数组中的每一项都可以是js表达式,并且数组中可以包含class对象写法\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-bind:class=&quot;currentIndex === 0 ? &#x27;active lry &#x27; + className: &#x27;lry &#x27;+ className&quot;&gt;        第一段歌词 0    &lt;/p&gt;    &lt;p v-bind:class=&quot;[&#123;active: currentIndex === 1&#125;, &#x27;lry&#x27;, className]&quot;&gt;        第二段歌词 1    &lt;/p&gt;    &lt;p v-bind:class=&quot;[&#123;active: currentIndex === 2&#125;, &#x27;lry&#x27;, className]&quot;&gt;        第三段歌词 2    &lt;/p&gt;    &lt;p v-bind:class=&quot;[&#123;active: currentIndex === 3&#125;, &#x27;lry&#x27;, className]&quot;&gt;        第四段歌词 3    &lt;/p&gt;    &lt;p v-bind:class=&quot;[&#123;active: currentIndex === 4&#125;, &#x27;lry&#x27;, className]&quot;&gt;        第五段歌词 4    &lt;/p&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;                        el: &#x27;#app&#x27;,            data: &#123;                currentIndex: 3,                className: &#x27;test&#x27;            &#125;        &#125;)&lt;/script&gt;\n\n\n\n\n注意:\n\nclass 的数组语法,对象语法中的数组或对象都可以存放data中绑定给class (data中不要使用this)\n一个dom元素中可以最对同时拥有 一个绑定的class属性和一个普通class属性\n\n&lt;p v-bind:class=&quot;[&#123;active: currentIndex === 3&#125;, &#x27;lry&#x27;, className]&quot;&gt;   第四段歌词 3&lt;/p&gt;&lt;p class=&quot;lry&quot; v-bind:class=&quot;[&#123;active: currentIndex === 4&#125;, className]&quot;&gt;   第五段歌词 4&lt;/p&gt;\nv-bind绑定style1. 对象语法概念: v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名。\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 短横线命名CSS样式需要加引号--&gt;    &lt;p v-bind:style=&quot;&#123;color,backgroundColor,&#x27;font-size&#x27;: &#x27;18px&#x27;&#125;&quot;&gt;        我是一段文本    &lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123;           el: &#x27;#app&#x27;,           data: &#123;                   color: &#x27;blue&#x27;,                   backgroundColor: &#x27;orange&#x27;          &#125;    &#125;)&lt;/script&gt;\n\n2. 数组语法概念: v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-bind:style=&quot;[defaultStyle,&#123;color,backgroundColor,fontSize: &#x27;18px&#x27;&#125;]&quot;&gt;        我是一段文本    &lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123;        el: &#x27;#app&#x27;,       data: &#123;                color: &#x27;blue&#x27;,                backgroundColor: &#x27;orange&#x27;,                defaultStyle: &#123;                                fontWeight: 700,                                border: &#x27;1px solid #ccc&#x27;                &#125;    &#125;&#125;)&lt;/script&gt;\n\n3.v-bind:style的多重值概念: style 绑定中的样式属性可以提供一个包含多个值的数组，常用于提供多个带前缀的值。\n&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;\n\n\n这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。\n\n4.v-bind:style自动添加前缀概念: 当v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀。\n&lt;div :style=&quot;&#123;  transform: &#x27;rotate(-45deg)&#x27; &#125;&quot;&gt;Hello&lt;/div&gt;\n\n事件处理概念: 在vue中可以给DOM元素通过 v-on 指令,绑定事件处理逻辑。\n语法: v-on:事件名=&quot;js表达式&quot;\n &lt;div id=&quot;app&quot;&gt;     每次点击h2标签 count都会加一     &lt;h2 v-on:click=&quot;count++&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                count: 17            &#125;        &#125;)&lt;/script&gt;\n\n注意: 不应该使用箭头函数来定义 method 函数 (例如 plus: () &#x3D;&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。\n扩展: v-on: 指令可以简写为 @ 符号\n&lt;div id=&quot;app&quot;&gt;   &lt;h2 v-on:click=&quot;count++&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/h2&gt;   &lt;button @click=&quot;count--&quot;&gt;minus&lt;/button&gt;&lt;/div&gt; &lt;script&gt;    new Vue(&#123;         el: &#x27;#app&#x27;,         data: &#123;             count: 17            &#125;        &#125;)&lt;/script&gt;\n\nVue实例配置methods选项在学习Vue事件绑定函数之前，我们需要学习如何在Vue实例中创建实例对象自身的方法函数。创建Vue实例对象的方法同样需要通过Vue实例配置选项来创建。\nmethods实例配置选项语法：&#123; [key: string]: Function &#125;\n介绍：methods配置对象将被混入到 Vue 实例中作为当前实例的方法。 VM 实例可以直接访问该对象内的方法，或者在指令表达式中使用他们。methods对象中的方法的 this 会自动绑定为 Vue 实例。\n&lt;!-- 在指令表达式中使用--&gt;&lt;div id=&#x27;app&#x27;&gt;&#123;&#123;reverseStr()&#125;&#125;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123;  el: &#x27;#app&#x27;,    data: &#123;           a: 1 ,           str: &#x27;hello world&#x27;        &#125;,  methods: &#123;    addA: function () &#123;      this.a++    &#125;,    reverseStr() &#123; // ES6写法       return this.str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)    &#125;  &#125;&#125;)vm.addA() // 通过Vue实例对象直接访问methods内部的方法vm.a // 2&lt;/script&gt;\n\nVue事件绑定函数介绍: 在Vue的v-on事件绑定语法,支持将函数作为js表达式绑定到监听事件中。当目标元素的事件被触发时绑定的函数将会被执行。\n注意:\n\nv-on事件绑定中js表达式传入函数，函数名后不显式添加()会被vue隐式默认添加(),并且会默认的将event原生事件对象作为参数传入到函数中\n\n&lt;div id=&quot;app&quot;&gt;&lt;!--     被点击会打印undefined,因为函数显示被调用并没有向函数内部传递任何参数--&gt;    &lt;button @click=&quot;clickHandel()&quot;&gt;click me&lt;/button&gt;&lt;!--     被点击会打印事件对象event,vue会隐式调用该函数并传递event作为当前函数的参数--&gt;    &lt;button @click=&quot;clickHandel&quot;&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            methods: &#123;                clickHandel(event) &#123;                    console.log(event)                &#125;            &#125;        &#125;)&lt;/script&gt;\n\n\n如果需要在事件绑定函数中不但手动传参还要传递event事件对象,需要使用vue实例对象提供的特殊变量 $event ,将事件对象手动传递给函数内部\n\n&lt;div id=&quot;app&quot;&gt;     // 向函数手动传递参数 $event是vue所提供的当前原生事件对象特殊变量      &lt;button @click=&quot;clickHandel($event,12)&quot;&gt;click me&lt;/button&gt; &lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            methods: &#123;                clickHandel(event,num) &#123;                    console.log(event,num)                &#125;            &#125;        &#125;)&lt;/script&gt;\n\n修饰符概念: 在事件处理程序中用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。简化上面这种DOM事件细节需求\n语法: v-on:事件名.修饰符1.修饰符2...\n事件修饰符.stop 阻止事件冒泡\n&lt;div id=&quot;app&quot;&gt;    &lt;div :style=&quot;&#123;width: &#x27;200px&#x27;,height: &#x27;200px&#x27;,backgroundColor: &#x27;red&#x27;&#125;&quot; @click=&quot;clickHandle($event,&#x27;div&#x27;)&quot;&gt;        &lt;p :style=&quot;&#123;width: &#x27;120px&#x27;,height: &#x27;120px&#x27;,backgroundColor: &#x27;green&#x27;&#125;&quot;           @click.stop=&quot;clickHandle($event,&#x27;p&#x27;)&quot;&gt;            &lt;a @click.stop=&quot;clickHandle($event,&#x27;a&#x27;)&quot;&gt;我是A标签&lt;/a&gt;        &lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;    &lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            methods: &#123;                clickHandle(event, detail) &#123;                    console.log(detail + &#x27;被点击了&#x27;, event.target)                &#125;            &#125;        &#125;)    &lt;/script&gt;\n\n.prevent 阻止事件浏览器默认行为\n&lt;form&gt;    &lt;input @click.prevent=&quot;clickHandle($event,&#x27;submit&#x27;)&quot; type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n.capture 事件使用捕获\n&lt;div :style=&quot;&#123;width: &#x27;200px&#x27;,height: &#x27;200px&#x27;,backgroundColor: &#x27;red&#x27;&#125;&quot;      @click.capture=&quot;clickHandle($event,&#x27;div&#x27;)&quot;&gt;    &lt;p :style=&quot;&#123;width: &#x27;120px&#x27;,height: &#x27;120px&#x27;,backgroundColor: &#x27;green&#x27;&#125;&quot;       @click.capture=&quot;clickHandle($event,&#x27;p&#x27;)&quot;&gt;         &lt;a @click=&quot;clickHandle($event,&#x27;a&#x27;)&quot;&gt;我是A标签&lt;/a&gt;    &lt;/p&gt;&lt;/div&gt;\n\n.self event.target必须是绑定事件的元素自身才能触发\n&lt;div :style=&quot;&#123;width: &#x27;200px&#x27;,height: &#x27;200px&#x27;,backgroundColor: &#x27;red&#x27;&#125;&quot;      @click=&quot;clickHandle($event,&#x27;div&#x27;)&quot;&gt;    &lt;p :style=&quot;&#123;width: &#x27;120px&#x27;,height: &#x27;120px&#x27;,backgroundColor: &#x27;green&#x27;&#125;&quot;       @click.self=&quot;clickHandle($event,&#x27;p&#x27;)&quot;&gt;        &lt;a @click=&quot;clickHandle($event,&#x27;a&#x27;)&quot;&gt;我是A标签&lt;/a&gt;    &lt;/p&gt;&lt;/div&gt;\n\n.once 事件只触发一次\n&lt;div :style=&quot;&#123;width: &#x27;200px&#x27;,height: &#x27;200px&#x27;,backgroundColor: &#x27;red&#x27;&#125;&quot;      @click=&quot;clickHandle($event,&#x27;div&#x27;)&quot;&gt;   &lt;p :style=&quot;&#123;width: &#x27;120px&#x27;,height: &#x27;120px&#x27;,backgroundColor: &#x27;green&#x27;&#125;&quot;      @click.self.stop.once=&quot;clickHandle($event,&#x27;p&#x27;)&quot;&gt;       &lt;a @click=&quot;clickHandle($event,&#x27;a&#x27;)&quot;&gt;我是A标签&lt;/a&gt;   &lt;/p&gt;&lt;/div&gt;\n\n.passive 提高移动端scroll事件滑动性能的修饰符,该修饰符不能与 .prevent 一起使用\n&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成  --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;\n\n按键修饰符概念: 在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符\n修饰符种类:\n\nKeyboardEvent.key修饰符\n\n介绍: Vue支持 键盘事件中每个键的key按键名转换为 kebab-case 来作为修饰符。\n语法v: -on:事件名.[event.key]\n// 按键盘page down键触发&lt;textarea @keyup.page-down=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;// 按键盘a触发&lt;textarea @keyup.a=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;// 按键盘a或者s触发&lt;textarea @keyup.a.s=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;\n\n注意: 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名\n\n\n\n修饰符\n描述\n\n\n\n.enter\n回车键\n\n\n.tab\nTab键\n\n\n.delete\n捕获“删除”和“退格”键\n\n\n.esc\nESC键\n\n\n.space\n空格键\n\n\n.up\n方向键上\n\n\n.down\n方向键下\n\n\n.left\n方向键左\n\n\n.right\n方向键右\n\n\n\n系统修饰键\n\n介绍: 系统修饰键可以配合其他按键一起按下相应按键时才触发鼠标或键盘事件的监听器。\n语法: v-on:事件名.系统修饰键.[event.key]\n\n\n\n修饰符\n描述\n\n\n\n.ctrl\nctrl键\n\n\n.alt\nalt键\n\n\n.shift\nshift键\n\n\n.meta\n在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。\n\n\n// 在按下shift键后再按其他键才会触发&lt;textarea @keyup.shift=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;// 在按下shift键后按a键才会触发&lt;textarea @keyup.shift.a=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;// 在按下shift键ctrl键后再按a键才会触发&lt;textarea @keyup.shift.ctrl.a=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;\n\n注意: vue在2.5.0 新增 .exact\n介绍: 修饰符(严格修饰符),该修饰符的功能是,严格控制系统修饰键按压\n// 非严格模式下在按下shift键ctrl键后再按a键也会触发&lt;textarea @keyup.shift.a=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;// 严格模式下在按下shift键ctrl键后再按a键不会触发// 只有仅按shift键没有按下其他系统修饰键的情况下按a才会触发&lt;textarea @keyup.shift.a.exact=&quot;keyUpHandle&quot;&gt;&lt;/textarea&gt;\n\n\n鼠标按钮修饰符\n\n概念: 鼠标修饰符会限制处理函数仅响应特定的鼠标按钮。\n\n\n\n修饰符\n描述\n\n\n\n.left\n鼠标左键\n\n\n.right\n鼠标右键\n\n\n.middle\n鼠标中间滚轮键\n\n\n条件渲染指令 v-if概念: 允许使用 v-if &#x2F; v-else &#x2F; v-else-if 控制元素的渲染语法: &lt;元素 v-if=&quot;判别式&quot; /&gt;\n&lt;div id=&quot;app&quot;&gt;        &lt;div             :style=&quot;&#123;width: &#x27;100px&#x27;,height: &#x27;100px&#x27;, backgroundColor: &#x27;red&#x27;&#125;&quot;            v-if=&quot;show&quot;        &gt;&lt;/div&gt;        &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;&lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                show: true            &#125;        &#125;)&lt;/script&gt;\n\n\n\n语法: &lt;元素1 v-if=&quot;判别式&quot; /&gt; &lt;元素2 v-else /&gt;\n&lt;div id=&quot;app&quot;&gt;       &lt;div            :style=&quot;&#123;width: &#x27;100px&#x27;,height: &#x27;100px&#x27;, backgroundColor: &#x27;red&#x27;&#125;&quot;           v-if=&quot;show&quot;       &gt;白天&lt;/div&gt;       &lt;!--v-if元素 与 v-else元素之间除了空行和注释以外不能有其他元素否则会报错--&gt;       &lt;div :style=&quot;&#123;width: &#x27;100px&#x27;,height: &#x27;100px&#x27;, backgroundColor: &#x27;#ccc&#x27;&#125;&quot; v-else&gt;           晚上       &lt;/div&gt;       &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;   &lt;/div&gt;   &lt;script&gt;       new Vue(&#123;           el: &#x27;#app&#x27;,           data: &#123;               show: true           &#125;       &#125;)   &lt;/script&gt;\n\n语法: &lt;元素1 v-if=&quot;判别式&quot; /&gt; &lt;元素2 v-else-if=&quot;判别式&quot; /&gt; ... &lt;元素n v-else /&gt;\n&lt;div id=&quot;app&quot;&gt;    &lt;!--注意v-if v-else-if v-else元素之间除了空行和注释以外不能有其他任何节点--&gt;  &lt;div v-if=&quot;score &gt; 90&quot;&gt;    优秀  &lt;/div&gt;  &lt;div v-else-if=&quot;score &gt;= 85&quot;&gt;    良好  &lt;/div&gt;  &lt;div v-else-if=&quot;score &gt;= 60&quot;&gt;     及格  &lt;/div&gt;  &lt;div v-else&gt;    不及格  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                score: 50            &#125;        &#125;)&lt;/script&gt;\n\n指令 v-show概念: 允许使用 v-show 控制元素的显示隐藏\n语法: v-show=&quot;判别式&quot;\n&lt;div id=&quot;app&quot;&gt;    &lt;div v-show=&quot;show&quot; style=&quot;width: 100px;height: 100px;background-color: red;&quot;&gt;show&lt;/div&gt;    &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                show: true            &#125;        &#125;)&lt;/script&gt;\n\n注意:\n\nv-if指令实现元素的隐藏是直接将该元素从DOM节点中删除,而v-show隐藏元素只是设置了元素的display: none属性并没有把元素从DOM节点中移除。因为上面的特性在开发中需要频繁显示隐藏的元素请使用v-show，而只需显示一次的元素请使用v-if\nVue 会尽可能高效地渲染元素，通常在使用v-if切换元素时， 会复用已有元素而不是从头开始渲染，下面的例子中元素切换并没有真的卸载掉上一个表单元素重新安装，而是复用了该元素只是修改其placeholder的属性值，在下面的的代码中切换 show 将不会清除用户已经输入到表单的内容\n\n&lt;div id=&quot;app&quot;&gt;    &lt;!--请在表单元素中输入内容后切换元素查看效果--&gt;    &lt;input v-if=&quot;show&quot; placeholder=&quot;请输入密码&quot;&gt;    &lt;input v-else placeholder=&quot;请输入验证码&quot;&gt;     &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                show: true            &#125;        &#125;)&lt;/script&gt;\n\n\nVue提供了一个key属性来表示元素的独立性,简单来说key属性的值是一个字符串。只有在兄弟元素（同一个if语句，同一个循环的同级元素）中key属性相同的元素才可以互相复用。下面的代码中 两个兄弟表单元素因为key属性不同不能互相复用。所以在元素切换时上一个表单元素会被卸载，重新渲染新的表单元素\n\n&lt;div id=&quot;app&quot;&gt;     &lt;!--请在表单元素中输入内容后切换元素查看效果--&gt;     &lt;input key=&quot;1&quot; v-if=&quot;show&quot; placeholder=&quot;请输入密码&quot;&gt;     &lt;input key=&quot;2&quot; v-else placeholder=&quot;请输入验证码&quot;&gt;      &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                show: true            &#125;        &#125;)&lt;/script&gt;\n\n列表渲染指令 v-for概念: Vue可以使用户v-for遍历数组或者对象循环渲染多个相同DOM节点\n语法: v-for=&quot;item in &lt;Array&gt;&quot; item为数组每一项的值\n &lt;div id=&quot;app&quot;&gt;     &lt;ul&gt;    &lt;li v-for=&quot;item in arr&quot; :key=&quot;item&quot; :class=&quot;&#x27;item-&#x27;+item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;    &lt;/ul&gt; &lt;/div&gt; &lt;script&gt;   new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]        &#125;  &#125;)&lt;/script&gt;\n\n\n\n语法: v-for=&quot;(item, index) in &lt;Array&gt;&quot; item为数组每一项的值，index为对应项的下标\n&lt;div id=&quot;app&quot;&gt;        &lt;ul&gt;            &lt;li v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot; :class=&quot;&#x27;item-&#x27;+index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]            &#125;        &#125;)&lt;/script&gt;\n\n\n\n语法: v-for=&quot;value in &lt;Object&gt;&quot; value为数组每一项键值对的value值\n&lt;div id=&quot;app&quot;&gt;        &lt;ul&gt;           &lt;li v-for=&quot;val in obj&quot; :key=&quot;val&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/li&gt;        &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;               obj: &#123;                   name: &#x27;小明&#x27;,                   age: 19,                   address: &#x27;深圳&#x27;               &#125;            &#125;        &#125;)&lt;/script&gt;\n\n语法: v-for=&quot;（value，key） in &lt;Object&gt;&quot; value为数组每一项键值对的value值，key为对应键值对的键名\n&lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;        &lt;li v-for=&quot;(val,key) in obj&quot; :key=&quot;key&quot;&gt;&#123;&#123;key&#125;&#125;:&#123;&#123;val&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;               obj: &#123;                   name: &#x27;小明&#x27;,                   age: 19,                   address: &#x27;深圳&#x27;               &#125;            &#125;        &#125;)&lt;/script&gt;\n\n语法: v-for=&quot;（value, name, index） in &lt;Object&gt;&quot; value为数组每一项键值对的value值，key为对应键值对的键名，index为对应键值对的下标\n&lt;div id=&quot;app&quot;&gt;      &lt;ul&gt;         &lt;li v-for=&quot;(val,key,index) in obj&quot; :key=&quot;index&quot; :class=&quot;&#x27;item-&#x27;+index&quot;&gt;&#123;&#123;key&#125;&#125;:&#123;&#123;val&#125;&#125;&lt;/li&gt;      &lt;/ul&gt;  &lt;/div&gt;  &lt;script&gt;      new Vue(&#123;          el: &#x27;#app&#x27;,          data: &#123;             obj: &#123;                 name: &#x27;小明&#x27;,                 age: 19,                 address: &#x27;深圳&#x27;             &#125;          &#125;      &#125;)  &lt;/script&gt;\n\n注意: 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态(当前列表不会增加,删除,更新顺序)。解决方法，为每一个使用v-for遍历出来的DOM节点添加一个唯一key属性，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素\n\n建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。key属性不需要做到全局唯一，只需要同一个循环遍历的兄弟元素之间不同就好了\n\n注意: 数组排列或者删除的操作请谨慎使用index作为key,index无论怎么删除下标永远都是从0 到 n,导致会删除掉错误dom节点\n更新检测概念: Vue数据双向绑定的原理是在vue实例初始化时递归的给所有的对象属性绑定getter&#x2F;setter方法,这样导致了两个问题:\n1. 数组的更新，介绍: 数组的每一项不会被vue递归的绑定get&#x2F;set，所以在vue中数组通过下标添加或者修改值的时候不会引起页面更新。\n注意: Vue 的数组都被做了特殊处理，其中的 push() pop() shift() unshift() splice() sort() reverse()方法,都被进行了包裹二次封装(不是原生js方法)，所以调用上面的方法将会触发视图更新\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;&lt;/div&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                arr: [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]            &#125;&#125;)vm.arr[1] = &#x27;AAA&#x27;  // 页面不会更新vm.arr[4] = &#x27;e&#x27; // 页面不会更新\n\n\n\n可以引起数组更新视图的方法有三种:\n\n方法一: 调用上面说的数组中的方法\n方法二: 使用新数组替换旧数组\n方法三: 使用vm.$set 或者Vue.set方法修改数组指定下标的值\n\n语法: vm.$set(数组,index,val) 或者 Vue.set(数组,index,value)\nlet vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]            &#125;        &#125;)/*vm.arr[1] = &#x27;AAA&#x27; // 页面不会更新vm.arr[4] = &#x27;e&#x27; // 页面不会更新*/Vue.set(vm.arr, 1, &#x27;CCCC&#x27;) // 页面会更新vm.$set(vm.arr, 4,&#x27;eee&#x27;)// 页面会更新\n\n2. 对象的更新介绍: 因为在Vue初始化时对象中的所有属性都被添加了get&#x2F;set,所以对象可以直接通过属性名修改就会引起页面的更新,但是如果在Vue实例化之后给某个对象添加新的属性,这个属性将不包含get&#x2F;set方法。增加新属性或修改这个新属性就不会引起页面更新。\n给对象添加新属性并引起页面更新的方法有两种:\n\n方法一: 新对象替换旧对象\n方法二: vm.$set &#x2F; Vue.set 添加新属性,自动给新属性绑定get set方法\n\n语法: Vue.set(对象,&#39;键名&#39;,属性值) 或者 vm.$set(对象,&#39;键名&#39;,属性值)\n&lt;div id=&quot;app&quot;&gt;    &lt;p v-for=&quot;(val,key) in obj&quot; :key=&quot;key&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                obj: &#123;                    name: &#x27;老李&#x27;,                    age: 18                &#125;            &#125;        &#125;)vm.$set(vm.obj, &#x27;address&#x27;, &#x27;深圳&#x27;)  // 页面会更新        vm.$set(vm.obj, &#x27;address&#x27;, &#x27;广州&#x27;)  // 页面会更新     vm.obj.address = &#x27;佛山&#x27; //address 自动添加get set 页面会更新     Vue.set(vm.obj, &#x27;hobby&#x27;, &#x27;吃肉&#x27;) // 页面会更新&lt;/script&gt;\n\n注意：Vue.set / vm.$set只可以给data中的Object对象属性添加新属性,不可以给vm.$data对象自身添加新属性,但可以修改vm.$data已声明属性。\nvar vm = new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;        a: 1 ,        str: &#x27;hello world&#x27;    &#125;&#125;)vm.$set(vm.$data,&#x27;a&#x27;, 2) // 正确， 可以使用set方法修改data对象已有属性vm.$set(vm.$data, &#x27;test&#x27;, 10086) // 错误, 不可以使用set方法向data对象添加新属性\n\n\n错误信息: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.\n避免在运行时向Vue实例或其根$data添加新性属性,请在data选项中预先声明。即请将data中可能用到的属性在初始化时预先声明。data对象不支持实例化后添加新属性。\n\n动画过渡单一元素&#x2F;组件的过渡概念：Vue 在元素显示隐藏时， 提供了 transition 的封装组件，可以给任何元素和组件添加进入&#x2F;离开过渡\n语法：&lt;transition name=&quot;过渡css名&quot;&gt;单一标签&lt;/transition&gt;\n\n被transition标签包裹的元素在其显示隐藏时,六个不同的阶段会自动添加6个class名:\n元素进入的第一帧 [transition name 属性]-enter\n元素进入中 [transition name 属性]-enter-active\n元素进入的最后一帧 [transition name 属性]-enter-to\n元素离开的第一帧 [transition name 属性]-leave\n元素离开中 [transition name 属性]-leave-active\n元素离开的最后一帧 [transition name 属性]-leave-to\n\n&lt;div id=&quot;app&quot;&gt;        &lt;!--        被transition标签包裹的元素在其显示隐藏时,六个不同的阶段会自动添加6个class名        元素进入的第一帧  [transition name 属性]-enter        元素进入中        [transition name 属性]-enter-active        元素进入的最后一帧 [transition name 属性]-enter-to        元素离开的第一帧   [transition name 属性]-leave        元素离开中        [transition name 属性]-leave-active        元素离开的最后一帧 [transition name 属性]-leave-to        --&gt;    &lt;transition name=&quot;fade&quot;&gt;      &lt;div class=&quot;box&quot; v-if=&quot;show&quot;&gt;&lt;/div&gt;    &lt;/transition&gt;    &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                show: true            &#125;        &#125;)&lt;/script&gt;    &lt;style&gt;        .box &#123;            width: 100px;            height: 100px;            background-color: green;        &#125;        .fade-enter,  .fade-leave-to&#123;            /*元素进入动画第一帧 类名*/            opacity: 0;            transform: translateX(300px);            width: 0;            height: 0;        &#125;        .fade-enter-active, .fade-leave-active &#123;            /*元素进入整个过程中 类名*/            transition: all .5s linear;        &#125;        .fade-enter-to, .fade-leave &#123;            /*元素进入动画最后一帧 类名*/            opacity: 1;            transform: translateX(0);            width: 100px;            height: 100px;        &#125;&lt;/style&gt;\n\n注意:\n\ntransition 标签内只能包含一个直接子元素\ntransition 标签的name属性可以省略, 省略后元素进入离开时类名默认使用v-开头,例: v-enter v-enter-to v-leave v-leave-to。\n\n列表的进入&#x2F;离开过渡概念: 因为transition标签内部只能监听单个节点,或同一时间渲染多个节点中的一个。所以transition标签内部无法监听多个节点的。所以vue提供了 &lt;transition-group&gt; 组件实现内部监听多个节点的进入离开\n语法: &lt;transition-group name=&quot;过渡css名&quot;&gt;多个标签&lt;/transition-group&gt;\n&lt;div id=&quot;app&quot;&gt;    &lt;transition-group name=&quot;fade&quot;&gt;              &lt;p v-for=&quot;c in arr&quot; :key=&quot;c&quot;&gt;&#123;&#123;c&#125;&#125;&lt;/p&gt;    &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt;        let vm = new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]            &#125;        &#125;)&lt;/script&gt;&lt;style&gt;        .fade-enter,         .fade-leave-to &#123;            transform: translateX(100px);        &#125;        .fade-enter-active,         .fade-leave-active &#123;            transition: all .5s linear;        &#125;        .fade-enter-to,         .fade-leave &#123;            transform: translateX(0);        &#125;&lt;/style&gt;\n\n注意：\n\n在transition-group组价中，列表渲染的key不能使用index。index作为key在添加或者删除时会导致不是正确的DOM节点被移除\n\n&lt;!--请观察下面代码,我们在使用 transition-group 元素时内部兄弟节点使用数组每一项的值作为key &#x27;:key=&quot;c&quot;&#x27; (因为key值必须唯一所以请不要让数组中包含相同的值),这时请尝试添加或删除数组中的某一项,你胡发现动画效果是正确的但是如果我们使用数组下标作为key后,元素的添加或删除动画会异常--&gt;&lt;div id=&quot;app&quot;&gt;    &lt;transition-group name=&quot;fade&quot;&gt;        &lt;p v-for=&quot;(c,i) in arr&quot; :key=&quot;i&quot;&gt;            &#123;&#123;c&#125;&#125;            &lt;button @click=&quot;removeArr(c)&quot;&gt;remove&lt;/button&gt;        &lt;/p&gt;     &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt;    let vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            arr: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]        &#125;,        methods: &#123;            removeArr(c) &#123;                this.arr = this.arr.filter(a =&gt; a !== c)            &#125;        &#125;    &#125;)&lt;/script&gt;&lt;style&gt;    .fade-enter,    .fade-leave-to &#123;        transform: translateX(100px);    &#125;    .fade-enter-active,    .fade-leave-active &#123;        transition: all .5s linear;    &#125;    .fade-enter-to,    .fade-leave &#123;        transform: translateX(0);    &#125;&lt;/style&gt;\n\n\ntransition-group会被vue默认渲染成一个span元素,如果你想设置transition-group组件渲染输出的节点可以设置其tag属性,例 tag&#x3D;“ul” transition-group组件就会被渲染成ul标签\n\n&lt;transition-group tag=&quot;ul&quot; name=&quot;move&quot;&gt;                &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;                   &#123;&#123;todo.text&#125;&#125;                &lt;/li&gt;&lt;/transition-group&gt;\n\nJavaScript 动画钩子概念:无论transition 和 transition-group 标签都支持使用动画js钩子。动画的钩子就是元素在整个动画过渡中默写特殊的时间点。当动画到达这些时间点时就会触发js钩子所绑定方法。有了js动画钩子就可以实现一些复杂的动画。\n语法：动画钩子就是vue提供的一些自定义事件，监听响应的事件触发绑定的函数\n&lt;transition  v-on:before-enter=&quot;beforeEnter&quot;  v-on:enter=&quot;enter&quot;  v-on:after-enter=&quot;afterEnter&quot;  v-on:enter-cancelled=&quot;enterCancelled&quot;  v-on:before-leave=&quot;beforeLeave&quot;  v-on:leave=&quot;leave&quot;  v-on:after-leave=&quot;afterLeave&quot;  v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;  &lt;!-- ... --&gt;&lt;/transition&gt;&lt;transition-group  v-on:before-enter=&quot;beforeEnter&quot;  v-on:enter=&quot;enter&quot;  v-on:after-enter=&quot;afterEnter&quot;  v-on:enter-cancelled=&quot;enterCancelled&quot;  v-on:before-leave=&quot;beforeLeave&quot;  v-on:leave=&quot;leave&quot;  v-on:after-leave=&quot;afterLeave&quot;  v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;  &lt;!-- ... --&gt;&lt;/transition-group&gt;\n\n注意：动画钩子事件会将当前动画元素作为参数传入到函数内部\n&lt;!--Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择--&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt;            &lt;div v-show=&quot;show&quot; class=&quot;box&quot;&gt;&lt;/div&gt;        &lt;/transition&gt;        &lt;button @click=&quot;show = !show&quot;&gt;show/hidden&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        console.log(Velocity)        new Vue(&#123;            el: &quot;#app&quot;,            data: &#123;                show: true            &#125;,            methods: &#123;                beforeEnter(el) &#123;                    console.log(el, &#x27;元素将要显示&#x27;)                    el.style.opacity = 0                &#125;,                enter(el, done) &#123;                    console.log(&#x27;元素正在显示&#x27;)                    Velocity(el, &#123;                        opacity: &quot;1&quot;,                        translateY: &#x27;30px&#x27;,                    &#125;, &#123;                        duration: 400,                        easing: &quot;swing&quot;,                        loop: 2,                        complete: done // 动画结束后触发done表示自定义动画结束                    &#125;);                &#125;,                afterEnter(el) &#123;                    el.style.opacity = 1                    // console.log(el.offsetHeight)                    console.log(&#x27;元素显示完毕&#x27;)                &#125;            &#125;        &#125;)    &lt;/script&gt;\n\n注意：动画钩子事件会中enter事件与leave事件除了会默认传递第一个参数el（当前动画元素）以外，还会传递第二个参数 done，done 是一个方法用来告诉Vue当前元素的自定义动画已经结束，动画钩子才会执行下一步 after-enter 或者after-leave。如果自定义动画效果结束后不调用done可能会导致动画元素样式不更新。\n表单的数据绑定概念: 在开发中我们经常需要创建一些表单元素,表单元素的内容由vue实例中的data控制。而用户在表单上的输入操作又可以修改实例中的数据。上面的行为我们称之为表单的双向绑定。\n例子: 下面的代码就是实现input表单的双向绑定\n&lt;div id=&quot;app&quot;&gt;   &lt;input v-bind:value=&quot;str&quot; @input=&quot;inputHandel&quot;&gt;   &#123;&#123;str&#125;&#125;&lt;/div&gt;&lt;script&gt;new Vue(&#123;     el: &quot;#app&quot;,     data: &#123;         str: &#x27;hello world&#x27;     &#125;,     methods: &#123;         inputHandel(evt) &#123;            this.str = evt.target.value          &#125;     &#125;&#125;)&lt;/script&gt;\n\n注意：\n\nVue为了简化表单元素的数据绑定， input 、select、 textarea 这些值绑定全部统一使用value属性,但是单复选框依然是checked属性\n\n&lt;div id=app&gt;        &lt;input v-bind:value=&quot;str&quot; @input=&quot;inputHandel&quot;&gt;    &#123;&#123;str&#125;&#125;    &lt;textarea :value=&quot;str&quot;&gt;&lt;/textarea&gt;    &lt;select :value=&quot;city&quot;&gt;        &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;        &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;        &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt;        &lt;option value=&quot;sz&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;        &lt;input type=&quot;checkbox&quot; :checked=&quot;true&quot;&gt;&lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &quot;#app&quot;,            data: &#123;                str: &#x27;hello world&#x27;,                city: &#x27;sz&#x27;            &#125;,            methods: &#123;                inputHandel(evt) &#123;                    this.str = evt.target.value                 &#125;            &#125;        &#125;)&lt;/script&gt;\n\n\n虽然Vue帮我们简化了表单元素值得绑定,但是在不同表单元素之间依然有一些差异的。要根据不同的表单元素差异绑定不同的属性与方法还是有些繁琐。这时Vue为了帮我们解决表单的差异，提供了一个v-model的指令，v-model本质上是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。\n\n语法： v-model=&quot;data属性&quot;\n&lt;div id=&quot;app&quot;&gt;   &lt;input v-model=&quot;str&quot;&gt;   &#123;&#123;str&#125;&#125;   &lt;textarea v-model=&quot;str&quot;&gt;&lt;/textarea&gt;   &lt;p&gt;&#123;&#123;city&#125;&#125;&lt;/p&gt;   &lt;select v-model=&quot;city&quot;&gt;               &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;               &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;               &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt;       &lt;option value=&quot;sz&quot;&gt;深圳&lt;/option&gt;   &lt;/select&gt;   &lt;p&gt;&#123;&#123;agree? &#x27;同意&#x27; : &#x27;不同意&#x27;&#125;&#125;&lt;/p&gt;   &lt;input type=&quot;checkbox&quot; v-model=&quot;agree&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123;     el: &quot;#app&quot;,     data: &#123;       str: &#x27;hello world&#x27;,       city: &#x27;sz&#x27;,       agree: false     &#125;&#125;)&lt;/script&gt;\n\n注意: v-model 绑定支持表单元素的复选时,v-model绑定的数据请使用数组类型\n&lt;div id=&quot;app&quot;&gt;    &lt;!-- 选择器当设置了可复选属性时,会自动将v-model中的数据转化为数组 --&gt;    &lt;select v-model=&quot;city&quot; multiple&gt;    &lt;option value=&quot;&quot; disabled&gt;请选择你所在的城市&lt;/option&gt;    &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt;    &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt;    &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt;    &lt;option value=&quot;sz&quot;&gt;深圳&lt;/option&gt;    &lt;/select&gt;   &lt;!--复选框要实现复选时,必须将v-model中的数据设置为数组--&gt;  &lt;p&gt;爱好&#123;&#123;hobbys&#125;&#125;&lt;/p&gt;   &lt;label&gt;    抽烟    &lt;input type=&quot;checkbox&quot; value=&quot;抽烟&quot; v-model=&quot;hobbys&quot;&gt;  &lt;/label&gt;  &lt;label&gt;    喝酒    &lt;input type=&quot;checkbox&quot; value=&quot;喝酒&quot; v-model=&quot;hobbys&quot;&gt;  &lt;/label&gt;  &lt;label&gt;    烫头    &lt;input type=&quot;checkbox&quot; value=&quot;烫头&quot; v-model=&quot;hobbys&quot;&gt;  &lt;/label&gt;  &lt;label&gt;    玩摇滚    &lt;input type=&quot;checkbox&quot; value=&quot;玩摇滚&quot; v-model=&quot;hobbys&quot;&gt;  &lt;/label&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123;     el: &quot;#app&quot;,     data: &#123;       city: &#x27;&#x27;,       hobbys: []     &#125;&#125;)&lt;/script&gt;\n\n修饰符.lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步：\n&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot;&gt;\n\n.number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：\n&lt;!--    即使表单元素设置的type=&quot;number&quot;属性但是表单的value依然是字符串--&gt;&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n\n注意: 这通常很有用，因为即使在 type&#x3D;“number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。\n.trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：\n&lt;input v-model.trim=&quot;msg&quot;&gt;\n\n计算属性概念:\n\n在Vue开发中,经常需要对项目中的属性进行一些js运算，如果将js运算代码直接插入到Vue的模板中会显得模板代码十分臃肿，并且插值语法内部只能使用js表达式。Vue为解决复杂的数据处理提供了一个新的配置选项，computed计算属性。\n写在当前计算属性函数内部的所有其他属性(data属性或其他computed计算属性) 都会作为当前计算属性的 依赖(计算属性会监听这些数据的变化)。\n如果依赖不发生改变计算属性就不会重复执行，而是返回上一次计算属性执行后的值（计算属性的缓存），否则计算属性将会重新计算并返回新的结果。\n\n基础例子:\n&lt;div id=&quot;example&quot;&gt;&lt;!-- message 字符串翻转代码直接插入到DOM节点中显得代码过于繁琐,并且不能复用导致代码想当的臃肿--&gt;      &lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt;      &lt;div&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!--解决方法 message属性 字符串的反转运算封装到计算属性中--&gt;&lt;div id=&quot;example&quot;&gt;      &lt;p&gt;&#123;&#123;reverseMsg&#125;&#125;&lt;/p&gt;      &lt;div&gt;&#123;&#123;reverseMsg&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    new Vue(&#123;        el: &#x27;#example&#x27;,        data: &#123;            message: &#x27;Hello world&#x27;        &#125;,        computed: &#123;           reverseMsg() &#123;               return  this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)           &#125;         &#125;    &#125;)&lt;/script&gt;\n\n计算属性的缓存概念:\n\n上面的计算属性功能使用methods也可以实现,但是为什么我们要使用计算属性呢?\n因为计算属性会将当前计算属性函数内调用的所有 data 和 其它计算属性 作为当前计算属性的依赖(当前计算属性会订阅其函数内部所有属性和其他计算属性变化)，如果依赖发生改变计算属性会自动重新计算自身的值。如果内部任何依赖都没有发生变化计算属性将不会执行内部代码，只会返回上一次计算出的值，这个特性就被称为缓存。\n下面的计算属性now如果str属性不发生改变的化,下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖（即不是vue的属性）\n\ncomputed: &#123;  now: function () &#123;    return this.str + Date.now()  &#125;&#125;\n\n计算属性的setter概念: 计算属性默认只有 getter(取值逻辑)，不过在需要时你也可以提供一个 setter(赋值逻辑)\n语法 : 计算属性名: &#123;get()&#123;return&#125;,set(val)&#123;&#125;&#125;\n例子: 计算属性 fullName 会根据依赖属性 lastName、firstName 的变化而自动更新(getter)，用户修改计算属性 fullName 时会反向的修改 lastName、firstName (setter)\n&lt;div id=&quot;app&quot;&gt;        &lt;p&gt;姓: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;/p&gt;        &lt;p&gt;名: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;/p&gt;        &lt;p&gt;全名: &lt;input type=&quot;text&quot; v-model=&quot;fullName&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                firstName: &quot;小明&quot;,                lastName: &quot;李&quot;            &#125;,            computed: &#123;                fullName: &#123;                    get() &#123;                        return `$&#123;this.lastName&#125; $&#123;this.firstName&#125;`                    &#125;,                    set(val) &#123;                        console.log(val)                        let names = val.split(&#x27; &#x27;)                        this.firstName = names[1]                        this.lastName = names[0]                    &#125;                &#125;            &#125;        &#125;)&lt;/script&gt;\n\n侦听器概念:Vue提供了一个对当前实例属性(data、computed)进行侦听的配置选项watch,当前被侦听的属性发生改变时,对应侦听器绑定的callback函数就会被触发。\n语法：watch： &#123;侦听的属性名：callback(newValue, oldValue)&#125;\n&lt;div id=&quot;app&quot;&gt;        &lt;div&gt;&#123;&#123;hours&#125;&#125;&lt;/div&gt;        &lt;button @click=&quot;hours++&quot;&gt;hours add&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                hours: 0            &#125;,            computed: &#123;                day() &#123;                    return this.hours % 24                &#125;            &#125;,            watch: &#123;                hours: function(newValue, oldValue) &#123;                    if(newValue !== oldValue) &#123;                        if(newValue &lt; 4) &#123;                            console.log(&#x27;健康游戏时间&#x27;)                        &#125;else if(newValue &lt; 6) &#123;                            // alert(`你已经高强度网上冲浪$&#123;this.hours&#125;`)                            alert(`你已经高强度网上冲浪$&#123;newValue&#125;小时请注意休息`)                        &#125;else &#123;                            alert(`强制下线`)                        &#125;                    &#125;                &#125;,                // 侦听器也可以侦听计算属性                day(newValue, oldValue) &#123;                                    &#125;             &#125;        &#125;)&lt;/script&gt;\n\n注意:watch中的额回调函数不能使用箭头函数,使用箭头函数会导致函数内的this不指向当前实例对象自身\n过滤器概念：Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“|”符号指示：\n语法：filter支持全局过滤器或者局部过滤器\n\n全局过滤器，将过滤器选项配置到Vue构造函数内部\n\n&lt;div id=&quot;app&quot;&gt;    &#123;&#123;str|capitalize&#125;&#125; // Hello&lt;/div&gt;&lt;script&gt;Vue.filter(&#x27;capitalize&#x27;, function (value) &#123;  if (!value) return &#x27;&#x27;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123;    el: &#x27;#app&#x27;,    data: &#123;        str: &#x27;hello&#x27;    &#125;&#125;)&lt;/script&gt;\n\n\n局部过滤器，将过滤器选项配置到Vue实例对象内部\n\n&lt;div id=&quot;app&quot;&gt;        &lt;div v-for=&quot;(f,i) in friends&quot; :key=&quot;i&quot;&gt;            &lt;h3&gt;姓名: &#123;&#123;f.name&#125;&#125; &lt;/h2&gt;            &lt;p&gt;年龄: &#123;&#123;f.age&#125;&#125;&lt;/p&gt;            &lt;p&gt;性别: &#123;&#123;f.sex|getSex&#125;&#125;&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                friends: [&#123;                        name: &#x27;Max&#x27;,                        sex: 0,                        age: 19                    &#125;,                    &#123;                        name: &#x27;Jack&#x27;,                        sex: 1,                        age: 22                    &#125;,                    &#123;                        name: &#x27;Jacose&#x27;,                        sex: 1,                        age: 19                    &#125;,                    &#123;                        name: &#x27;Tim&#x27;,                        sex: 1,                        age: 18                    &#125;,                    &#123;                        name: &#x27;Jimmy&#x27;,                        sex: 0,                        age: 20                    &#125;,                    &#123;                        name: &#x27;Tom&#x27;,                        sex: 0,                        age: 19                    &#125;,                ]            &#125;,            filters: &#123;                getSex(type) &#123;                    if (type === 0) &#123;                        return &#x27;男&#x27;                    &#125;                    return &#x27;女&#x27;                &#125;            &#125;        &#125;)    &lt;/script&gt;\n\n注意: filter支持传递多个参数,直接向substr传递的参数，直接传递的参数会依次作为filter方法的第二、第三…第n个参数\n&lt;div id=&quot;app&quot;&gt;&#123;&#123;&#x27;hello&#x27;|substr(3,4,...)&#125;&#125;&lt;/div&gt;&lt;script&gt;new Vue(&#123;    el: &#x27;#app&#x27;    filters: &#123;       substr(str,start,end) &#123;           return str.substr(start,end)       &#125;     &#125;&#125;)&lt;/script&gt;\n\n注意: Vue支持多个filter过滤器串联使用, 串联的过滤器会拿到前一个过滤器返回的结果依次执行\n&lt;div id=&quot;app&quot;&gt;        &#123;&#123;str|reverseStr|capitalize&#125;&#125; &lt;!-- str将会经过reverseStr过滤器处理被反转,反转后的字符串会传入capitalize过滤器处理将首字母大写,最终的结果为 Olleh--&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                str: &#x27;hello&#x27;            &#125;,            filters: &#123;                capitalize (value) &#123;                    if (!value) return &#x27;&#x27;                    value = value.toString()                    return value.charAt(0).toUpperCase() + value.slice(1)                &#125;,                reverseStr(value) &#123;                    if (!value) return &#x27;&#x27;                    return value.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)                &#125;            &#125;&#125;)&lt;/script&gt;\n\n组件概念: 组件系统是 Vue 的一个重要概念，Vue允许我们将代码拆分独立成一些将小型的可复用模块。这些模块就被成为组件,使用这些组件就可以构建一个大型项目。在Vue中组件分为全局组件和私有组件\n组件的创建\n全局组件\n\n概念: 注册在Vue构造函数中的组件,在Vue实例任何地方任何组件中都可以使用\n语法: Vue.component(&#39;组件名&#39;, &#123;组件的配置对象&#125;)\n&lt;div id=&quot;app&quot;&gt;        &lt;gec-title&gt;&lt;/gec-title&gt;&lt;/div&gt;&lt;script&gt;        //全局组件,使用Vue构造函数提供的component API添加在构造函数中,在Vue实例对象的任何地方都可以使用.\\        Vue.component(&#x27;gec-title&#x27;, &#123;            // 这里的配置选项与Vue实例对象的配置选项(除了没有el以外)基本相同            // template 模板配置选项,Vue实例配置选项中也有此选项            // 当前组件/vue实例渲染在页面中的DOM模板            template: `            &lt;div&gt;                &lt;h2&gt;&#123;&#123;12 + 8&#125;&#125;&lt;/h2&gt;                我是组件gec-title的模板            &lt;/div&gt;            `        &#125;)        new Vue(&#123;            el: &#x27;#app&#x27;        &#125;)&lt;/script&gt;\n\n\n私有组件\n\n概念: 通过components配置选项注册在Vue实例对象或其他子组件内部,只能在注册的父组件内部使用。\n语法: Vue配置选项和组件配置选项都支持components属性 components: &#123;组件名: &#123; 组件配置选项 &#125;&#125;\n&lt;div id=&quot;app&quot;&gt;        &lt;gec-title&gt;&lt;/gec-title&gt;        &lt;component-a&gt;&lt;/component-a&gt;&lt;/div&gt;&lt;script&gt;        //全局组件,使用Vue构造函数提供的component API添加在构造函数中,在Vue实例对象的任何地方都可以使用.\\        Vue.component(&#x27;gec-title&#x27;, &#123;            // 这里的配置选项与Vue实例对象的配置选项(除了没有el以外)基本相同            // template 模板配置选项,Vue实例配置选项中也有此选项            // 当前组件/vue实例渲染在页面中的DOM模板            template: `            &lt;div&gt;                &lt;h2&gt;&#123;&#123;12 + 8&#125;&#125;&lt;/h2&gt;                我是组件gec-title的模板            &lt;/div&gt;            `        &#125;)        new Vue(&#123;            el: &#x27;#app&#x27;,            components: &#123;                // 在Vue实例中注册的局部组件 &#x27;component-a&#x27;,只能在Vue的实例对象中使用                &#x27;component-a&#x27;: &#123;                    template: `                    &lt;div&gt;                        &lt;h3&gt;我是组件A&lt;/h3&gt;                        &lt;child-a&gt;&lt;/child-a&gt;                        &lt;gec-title/&gt;                    &lt;/div&gt;                    `,                    components: &#123;                        // 在组件&#x27;component-a&#x27;中注册的局部组件，该组件只能在组件&#x27;component-a&#x27;中使用                        &#x27;child-a&#x27;: &#123;                            template: &#x27;&lt;h2&gt;我是组件A的子组件childA&lt;/h2&gt;&#x27;                        &#125;                    &#125;                &#125;            &#125;        &#125;)&lt;/script&gt;\n\n注意: template属性指定DOM模板结构中必须有且仅有一个根DOM元素!\n组件的data配置选项概念: 组件设计初衷就是将哪些独立的可复用的代码块封装起来,因为对象是引用数据类型如果直接将组件的data属性设置为对象的话。同一个组件在复用时会导致多个组件同时读写同一个对象，严重的影响了组件可复用性和独立性。为了解决这个问题Vue明确规定组件的data不可以是个对象，而是一个返回data对象的工厂模式函数。\n语法:\n// 普通函数  Vue.component(&#x27;gec-title&#x27;, &#123;            template: `            &lt;div&gt;                &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data() &#123;                return &#123;                    name: &#x27;小明&#x27;,                    age: 18                &#125;            &#125;        &#125;) // 箭头函数 Vue.component(&#x27;gec-title&#x27;, &#123;            template: `            &lt;div&gt;                &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;            &lt;/div&gt;            `,            data: () =&gt; (&#123;                    name: &#x27;小明&#x27;,                    age: 18                &#125;)        &#125;)\n\n单项数据流概念: 在Vue中组件之间是单项数据流的。单项数据流规定子组件不可以直接访问父组件的数据，只能通过props属性让父组件把数据传递给子组件。并且子组件不可以直接修改父组件传递给子组件的数据。\nprops的使用概念: 组件可以通过特殊的配置选项props给自身设置自定义属性，父组件就可通过props属性传值将父组件的数据传递给子组件，因为Vue是单项数据流子组件不可以修改props（props是只读的）\n注意：组件的data属性与props属性不能同名\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;h2&gt;&#123;&#123;age&#125;&#125;&lt;/h2&gt;        &lt;my-label v-bind:a=&quot;age&quot; b=&quot;hello&quot; :c=&quot;age &gt;= 18?&#x27;已成年&#x27;:&#x27;未成年&#x27;&quot;/&gt;    &lt;/div&gt;    &lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                age: 15            &#125;,            components: &#123;                &#x27;my-label&#x27;: &#123;                    // 给当前my-label设置了三个自定义属性a b c                    // 组件组件自身就可以通过 this.props.a                     props: [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;],                    data: () =&gt; (&#123;                        name: &#x27;my-label&#x27;                    &#125;),                    template: `                    &lt;div&gt;                         &lt;p&gt;a:&#123;&#123;a&#125;&#125;&lt;/p&gt;                        &lt;p&gt;b:&#123;&#123;b&#125;&#125;&lt;/p&gt;                        &lt;p&gt;c:&#123;&#123;c&#125;&#125;&lt;/p&gt;                        &lt;child-a v-bind:name=&quot;name&quot; :rootage=&quot;a&quot;&gt;&lt;/child-a&gt;                    &lt;/div&gt;                        `,                    components: &#123;                        &#x27;child-a&#x27;: &#123;                            props: [&#x27;name&#x27;,&#x27;rootage&#x27;],                            template: &#x27;&lt;div&gt;我是childA 父组件的name为&#123;&#123;name&#125;&#125; rootAge&#123;&#123;rootage&#125;&#125;&lt;/div&gt;&#x27;                        &#125;                    &#125;                &#125;            &#125;        &#125;)    &lt;/script&gt;\n\n反向传值因为Vue是单项数据流的,规定只允许父组件向子组件传递状态,而不允许子组件直接修改父组件传递过来的状态。Vue提供了自定义事件API,通过父组件监听子组件自定义事件, 当子组件想要修改父组件的状态时会通过 $emit 方法触发自定义事件。父组件对应监听子组件自定义事件的回调函数就会被触发，这样父组件自身的方法就会相应的去修改自身的状态。子组件的props就会更新\n语法: $emit(&#39;自定义事件名&#39;, 向父组件回调函数传递参数)\n注意: $emit只接受两个参数,参数一触发父组件监听的指定事件名,参数二(可选)向父组件监听事件回调函数传递的数据\n案例: $emit的使用\n&lt;div id=&quot;father&quot;&gt;       &lt;child :zfb=&quot;money&quot; @call=&quot;callHandel&quot;/&gt;   &lt;/div&gt;   &lt;script&gt;       new Vue(&#123;           el:&#x27;#father&#x27;,           data: &#123;               money: 1500           &#125;,           methods: &#123;               callHandel() &#123;                   console.log(&#x27;儿子给我打电话了,说钱不够花&#x27;)                   this.money += 500               &#125;           &#125;,           components: &#123;               &#x27;child&#x27;: &#123;                   props: [&#x27;zfb&#x27;],                   template: `                   &lt;div&gt;                       父亲通过支付宝转生活费额度:&#123;&#123;zfb&#125;&#125;                       &lt;button @click=&quot;$emit(&#x27;call&#x27;)&quot;&gt;向父亲打电话&lt;/button&gt;                   &lt;/div&gt;               `               &#125;,                         &#125;       &#125;)    &lt;/script&gt;\n\n「课堂练习」\ncount-control子组件实现反向修改父组件的数据\n\nVue实例中包含一个属性值为Number类型的count属性\n并创建Vue实例私有子组件count-control1 与全局组件count-control2\n实现子组件让父组件count data 加 1\n实现子组件让父组件的count data 减 1\n实现子组件让父组件的count data 加指定 number值\n\n\n\n\nVue脚手架安装使用\nStep1 在系统变量中安装Vue脚手架工具vue-cli\n\n#全局安装vue-cli环境配置npm install -g @vue/cli\n\n\n\nStep2访问到指定目录,使用vue指令创建新项目\n\n#全局安装完毕后,以后 vue create 项目名称 搭建项目vue create project_name   \n\n\n\nStep3执行创建vue项目指令时会返回一个vue项目配置询问,先直接使用默认vue 2.0 模板\n\n? Please pick a preset: (Use arrow keys)&gt; Default ([Vue 2] babel, eslint) #使用默认vue 2.0 模板  Default (Vue 3 Preview) ([Vue 3] babel, eslint) #使用默认vue 3.0 模板  Manually select features      #自定义模板\n\n\n\nStep4 安装完毕后\n\n# 访问新创建的项目目录cd project_name#启动测试用服务开发指令npm run serve#项目开发完毕打包指令npm run build\n\nVue-cli项目结构webpack-demo |- /public   // 公共目录,这个目录中的文件不会被webpack打包而是作为一个静态目录              // 放置在 public 目录下或通过绝对路径被引用。这类资源将会直接被拷贝，而不会经过 webpack 的处理。    |- index.html // vue中 html模板文件 |- /src  // 整个项目代码开发目录    |- main.js // 项目的入口文件 |- babel.config.js  // webpack babel-loader配置文件  |- package.json // 项目的配置描述文件 |- README.md // 项目的readme文件+|- vue.config.js // 可自定义Vue webpack相关配置的文件\n\n\n局部关闭 ESlint 校检\nESlint 是一个js代码检测工具,约束开发人员的代码风格,如果想具体了解,请查阅其文档\n相关文档: https://blog.csdn.net/qq_39557024/article/details/107519531相关文档： https://blog.csdn.net/qq_39557024/article/details/107519531\n\npublic 文件夹概念: 任何放置在 public 文件夹的静态资源都会被简单的复制，而不经过 webpack。你需要通过绝对路径来引用它们。\n注意: 我们推荐将资源作为你的模块依赖图的一部分导入，这样它们会通过 webpack 的处理并获得如下好处：\n\n脚本和样式表会被压缩且打包在一起，从而避免额外的网络请求。\n文件丢失会直接在编译时报错，而不是到了用户端才产生 404 错误。\n最终生成的文件名包含了内容哈希，因此你不必担心浏览器会缓存它们的老版本。\n\npublic 目录提供的是一个应急手段，当你通过绝对路径引用它时，留意应用将会部署到哪里。如果你的应用没有部署在域名的根部，那么你需要为你的 URL 配置 publicPath 前缀，在 public&#x2F;index.html 或其它通过 html-webpack-plugin 用作模板的 HTML 文件中，你需要通过 &lt;%&#x3D; BASE_URL %&gt; 设置链接前缀：\n&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;css/style.css&quot;&gt;\n\n在js文件中 使用process.env.BASE_URL作为pubulic文件的前缀\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    // 直接引入静态目录中的文件    &lt;img alt=&quot;Vue logo&quot; :src=&quot;`$&#123;publicPath&#125;imgs/01.jpg`&quot;&gt;    // 相对路径的引入会导致webpack对该文件进行打包    &lt;img alt=&quot;Vue logo&quot; src=&quot;../public/imgs/01.jpg&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;App&#x27;,  data() &#123;    return &#123;       // 获取公共目录路径      publicPath: process.env.BASE_URL    &#125;  &#125;&#125;&lt;/script&gt;\n\npublicPath配置实在项目的根目录下vue.config.js中设置publicPath选项就好了\nmodule.exports = &#123;    publicPath: process.env.NODE_ENV === &#x27;production&#x27;      ? &#x27;/production-sub-path/&#x27; //真实开发的话,如果你的项目存放在公司域名二级路径下 只需要将 /production-sub-path/改为 /公司二级路径/就可以了      : &#x27;/&#x27;  &#125;\n\nwebpack 相关（了解）介绍: 在vue-cli中简单的配置webpack方式就是在Vue项目的根目录下创建vue.config.js文件。这个通过配置这个文件中 module.exports 公开的对象实现对Vue Webpack进行修改。\n\n指定项目静态资源模块的相对路径\n指定打包后文件的目录(默认dist文件)\nassets文件的目录\n多页面应用开发\ncss模块化 loader等\n给项目添加Webpack plugin\n配置当前项目的开发测试服务器\n\n// vue.config.jsmodule.exports = &#123;    publicPath: process.env.NODE_ENV === &#x27;production&#x27;        ? &#x27;/production-sub-path/&#x27; //真实开发的话,如果你的项目存放在公司域名二级路径下 只需要将 /production-sub-path/改为 /公司二级路径/就可以了        : &#x27;/&#x27;,    devServer: &#123; // 服务器代理,当请求了代理设置的路径时 会自动跳转到指定服务器上,解决跨域问题        proxy: &#123;            &quot;/search&quot;: &#123;                target: &#x27;http://musicapi.leanapp.cn/&#x27;,                changeOrigin: true                // 当你请求 /search?123123 时 会代理到 &#x27;http://musicapi.leanapp.cn/search?123123&#x27;            &#125;        &#125;    &#125;&#125;\n\n了解Vue-cli src目录结构介绍: 在src文件中main.js是整个项目的入口文件，也是实例化Vue对象的地方\n\n因为vue-cli是模块化开发，所以整个项目不适用&lt; script &gt;标签引入Vue支持而是使用模块化依赖模式通过import引入Vue对象\n\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27; // 引入单文件App组件Vue.config.productionTip = false// 实例化Vuenew Vue(&#123;  render: h =&gt; h(App)    // render是template字符串模板的替代方案，render是一个函数函数接收一个参数（createElement）  // 这个参数可以将组件生成为一个Vue DOM节点渲染在页面上  // 所以上面这句化等价于 template: &#x27;&lt;App&gt;&lt;/App&gt;&#x27; &#125;).$mount(&#x27;#app&#x27;)// 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。// 这时可以使用 vm.$mount() 手动地挂载一个未挂载的实例。\n\n认识单文件组件我们观察下面的代码,在Vue实例中添加了局部组件App,如果说除了Vue实例以外其他组件可能也需要注册App局部组件的话。我们推荐将App抽离出来提供给其他组件复用\nnew Vue(&#123;    el: &#x27;#app&#x27;,    components: &#123;        App: &#123;            props: [&#x27;name&#x27;,&#x27;age&#x27;],            data() &#123;                return &#123;                    address: &#x27;bj&#x27;                &#125;            &#125;,            template: `            &lt;div&gt;                &lt;h2&gt;用户:&#123;&#123;name&#125;&#125; 年龄:&#123;&#123;age&#125;&#125;&lt;/h2&gt;                &lt;p&gt;地址:&#123;&#123;address&#125;&#125;&lt;/p&gt;               &lt;/div&gt;            `        &#125;    &#125;&#125;)\n\n抽离后\nconst App = &#123;    props: [&#x27;name&#x27;,&#x27;age&#x27;],    data() &#123;        return &#123;            address: &#x27;bj&#x27;        &#125;    &#125;,    template: `    &lt;div&gt;        &lt;h2&gt;用户:&#123;&#123;name&#125;&#125; 年龄:&#123;&#123;age&#125;&#125;&lt;/h2&gt;        &lt;p&gt;地址:&#123;&#123;address&#125;&#125;&lt;/p&gt;       &lt;/div&gt;    `&#125;new Vue(&#123;    el: &#x27;#app&#x27;,    components: &#123;        App    &#125;&#125;)\n\n我们在开发中推荐使用模块化开发，建议将每个可复用的组件单独封装成一个js模块，通过import引入其他文件中复用。这样的好处是便于维护更新让项目的结构更明确。\n// 将App组件封装成一个js模块// App.jsexport default &#123;    props: [&#x27;name&#x27;,&#x27;age&#x27;],    data() &#123;        return &#123;            address: &#x27;bj&#x27;        &#125;    &#125;,    template: `    &lt;div&gt;        &lt;h2&gt;用户:&#123;&#123;name&#125;&#125; 年龄:&#123;&#123;age&#125;&#125;&lt;/h2&gt;        &lt;p&gt;地址:&#123;&#123;address&#125;&#125;&lt;/p&gt;       &lt;/div&gt;    `&#125;// 其他组件或实例注册App组件import App from &#x27;./App&#x27;new Vue(&#123;    el: &#x27;#app&#x27;,    components: &#123;        App    &#125;&#125;)\n\nVue为了简化template字符串模板的开发（使用字符串写HTML语法js无法格式化代码，编译器无法对模板进行补全和检查），Vue提供了一个.vue文件简化了js文件创建单文件组件时template字符串模板开发不便。.vue文件单独的将template选项抽离出来以HTML的形式进行开发。\n上面的App.js就可以转化为:\n// App.vue// template 被抽离出来变成了一个独立的标签,内部本来使用字符串模板代码变成HTML语法&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;用户:&#123;&#123;name&#125;&#125; 年龄:&#123;&#123;age&#125;&#125;&lt;/h2&gt;    &lt;p&gt;地址:&#123;&#123;address&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&quot;name&quot;, &quot;age&quot;],  data() &#123;    return &#123;      address: &quot;bj&quot;,    &#125;  &#125;&#125;&lt;/script&gt;\n\n注意：\n\n.vue文件不仅支持template标签指定组件的模板样式和script 公开当前模板配置选项,还支持style标签内置的设置当前组件的样式,而且style标签支持使用sass\\less\\stylus预编译语言\n\n&lt;template&gt;  &lt;div class=&quot;demo&quot;&gt;      我是Demo,在vue文件中 &lt;!-- template内部遵循XML语法规则,所有单一型标签后面一定要跟一个/,并且template标签内部有且仅有一个根元素 --&gt;      &lt;input/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;!--style有两个可选属性     lang=&quot;scss&quot; 内部使用sass语法,项目要额外安装 sass-loader      lang=&quot;less&quot; 内部使用less语法,项目要额外安装 less-loader      lang=&quot;stylus&quot; 内部使用less语法,项目要额外安装 stylus-loader     不设置该属性则使用css    scoped 样式私有化,如果设置了该属性,style标签内的所有样式只会对组件自身有效--&gt;&lt;style lang=&quot;less&quot; scoped&gt;.demo &#123;    color: green;&#125;&lt;/style&gt;\n\n\n建议使用.vue创建组件时,组件名与文件名一致并且使用每个单词首字母大写的命名方法。例: HelloWorld.vue、DemoComponent.vue\n\nProps验证概念：在开发中我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这一模式会在开发中帮开发人员捕获大量的异常。\n语法： props可以是一个数组，数组中的每一项都是当前组件的props属性名。props属性还是是一个对象为每个指定的props属性指定其验证规则以及默认值\nprops: &#123;        // 当前组件的propsA属性必须是Number数据类型或者为空(可忽略)        propA: Number,         // propB与propA等价        // prop为指定数据类型只需要设置该属性type值为对应数据类型的构造函数        propB: &#123;            type: Number        &#125;,        // prop属性可以设置为必要属性,渲染该组件时必须给该属性传值并且不可为空        propC: &#123;            type: Number,            required: true         &#125;,        // prop属性支持默认值,当没有给该prop传递属性是,该属性则会使用默认值        // 注意: 默认值优先级小于required        propD: &#123;            type:Number,            default: 15        &#125;,        propE: &#123;          type: Object,          // 对象或数组默认值必须从一个工厂函数获取          default: function () &#123;            return &#123; message: &#x27;hello&#x27; &#125;          &#125;        &#125;    &#125;\n\nProps验证规则props: &#123;       // 通过构造函数指定prop数据类型       propA: Number,       propB: Boolean,       propC: String,       propD: Array,       propE: Object,       propF: Symbol,       propG: RegExp,       propH: Date,       propI: Cat, // 可以指定任何构造函数作为prop的type,当前prop接收到的值必须是当前指定构造函数的实例对象       propJ: Function       // prop验证支持 多个可能的类型       propK: [String, Number],        // 自定义验证规则,不满足验证条件是return false       propL: &#123;         validator(val) &#123;// val 传入到 propL属性的值           if (typeof val === &quot;string&quot;) &#123;             if (/fuck/gi.test(val)) &#123;               console.error(&quot;组件ComponentA中 属性 PropL包含敏感词汇!&quot;);             &#125; else &#123;               return true;             &#125;           &#125; else &#123;             console.error(&quot;数据必须是字符串&quot;);           &#125;           return false;         &#125;       &#125;   &#125;\n\n动态组件概念: VUe 提供了一个标签component,该标签可以使用 is attribute 来切换不同的组件：\n&lt;div id=&quot;app&quot;&gt;        &lt;component :is=&quot;`my-$&#123;name&#125;`&quot;&gt;&lt;/component&gt;             &lt;button @click=&quot;name =&#x27;a&#x27;&quot;&gt;a&lt;/button&gt;        &lt;button @click=&quot;name =&#x27;b&#x27;&quot;&gt;b&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;         new Vue(&#123;             el: &#x27;#app&#x27;,             data: &#123;                 name: &#x27;a&#x27;             &#125;,             components: &#123;                 &#x27;my-a&#x27;: &#123;                     template: &#x27;&lt;h2&gt;我的组件A&lt;/h2&gt;&#x27;                 &#125;,                 &#x27;my-b&#x27;: &#123;                     template: &#x27;&lt;h2 @click=&quot;num++&quot;&gt;组件B&#123;&#123;num&#125;&#125;&lt;/h2&gt;&#x27;,                     data() &#123;                         return &#123;num: 7&#125;                     &#125;                 &#125;,             &#125;         &#125;)    &lt;/script&gt;\n\n在动态组件上使用 keep-alive概念: 当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。\n&lt;div id=&quot;app&quot;&gt;       &lt;!-- 失活的组件将会被缓存！--&gt;       &lt;keep-alive&gt;           &lt;component :is=&quot;`my-$&#123;name&#125;`&quot;&gt;&lt;/component&gt;       &lt;/keep-alive&gt;             &lt;button @click=&quot;name =&#x27;a&#x27;&quot;&gt;a&lt;/button&gt;       &lt;button @click=&quot;name =&#x27;b&#x27;&quot;&gt;b&lt;/button&gt;   &lt;/div&gt;   &lt;script&gt;        new Vue(&#123;            el: &#x27;#app&#x27;,            data: &#123;                name: &#x27;a&#x27;            &#125;,            components: &#123;                &#x27;my-a&#x27;: &#123;                    template: &#x27;&lt;h2&gt;我的组件A&lt;/h2&gt;&#x27;                &#125;,                &#x27;my-b&#x27;: &#123;                    template: &#x27;&lt;h2 @click=&quot;num++&quot;&gt;组件B&#123;&#123;num&#125;&#125;&lt;/h2&gt;&#x27;,                    data() &#123;                        return &#123;num: 7&#125;                    &#125;                &#125;,            &#125;        &#125;)      &lt;/script&gt;\n\n注意: 在上面的案例中如果没有使用keep-alive缓存失活的组件,那么失活的组件将被丢弃(卸载)，组件切换时每次都是挂载一个全新的组件\n\n异步组件（了解）介绍: 在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：\nVue.component(&#x27;async-example&#x27;, function (resolve, reject) &#123; setTimeout(function () &#123;   // 向 `resolve` 回调传递组件定义   resolve(&#123;     template: &#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;   &#125;) &#125;, 1000)&#125;)\n\n如你所见，这个工厂函数会收到一个 resolve 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 reject(reason) 来表示加载失败。这里的 setTimeout 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：\nVue.component(&#x27;async-webpack-example&#x27;, function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require([&#x27;./my-async-component&#x27;], resolve)&#125;)\n\n你也可以在工厂函数中返回一个 Promise，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：\nVue.component(   &#x27;async-webpack-example&#x27;,  // 这个动态导入会返回一个 `Promise` 对象。  () =&gt; import(&#x27;./my-async-component&#x27;))\n\n当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：\nnew Vue(&#123; // ... components: &#123;   &#x27;my-component&#x27;: () =&gt; import(&#x27;./my-async-component&#x27;) &#125;&#125;)\n\n如果你是一个 Browserify 用户同时喜欢使用异步组件，很不幸这个工具的作者明确表示异步加载“并不会被 Browserify 支持”，至少官方不会。Browserify 社区已经找到了一些变通方案，这些方案可能会对已存在的复杂应用有帮助。对于其它的场景，我们推荐直接使用 webpack，以拥有内置的头等异步支持。\n懒加载状态 (2.3.0+ 新增)这里的异步组件工厂函数也可以返回一个如下格式的对象：\nconst AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import(&#x27;./MyComponent.vue&#x27;), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;)\nRef概念: Vue给组件元素提供了一个ref属性,绑定了ref属性的组件元素可以在当前vue实例对象中通过$refs访问其真实DOM节点(标签元素)或实例对象(组件)。\n在原生html标签中使用ref语法: &lt;div ref=&quot;变量名&quot;&gt;&lt;/div&gt; 当前组件内部 this.$refs.变量名 访问其真实DOM节点\n &lt;div id=&quot;app&quot;&gt;        &lt;audio ref=&quot;myAudio&quot; src=&quot;./药水歌.mp3&quot; controls&gt;&lt;/audio&gt;        &lt;button @click=&quot;showAudio&quot;&gt;show&lt;/button&gt; &lt;/div&gt;    &lt;script&gt; new Vue(&#123;     el: &#x27;#app&#x27;,     methods: &#123;         showAudio() &#123;             console.log(this.$refs.myAudio)         &#125;               &#125;&#125;)&lt;/script&gt;  \n\n在组件中中使用ref语法： &lt;MyComponent ref=&quot;变量名&quot; /&gt; 当前组件内部 this.$refs.变量名 访问这个子组件的实例对象,可以获取这个组件实例的属性和方法(尽量避免使用该模式,因为他会增加组件间的耦合性)\n&lt;template&gt;    &lt;Demo ref=&quot;myDemo&quot; /&gt;&lt;/template&gt;&lt;script&gt;import Demo from &#x27;./components/Demo&#x27;export default &#123;  name: &#x27;App&#x27;,  methods: &#123;    show() &#123;      // 子组件Demo的方法在父组件中被调用了      this.$refs.myDemo.sayHello()    &#125;  &#125;,  components: &#123;    Demo  &#125;&#125;&lt;/script&gt;\n\n注意:\n\nvue实例中每个标签或组件都可以设置ref属性,绑定了ref属性的元素可以有任意个\n\n&lt;div id=&quot;app&quot;&gt;        &lt;audio ref=&quot;myAudio&quot; src=&quot;./药水歌.mp3&quot; controls&gt;&lt;/audio&gt;        &lt;button ref=&quot;myBtn&quot; @click=&quot;showAudio&quot;&gt;show&lt;/button&gt;        &lt;p ref=&quot;textEl&quot;&gt;text&lt;/p&gt; &lt;/div&gt;   // 这时可以在组件中通过 this.$refs不同的变量名访问对应的DOM元素 \n\n\nref配合列表渲染(v-for)使用时,$refs返回值为包含列表渲染出来的所有元素的一个数组\n\n&lt;div id=&quot;app&quot;&gt;    // 与v-for同级的ref 返回值都是列表渲染出来当前元素数组集合    &lt;p v-for=&quot;num in arr&quot; :key=&quot;num&quot; ref=&quot;numList&quot;&gt;        //v-for 内部的ref 返回值也是列表渲染出来当前元素数组集合        &lt;span ref=&quot;spanList&quot;&gt;&#123;&#123;num&#125;&#125;-span&lt;/span&gt;        &lt;a&gt;没用的a&lt;/a&gt;        &#123;&#123;num&#125;&#125;    &lt;/p&gt;    &lt;button @click=&quot;showRefList&quot;&gt;click&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    new Vue(&#123;        el: &#x27;#app&#x27;,        data: &#123;            arr: [1, 2, 3, 4, 5]        &#125;,        methods: &#123;            showRefList() &#123;                console.log(this.$refs.numList,                            this.$refs.spanList)                // [p,p,p,p,p] , [span,span,span,span,span]              &#125;        &#125;    &#125;)&lt;/script&gt;","categories":["编程","笔记"],"tags":["编程","笔记"]},{"title":"追番补番最佳体验教程。网盘挂载，三方弹幕，资源整合🧐","url":"/2024/12/19/%E6%9C%80%E8%88%92%E6%9C%8D%E7%9A%84%E7%9C%8B%E7%95%AA%E8%A7%82%E5%BD%B1%E6%8C%87%E5%8D%97/","content":"导读因为现在国内的视频网站码率压得太狠了，B站的码率在国内已经算是高的了，但也依旧达不到正经的1080P画质标准，1080P还不如YouTube的720P。 \n详情可以看视频 👉 视频网站的“蓝光”是怎么骗你的？——视频画质全解析【柴知道】\n这篇2020年的文章也早就说明了国内视频网站画质下降是必然的结果了 👉 谁也成为不了中国的 YouTube\n省流：谷歌一家独大，对全球各国众多宽带运营商议价能力极强，实现了油管的0宽带成本，而B站没有这个优势。\n而且因为国内审核的因素，模糊的审核标准，让国内大部分网站进行自我阉割，老番删减的删减，下架的下架，支持正版反倒成为了正版受害者。\n综上所述，B站已经不是追番的好选择了，不过补番的话，有些许的漏网之鱼还是能看的。\n教程的流程主要分以下三步走：\n\n本地挂载云盘\n资源搜寻\n弹幕观看\n\n目标结果如图所示：\nps：哥们之前是磁力下载党，等字幕组更新后再下载下来后做种，穷哥们的单硬盘电脑健康顶不住了，虽然并不影响使用，但硬盘健康度掉了就是绷不住啊😢\n\n本地挂载云盘前言AList 是一个支持多个存储提供商，包括本地存储、阿里云盘、OneDrive、Google Drive 等，支持网页浏览和 WebDAV 的文件列表软件，由 gin 和 Solidjs 驱动。简单的来说就是能够帮你整合管理各种云盘。当然，AList 除了支持网盘存储之外，还支持对象存储，本地存储，FTP 等等。\n通俗来说，就是可以让你以本地文件的形式来管理云端文件。\n下载 Alist：\n以64位的 Windows 为例，下载指定版本：Dalist-windows-amd64.zip  \n\n\n\n解压 alist.exe 放入到新文件夹中，在路径栏输入 cmd 回车运行。\n\n在命令行输入 alist start ，设置自定义密码后浏览器打开：127.0.0.1:5244。（注意不要关闭终端窗口，若要关闭窗口，执行命令 alist.exe server 启动全局服务后方可关闭）\n\n\n\n登录 Alist\n初始用户名默认是：admin ，初始密码为之前设置的自定义密码（114514）\n\n登录成功后，进入管理修改用户名和密码  \n\n\n\n添加网盘\n以 夸克网盘 为例\n\n用chrome浏览器打开F12控制台，其它浏览器F12控制台网络里的请求可能为空，再登录即可获取到所需的cookie\n\n\n代理为本地代理，粘贴从浏览器复制到的cookie即可\n\n\n更多网盘挂载方法，请查看官方文档\n\n\n安装 RaiDrive：安装完成后，点击添加 → 选择 NAS → WebDav → 然后取消地址选项，在http://处填入 127.0.0.1，端口：5244，路径：&#x2F;dav → 最后填写 Alist 账号和密码，点击连接即可。\n设置 Alist 开机自启每次使用，都需要通过 cmd 运行程序很繁琐。所以，我们最好设置 alist.exe 开机自启动\n\n在 alist 目录下新建一个文本文档，将以下代码复制进去，然后将文件重命名为 alist.vbs\nSet ws = CreateObject(&quot;Wscript.Shell&quot;) ws.run &quot;alist.exe server&quot;,vbhide\n\n注意：\\alist.exe server 前面是你本机 alist.exe 所在的文件路径地址\n注意：文本文档重命名为 alist.vbs 前，必须有打开文件扩展名，将. txt 修改成. vbs\n\n鼠标右键 alist.vbs，创建快捷方式\n然后 Win+R 打开命令窗口，输入 shell:startup 后回车，将刚创建的 alist.vbs 快捷方式粘贴到打开的文件夹中。\n这样，Alist 开机自启动就大功告成了。每次开机时网络位置都会自动挂载云盘。\n\n\n\n番剧资源搜寻追番曾经第三方阿里云盘不限速的时候，非常好用，现在就剩下夸克网盘能用了，番剧的更新速度非常快，几乎和磁力种子的发布速度一致，而且各个汉化组的资源都有，想要体验中日双语的话，可以等待自己喜欢的字幕组更新。\n新番实时更新文档 Ruach. | Link3\n新番夸克文档：日漫新番文档 夸克\n补番番剧完结后，会出售画质更高的BD，动画基本上都会根据BD的销售量来判断会不会有续作(游戏人生:你说什么？😄)，相比于网络版，BD有画面修正和更高的画质。\n压制组和字幕组合作压制出来的资源，有专门的压制组出来的资源没有字幕，\n这时候就需要自己来寻找字幕了，英剧美剧什么的，人人影视，射手字幕网都有。\n外挂字幕，字体缺失的话，番剧的字体就会使用电脑的默认字体\n动漫字幕论坛：Anime字幕论坛 - Powered by Discuz!\n动漫资源论坛：天使动漫论坛-梦开始的地方\n电报频道：高画质动漫分享 Anime share\n弹幕弹弹play可以用弹弹play，保存了B站大部分下架了的老番剧的弹幕，新番还可以直链视频网页弹幕，B站弹幕，台湾巴哈姆特动画疯的弹幕。\n弹弹play - 全功能“本地视频+弹幕”播放器\nB站下载弹幕本地观看现在B站新番删减和谐严重，而且弹幕低龄化也是问题，容易弹幕和画面不一致的情况，不过B站老番和港澳台的弹幕还是可以一用的。\n合并短时间内出现的重复弹幕，优化观看体验 👉 pakku.js: 拯救B站的弹幕体验！\n下载弹幕，也可以用来下载视频，字幕。 👉 Bilibili-Evolved: 强大的哔哩哔哩增强脚本\n弹幕下载到本地后，xml格式的弹幕可以直接拖动到弹弹play播放即可。\n","categories":["教程"],"tags":["教程","分享","资源检索","番剧","二次元"]},{"title":"【转载】等身抱枕-从入门到破产","url":"/2025/02/08/%E7%AD%89%E8%BA%AB%E6%8A%B1%E6%9E%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%A0%B4%E4%BA%A7/","content":"写在前面：写这篇文章的目的写这篇文章的主要原因，是因为深感当前国内市场⻥⻰混杂，对部分商家和工厂通过各种方式或是哄骗或是提高新人的理解门槛以获取不当利润的行为的不满。尤其是对于盗版这种行径的强烈谴责。\n因此，想要写出一份能够系统得、全面得解答一个萌新入坑时，可能遇到的所有问题，能让萌新在看完本文章之后，对抱枕这个圈子，能有正确的认识和判断能力。\n这篇文章，在很多方面，参考了欧美抱枕群体的综合指南(https://daki.info)。如有兴趣，可以自行查看（谷歌文档，需科技手段）。\n此文章内容可能涉及过多利益，其中部分内容仅作参考。出于个人安全考虑，此文章交由百度贴吧动漫抱枕吧的吧主-加拿大鹅代发。\n如何识别盗版？或许你并不常听到大家直接说盗版这个词，而是“复刻”。“复刻”一词为盗版商为了规避各种规章而使用的“美称”。本文全文不会使用“复刻”一词，只会直呼盗版。\n1、盗版抱枕是如何制作的盗版抱枕的核心在于盗图。盗图并不是完全单指直接将原图盗过来，而是指包括盗窃原图在内的其他各种方式还原原图的行为。\n除部分国产店铺的图，由于部分代工厂监守自盗，同时做盗版生意，导致原图流出外。多数情况下，盗图的图片质量远低于原图，包括但不限于：模糊、偏色。\n盗图通常有两种方法：软件算法放大与扫描仪扫描\n软件算法放大软件算法放大是指通过诸如waifu2x或AI等工具，利用商家公开的预览图（通常仅能看⻅模糊细节）、画师公开于Fanbox的高清预览图（可⻅细节，但通常仍低于实际印刷产品所用图片分辨率一半左右，且通常仅脸部等核心区域）或者公开的图站（如Y站Yande），将图片强行放大并降噪处理。\n经此处理后，通常会丢失很多细节。通常，你可以看到部分区域出现不明的线条弯曲，常⻅于瞳孔或发梢，这是由于过大的放大倍数所导致的。\n扫描仪扫描因其成本相对较高，此方法并不常⻅。\n顾名思义，使用扫描仪完整扫描抱枕图片。此方式可以获得具有清晰细节的抱枕图片，但是，由于设备及技术限制。会存在以下问题： \n1、扫描仪尺寸过小，需要拼合 \n2、摩尔纹及放大后可⻅的彩色扫描的色块。\n2、盗版与正版的对比因笔者手边并无盗版枕套，此区域图片搬运自欧美的抱枕指南。\n\n强热残分｜油漆娘｜爱蜜莉雅\n\n\n\n\n正版\n盗版\n\n\n\n\n\n\n\n\nAcHobby｜面条｜鸢一折纸\n\n\n\n\n正版\n盗版2WAY\n盗版桃皮绒\n\n\n\n\n\n\n\n\n\nDakimakuri｜Kätzchen｜扎拉\n\n\n\n\n左正版 右盗版\n左正版 右盗版\n\n\n\n\n\n\n\n\nNeko Works｜さより｜枫\n\n\n\n\n左正版 右盗版\n\n\n\n\n\n\n\n\n\n上正版 下盗版\n\n\n\n\n\n\n3、盗版店铺具有哪些特征盗版店铺的特征通常极为明显。可以从 7 个方向上下手。不过这些分辨方法可能误伤类似绝对萌域、尚萌此类成规模、流水线化运营的店铺，不过此类店铺极少，且图片质量通常并不高，笔者不会单独列出。\n在笔者撰写此文章的搜索过程中，发现部分盗版店隐藏极好，很难分辨。面对难以分辨的店铺，各位还请多看多学多问，增加对抱枕中较著名款式的认知，可帮助您更好地分辨盗版店。\n图片数量所有宣称百万图库的店铺，多为盗版店铺。\n所谓百万图库、海量图库，并非店铺所持有的，其实际上是由生产盗版枕套的代工厂所提供的。此类店铺均为代工厂的代理。通常，你可以在其他店铺看到同样的一批商品介绍图，其均为代工厂提供。\n同一⻆色具有多个不同的抱枕图，需提高警惕。\n由于原创店铺的主要成本即为约稿稿费。除非此⻆色卖爆，否则原创店铺很少会对同一个⻆色发售两个或以上数量的抱枕。且同⻆色也一定会穿着不同的衣服，与别的作品区分开来。\n使用编号命名由于盗图来源复杂，存在⻆色冷⻔、原创⻆色等现象，导致代工厂或店铺，可能并不知晓图中⻆色是谁。为了方便，便会采取编号命名的方式进行管理，并按照⻆色属性，如萝莉、御姐、兽耳娘等进行简单区分。\n若商家无法给出明确的⻆色名称或画师，极大概率为盗版商家。\n来图定制通常来说，原创店铺也会接代工业务。但是，其并不会写在所有商品的介绍里或者头图中。一般为单开一个商品专用于来图定制服务，且主要服务自行约稿的大佬，不接随意的网络图片。\n盗版商家经常会将来图定制与海量图库写在一起，且对来图定制毫无审核，照单全收，给钱就干。\n图片质量极高&#x2F;知名日本画师高质量的图片或知名画师意味着高额的稿费。若一个店铺图片质量普遍极高，大量（超过 10 个）日本大牌画师抱枕售卖，极有可能为盗版店铺。不同商品以画师作为区分，而非⻆色；同一商品下具有多套抱枕图（常⻅于毛玉牛乳、rurudo、mignon等知名日本原创⻆色抱枕画师），基本为盗版店铺。请仔细比对，检查是否符合本文提到的其他特征。若无把握请询问等身抱枕吧吧友或其他抱枕讨论群群友。\n此类盗版店铺中存在部分，仅上架日本知名画师抱枕，对于萌新来说分辨难度极大（典型的如：萌娘法则）。其为了吸引以画师名搜索抱枕的小白，商品标题多数都会标有画师名称。如存在大量知名画师，且此画师名下多数抱枕均可购买，基本可以确认为盗版店。关于如何知晓日本画师曾经绘制的抱枕，请参考后续章节“该在哪里找日版枕？”。\n目前，仅有极少数国内抱枕商家有向日本大牌画师约稿的经历，或作为日本画师代理在国内销售抱枕。\n作品风格不统一店铺的商品⻛格，受店主个人喜好影响极大。因此，多数原创店铺的⻛格相对来说比较统一，受众群体相对固定。\n除部分以寄售为主的店铺，基本不会出现萝莉与御姐大量同框的情况。\n非抱枕图印制抱枕盗版店为获取更多利润，部分情况下会将一些插画印制为抱枕。基本特征是：人物部分肢体不在画布中（如手或脚），人物脸部占画布范围极大。\n图片细节怪异部分盗版店铺甚至有胆截图展示经过算法放大后的部分区域高清图。笔者难以形容经过算法放大后图片那种明显的质感，建议有条件的玩家使用waifu2x-caffe放大下玩玩，您就知道这种质感为何物了。\n4、盗版店铺的运营模式盗版店铺的运营模式通常有两种：代工厂代理与店主自运营。\n代工厂代理此为最常见、铺开最广的盗版店铺运营模式。包括图库在内的所有生产资料，均为代工厂所有，店铺仅为代理商，作为客服与消费者沟通。赚取代工厂代工价与售价之间的差价。\n无⻔槛，无固定投资，做一单赚一单。但因其商品简介通常使用代工厂提供的相关图片，同质化严重，较易分辨。\n老司机甚至能通过商品简介所用图片分辨其为哪家工厂的代理商。\n店主自运营此模式指不使用代工厂提供的海量图库，而使用经过算法发大后低价聘请廉价画师修补细节、扫描仪扫描并精修等行为处理后的图片的商家。\n其类图片为店主个人持有，通常自己会宣称为“高质量复刻”，甚至叫嚣比肩原版。\n不同的面料之间到底有什么区别？该如何选择？抱枕面料可归为 5 大类：全聚酯、桃皮绒、牛奶丝、毛毛绒和2WAY（或称为2WT）。除2WAY和毛毛绒外，其他面料笔者均不推荐。\n在详细介绍各种面料前，请容许我先简单介绍2WAY。作为最常用、也是最推荐的面料，2WAY全称为two way tricot fabric（双向经编织物），两种简称分别为取单词开头（即2WT）与选取双向编制一部分（即2WAY）。无论商家如何说他们的2WT和2WAY有什么区别，这两种实际为同一类织物，仅被用作区分不同层级的抱枕的参考而已。因为，不存在2WT和2WAY孰优孰劣。这与分辨⻄红柿与番茄哪个更好吃一样是相同的行为。\n全聚酯全聚酯是抱枕面料中最便宜的一种。其名字就来自于原材料的成分，完全由聚酯纤维纺织而成，也就是涤纶。\n由于只有涤纶，而没有氨纶，其不具有弹性，通常手感较硬。因节约成本考虑，通常不进行消光处理，因此反光非常严重，在有月色的夜晚甚至可以清楚看到抱枕图案。\n在欧美的入门指南中，将全聚酯比喻作防水布，这一点是非常形象的，甚至于下一档中的桃皮绒中的部分也是如此的手感。\n桃皮绒桃皮绒是相对全聚酯稍好的面料，其手感相对全聚酯较软，根据工厂的不同，部分具有轻微的绒毛感，但同样，弹性与亲肤性较差。\n牛奶丝牛奶丝最早指一种使用牛奶蛋白纤维纺织而成的面料，实际上现在常指的牛奶丝是指一种涤纶氨纶混纺的布料，根据其氨纶添加的多少，其手感与弹性具有很大的差异。\n其具有一定的，较弱的弹性与亲肤性。因其编制方法不容易勾丝且并不是非常滑，常用于床单。\n毛毛绒毛毛绒泛指一切表面具有柔毛的面料。通常来说，毛毛绒不具有弹性，且不同工厂之间毛毛绒差异巨大。如短毛绒、⻓毛绒、宝宝绒等。故不会做详细描述。\n其多用于制造毛毯。因抱枕面料多数在冬天刚接触时很冷，故可购买以用于冬日使用。\n因其表面绒毛，印刷精度基本不在考虑范围。\n2WAY&#x2F;2WT作为抱枕的主力面料，2WAY具有手感好、弹性好、印刷色彩艳丽等诸多优点。但同时因为2WAY指代所有通过双向经编纺织而成的布料，因其布料克重、氨纶的含量与品质、布料后处理、助剂成分及比例的不同，2WAY的上下限极大。\n通常在购买抱枕时，你可能⻅过各种奇形怪状的名字。\n如日本产的：A&amp;J、Fules、樱饼或白樱。\n中国产的有：SAS、黑樱、白雪、AC、枫糖、润雪、章⻥等\n也有按产地称呼的：新无锡、老无锡、怀化、广州、武汉\n甚至老板名来称呼的：糖包料、⻣头料\n以下会对各面料进行简单的介绍，但是不会进行详细评测与打分，如对评测感兴趣，请移步贴吧自行翻阅精品贴中的评测。请自行谨慎分辨软文，并注意评测时间。评测仅可作为参考，抱枕体感受个人主观感受影响极大，且国内多数工厂存在极大的品控不严的问题，无法稳定保证各批次手感稳定。\n其中，日版价格相对较高，多为 12000 日元，且由于日本采用限时发售的模式，通常萌新只能购买到加价后的二手，故不推荐萌新入坑直接上手日版。\n面料名A&amp;JA&amp;J实际为公司名，公司官网：https://www.a-and-j.co.jp/。通常直接称呼为AJ，其生产的面料被认为是抱枕中的顶级面料，现有两种版本： ライクトロン （Lyctron 可音译为莱卡特绒）与 ライクトロンリッチ （Lyctron rich 可翻译为莱卡特绒 艳丽）。为方便描述，通常称过去使用、现已停产的ライクトロン面料为老AJ，于 2023 年底新投入市场的ライクトロンリッチ为新AJ或AJ rich。\n优点\n极佳的手感，极其柔软、亲肤，即使在冬天，抱在怀里也会觉得暖暖的。\n缺点\n极佳的手感的副作用便是极度脆弱，极其容易勾丝，需要有良好的使用习惯。\n三大日版中印刷表现相对最差。\n识别特征\n\n\n\n标有A&amp;J字样的拉链\n品质表示纸\n\n\n\n\n\n\n\n\n根据时代不同，品质表示纸具有多种形式，不同批次印刷的颜色也可能深浅不一。\n\nFules同为公司名，公司官网：https://fules.jp/。其拥有三种面料，从旧往新分别为： アクアライクラ （FulesAquaLycra）、 アクアプレミア （Fules AquaPremier）、 アクアヴェール （Fules AquaVeil）。与AJ相同，旧版本的面料已经停产。常说的旧fules指アクアプレミア，新fules指アクアヴェール。\n优点\n日版三大厂中印刷颜色最艳丽的。手感、润滑度适中。\n缺点\n新fules相对旧fules更容易勾丝，面料手感相对偏硬。\n识别特征\n\n\n\n标有YKK字样的拉链\nveil品质表示纸\n\n\n\n\n\n\n\n\n\n\npremier品质表示纸\nlycra品质表示纸\n\n\n\n\n\n\n\n白樱、樱饼しろもうふ公司旗下面料，公司官网：https://shiromoufu.co.jp/。 白桜 （HAKUOU）为旧面料， 桜餅（SAKURAMOCHI）为新面料。\n优点\n日版三大厂中最耐用的一家\n缺点\n相对较硬，手感较差\n识别特征\n\n白樱\n\n\n\n\n标有YKK字样的拉链与品质表示纸\n水洗标\n\n\n\n\n\n\n\n\n樱饼\n\n\n\n\n标有YKK字样的拉链与品质表示纸\n水洗标\n\n\n\n\n\n\n\n其他日版品牌P80、DC麗、黑金等，因不常⻅，且部分面料品质甚至不如国产的，本文不详细说明。\nSAS PANDA生产工厂为国内的无锡市溢彩联天纺织品有限公司。圈内称为新无锡。通常简称为SAS。现自称升级为SAS 2.0。\n因同时生产其他面料，工厂介绍会放置于后续的以地区分类章节。其工厂有生产盗版枕套的业务，但其声明SAS不会印制盗版。\n识别特征\n\n蚀刻有SAS字样的YKK拉链\n\n黑樱、白雪生产厂商为国内的无锡十月十日网络科技有限公司。圈内通称老无锡。因老板昵称⻣头，故称呼⻣头料的时候也代指黑樱。\n因同时生产其他面料，工厂介绍会放置于后续的以地区分类章节。其工厂有生产盗版枕套的业务。\n识别特征\n\n⻣头称一枕一编号，抱枕套内可⻅水洗标\n\n外包装贴纸\n\n\nAC国产店铺AcHobby旗下面料。店铺：https://achobby.taobao.com。此店铺为画师个人店铺，店主为画师Noodle（面条），店铺内会有其他画师代理贩售的抱枕。\n因自身产能有限，不接受其他店铺的代工。\n优点\n不错的顺滑度与亲肤性\n缺点\n发货很慢、大部分批次存在逆向摩擦（即从下往下摸会感受到粗糙感，详细原因会于后续工艺及后处理相关章节介绍）\n识别特征\n抱枕套内有标签，此标签为2WAY材质\n枫糖国产店铺萌枕会旗下面料。店铺：https://moemakura.taobao.com。店主为糖包，故也称糖包料。 23 年末 24 年初新上的料子。\n工厂位于绍兴，目前仅生产枫糖一种料子，声明不会印制盗版。\n优点\n所有国产工厂中唯一提供了GB18401-2010 B类认证和SGS认证的工厂\n缺点\n新工厂，发货时效不稳定。\n识别特征\n\n品质保证卡\n\n润雪（已停产）国产店铺强热残分旗下面料。店铺：https://kancolle.taobao.com/。此店铺为画师个人店铺，店主为油漆娘，此店铺仅售卖全年龄作品。\n此面料为油漆娘亲自监督，颜色由画师亲自把控，手感也颇为不错，性价比极高。\n目前，此面料现已停产，油漆娘全面换用枫糖。\n章鱼欧美抱枕社团Cuddly Octopus旗下面料。网站：https://cuddlyoctopus.com/，国内店铺：https://moedim.taobao.com。此店铺主营欧美，国内仅为附带。生产于广州增城，生产厂家为广州市景彩数码科技有限公司。（注：章鱼料是专供章鱼的，你无法联系工厂获得）\ndakimakuri欧美抱枕社团Dakimakuri旗下面料。网站：https://dakimakuri.com/shop。此店铺主营欧美，可以网⻚下单，国内免运费。生产于广东。\n以生产厂家的地区名分类由于国内店铺对同一厂家的面料经常使用如四色、六色、八色来进行面料细分，此部分内容放置于下一章节详细说明。\n怀化抱枕店常⻅面料选项，如怀化3.6。\n价格便宜，较为常⻅。\n此工厂涉及盗版生意，委托制作的图片约会在一年后流入图库，出现盗版。\n老无锡无锡十月十日网络科技有限公司、无锡市剥桉纺织科技有限公司、深圳市南山区御宅领域商贸商行（已注销）。\n工厂自有店铺鹿初雪。店铺：https://luchuxue.taobao.com/。店铺原名：御宅领域动漫周边（因淘宝用户名无法修改，故可知），原为盗版店，现商品列表已无盗版产品，多为寄售，因寄售在此后不会被此工厂生产盗版。\n旗下2WAY面料包括：新作2WAY（即普通2WAY）、黑樱、白雪。\n此工厂涉及盗版生意，目前，其 1688 店铺已删除。\n新无锡无锡市溢彩联天纺织品有限公司。\n暂无自有店铺，其推广营销主要由紫瞳软萌动漫进行。\n旗下2WAY面料包括：2WAY（普通）、新2WAY（或new2WAY）、SAS。\n此工厂由老无锡分裂而来，成立初期，紫瞳与老无锡的⻣头骂战不断，笔者仅为旁观，吃瓜并不深入，在此就不讲古了，有兴趣的请自行询问其他大佬。\n此工厂涉及盗版生意，如：紫瞳经营原创店铺的紫瞳软萌动漫的同时继续售卖盗版枕套。\n广东萌工坊广东萌工坊实业有限公司。\n著名毒瘤，描图盗版大团队。著名百万图库的拥有者。无数盗版店铺的总教头。\n武汉麦芽糖武汉易帛数码纺织科技有限公司。\n主销海外，料子一般，低调。\n其他默认垃圾\n四色、六色、八色都是什么意思？有什么区别？因印刷物的显色方式为反射发光，因此使用四色油墨CMYK，此为四色印刷。也就是标准印刷。通过添加其他色的油墨，扩大色彩的显示范围，增加色彩的丰富度。实际上的六色、八色印刷，与清晰度毫无关系，清晰度是由印刷机打印头精度决定的。\n需注意，影响色彩表现的不只颜色数，其同时受到油墨品质、打印机喷头、转印纸品质、转印机品质、布料等影响。同时，添加额外色彩的色彩提升效果递减。提升微乎其微。\n以日版厂举例，A&amp;J要求CMYK入稿，证明其为四色印刷。据Fules推特披露的机器图片，此机器仅支持最高六色打印，使用RGB入稿，说明其应该采用的是六色印刷。然而这两种面料色彩表现超过部分国内自称八色打印的产品。\n现存国内代工厂所谓X色，更多的是区分产品品质和产品价格用途。实际情况难以考证，无从可知。\n抱枕面料不同手感之间的差异是怎么来的？纺织时的原料纱与后处理工序中的助剂是主要影响抱枕手感的两大因素。\n原料纱的品质和添加量，决定了一款抱枕面料最基础的数值。其中氨纶价格高出不少，对手感的影响比重较大。通常的氨纶添加量在18%～20%。其使抱枕面料具有柔顺的手感与弹性。同时，纺纱的支数、布料的克重均对抱枕手感影响颇大。如部分面料中出现的逆向摩擦现象，即为编制密度过高导致的。\n后处理工序是对原料布进行的二次加工，经过此工艺后的布料才是印制抱枕的原料。此工艺中，会添加各种纺织助剂，通过助剂的添加，可以起到如抗菌、香味、使布料手感软化、更加顺滑等效果。但是，添加过多助剂，会直接导致布料耐用性下降，更易勾丝、起球等。同时，每次洗涤，都会导致助剂被洗掉。因此，过多的洗涤会导致抱枕手感下降，但通常来说，并不明显。若几次洗涤之后，布料手感下降明显，基本可以确定此面料助剂添加较多。\n无论哪款布料，都会遵循不可能三⻆，即：生产成本够低、手感够好、耐用性强三者无法同时满足。且手感与耐用性基本成对立关系，意图同时提升两种带来的成本提升巨大。无论哪种布料，均只能从其中选择一个平衡点。\n该如何选择枕芯？枕芯同样是影响抱枕手感的重要一环。过小的枕芯可能导致无法撑起枕套，松松垮垮毫无手感。过大的枕芯可能导致抱枕面料撑得太开，能摸到明显的颗粒感，⻓期使用也会把枕套撑大。\n枕芯通常通过填充物归类，分为PP棉和羽绒棉。其他的具有品牌名的枕芯，多数难以通过此方法进行归类，故会单独列出。\n枕芯具有寿命，根据使用习惯与填充物，通常在 1 到 2 年。之后弹性可能出现明显下降，或产生结块、分段等现象。枕芯由工厂使用充绒机填充，重新手填可一定程度上改善，但作用甚微。\n枕芯十分看个人的喜好和习惯。如果不想看详细介绍，笔者推荐萌新采用由油漆娘出品的Q柔雏或Q柔莲（https://item.taobao.com/item.htm?id=607398645641），性价比高，且体感舒适。这是最终的归宿（笑）。不要迷信日本产或枕芯重量。等待Q柔发售的时间，买个PP棉的枕芯凑活用，等Q柔到了就扔（土豪玩法）。\nPP棉最便宜的选择，通常其枕芯皮是无纺布或者棉布。手感较硬，棉芯基本是一个整体，夹着用一段时间极易断层。属于快速消耗品，且体验一般。\n常⻅于便宜公仔、方枕的填充物。\n羽绒棉常⻅的选项，枕芯皮通常为棉布、2WAY或起毛2WAY。不推荐普通2WAY枕芯皮，与2WAY枕套之间滑动严重，手感不佳。羽绒棉枕芯根据重量不同，具有不同的手感，整体手感较软。如某个区域经常受力，可能出现棉花跑开，此区域棉花变少，其他区域棉花变多的下凹的情况（葫芦形）。\n过重、过大的枕芯可能并不会带来很好的体验，请根据个人习惯与喜好选购。\n虽名为羽绒棉，其实不是羽绒也不是棉，依旧是一种化纤。化纤是最适合作为抱枕芯的材料。笔者不推荐玩真羽绒这种花活，保暖效果太好且价格过于昂贵，实际体验不⻅得会好到哪里去。\nQ柔系列国产店铺强热残分旗下枕芯。现有 3 种款式：姬、雏、莲。\n商品链接：https://item.taobao.com/item.htm?id=607398645641\n详细介绍请观看商品详情中的介绍，此处复制部分商品的介绍。\n姬：手感偏向软糯，柔软度高，体积偏大，不易断层，重量约为4kg，三款中最重。莲：手感靠拢姬，体积靠拢雏，高度鼓鼓的，重量约为3.6kg，三款中最适中。雏：手感如果冻般轻弹，体积偏小，重量约为3kg，三款中最轻。\n笔者不推荐萌新购买姬，体积相对较大，陪睡用途并不舒服。如喜欢压着抱枕或有其他喜好请按需购买。具体购买建议参考商品内的详细介绍。\nDHR系列DHR系列中常用的为DHR7000H和DHR7500。\n商品链接：https://www.a-and-j.co.jp/item/cate13/20181105-46/\nA&amp;J旗下枕芯品牌。其中 7000 相对更厚更软， 7500 相对更薄更弹。两者重量均适中。\n由于日本运输回国价格较高，且运输时间⻓，⻓时间压缩对抱枕芯的恢复有不可挽回的影响。故不建议国内购买。建议从日本回国时旅行箱自行带回使用。否则千元购买实属不必。\n其他以下枕芯为不常⻅品种，笔者并未购买尝试，如有兴趣可参考欧美圈子评测。\n国内店铺绝对萌域曾出品过MHR7000与YHR7000，为仿造DHR命名的产品。\n日本Fules公司旗下品牌：ウィズアクア与ウィズアクアNEXT。\n日本しろもうふ公司旗下品牌：まるみみ。\n应该如何洗涤、收纳及保养我的抱枕？洗涤洗衣液选择中性洗衣液即可，无过多讲究。柔顺剂对抱枕手感有无影响，笔者并未尝试，也未⻅相关讨论，故不建议尝试。建议使用常⻅大品牌洗衣液即可。\n如使用手洗，建议佩戴橡胶手套，或提前修剪指甲，防止搓洗时勾损。\n如使用机洗，请搜索内衣洗衣袋，选择较为厚实的款式，可有效避免机洗过程中抱枕的损伤。\n晾晒由于2WAY面料不吸水，阴干一至两天即可。也可使用干衣机，约半小时即可干透（吉吉国王或南方回南天）。\n由于2WAY弹性较好，建议使用落地晾衣架平坦放置，或使用两根衣架分别在抱枕的1&#x2F;4与3&#x2F;4处挂着，使抱枕成M状晾晒。防止由于重力拉⻓抱枕套。\n收纳收纳根据个人习惯、生活环境，自由选择。\n若喜好美观，可采用一次性透明包装袋收纳。在意可重复利用，可使用自封拉链袋。若所处环境较为潮湿，担心枕套发霉，可使用⻝品密封保鲜袋（选择大号）。\n折叠方式可参考贴吧其他大佬的分享：\n\nhttps://tieba.baidu.com/p/7738197722 \nhttps://tieba.baidu.com/p/8894525580 \nhttps://www.bilibili.com/video/BV1p8411Y7iZ\n\n个人卫生想要抱枕用得久，个人卫生不能少。\n建议抱抱枕前先洗澡再上床贴贴。\n勤剃胡须、注意腿毛。毛发是抱枕起球的一大主要原因。\n勤剪指甲，并在剪指甲后打磨指甲。过⻓的指甲极易勾丝，一勾一⻓条。请勿使用指甲刀自带的锉刀磨指甲，此会导致指甲更易勾丝。搜索指甲打磨搓条，每次剪完指甲，修修指甲边缘可能存在的凸起即可。\n为什么在二手交易平台上，有些日本产的枕套这么贵？由于日本售卖枕套采用限时预定的方式，甚至部分枕套仅在展会线下售卖。导致部分枕套存在供需的极度不匹配。\n故存在倒爷这一群体，在预定期间大量囤货，并在预定期结束后，提高价格销售。如猫娘乐园官方抱枕，仅在游戏发售时同捆销售，市场存量少，目前市场价非常离谱。\n笔者不推荐各位玩家高价购买。毕竟未来，或许会有更好看、更戳你的枕的出现。若因为对部分⻆色或画师有特殊的执念或其他的原因，请自行多方比对价格，期望您能早日圆梦。\n该在哪里找日版枕？此部分内容默认您具有科学上网能力。\n通常的贩售平台为booth（https://booth.pm），以下为常用抱枕情报站。\n\nhttp://omiai-dakimakura.com/ (推荐)\nhttps://imoutoroot.com/ (日本人常用)\nhttp://www.nijigenshingu.info/ (仅官方抱枕)\nhttps:&#x2F;&#x2F;埋もれる抱き枕er.jp&#x2F; (2015年停止更新)\n\n购买、代购、转运等相关内容，本文不做介绍或推荐。\n笔者对AI抱枕的态度由于⻆色热度等原因，终究会有许多老婆无法有高质量的抱枕。因此，笔者虽不支持AI抱枕，但也并不反对其存在与发展。当前时代下，AI抱枕⻛格极其明显，较易分辨，其店铺多数也并无遮掩。但是，对于混淆视听的行为，笔者还是会进行谴责的。瞎写的稿费参考还是要点脸吧，有点太过分了，看了真的绷不住😂。\n写在最后相比笔者入坑时的莽荒时期，现在的买家有了更多的选择，希望读完这篇文章，能为您省下不少学费。感谢现在玲琅满目的原创抱枕店家为我们提供了如此多的选择，期望未来抱枕市场能发展得越来越好，为各位玩家提供更多高质量的抱枕。\n由于笔者退坑已久，对国内抱枕的了解与资料并不多，所述内容或有纰漏。如有图片补充，或错误指正，请邮件联系。此邮箱并不会经常检查，若信息未能及时回复，还请稍安勿躁。称呼方面，叫我达就好，此化名取自抱き枕的第一个音节。\n如需转载本文完整内容或部分内容，无需发送邮件询问，写明来源即可。\n达\nEmail: ilovedakimakura@gmail.com\n2024 年 3 月 16 日\n","categories":["教程"],"tags":["教程","资源检索","二次元","转载"]},{"title":"简历制作工具合集","url":"/2025/04/14/%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/","content":"简历工具easy-go-resume本人开发的简历制作工具\n项目地址：https://github.com/whitehair-failure/easy-go-resume\n在线地址：www.lolimama.love/easy-go-resume\n简历模板示例:\n及时简历洋大人搞的简历，内置九种模板，还可以自定义CSS样式\n项目地址：https://github.com/AmruthPillai/Reactive-Resume\n在线地址：及时简历 - 免费开源的简历生成器\n简历模板示例:\nopen-resume同样是洋大人搞的，只有一种模板\n项目地址：xitanggg&#x2F;open-resume\n在线地址：OpenResume - Free Open-source Resume Builder and Parser\n简历模板示例:\n\n以下的简历制作工具内容转载自流氓网站CSDN的博客：【工具】推荐几款免费且好用的简历工具_amruthpillai-CSDN博客，作者：花神庙码农\n\n极简 Polebrief\n极简简历是 polebrief 简历一个专业免费的个人简历制作平台。 在线简历引领者，带给你不一样的体验，拥有专业简历模板，为求职者提供专业极简的简历模板，三分钟制作一份简历，可随时随地将在线制作的简历下载为图片、PDF、Word 格式文件。\n链接：https://www.polebrief.com\n\n简历下载\n非常不错的简历模版下载网站。免登陆一键下载，完全免费无套路。\n链接：简历下载\n\n木及简历\n木及简历是一款免费的（免费部分够用）简历制作工具, 利用 Markdown 的形式提供在线简历服务, 简历制作简单, 丰富的 Markdown 简历模板任你选。\n链接：https://www.mujicv.com/index.html\n\n热速美斯\n热速美斯是一款免费的简历制作工具，无需登录即可使用，本地存储保护隐私，拖拽组合，制作简单，还有丰富的简历模板任你选。\n链接：https://www.resumeis.com/\n\nmyresumes\nA one-of-a-kind resume builder that’s not out to get your data. Completely secure, customizable, portable, open-source and free forever.\n链接：https://myresumes.cn\n\nhloom\nWriting a Resume Is Easier Than Ever with Hloom’s Resume Builder. Choose from hundreds of free downloadable templates in the Hloom library to kick-start your resume writing.\n链接：www.hloom.com\n\nflowcv\nThat’s why we created FlowCV: not only does it help you with inputting your text in a cohesive and readable way, it also makes it really easy to wrap your resume into an eye-popping and professional design. Basically like you hired a designer but without the price tag.\n链接：https://flowcv.com\n\ngood resume\nGood Resume is a high quality collection of resume designs, resume ideas, professional cv, resume templates in PSD, Ai, EPS, PDF, INDD &amp; CDR All Resumes Free Resume Files.\n链接： https://good-resume.com/\n\nAmruthPillai 简历生成器\nAmruthPillai 开源的一个在线简历生成工具。\n链接：https://github.com/AmruthPillaihttps://www.amruthpillai.com/\n\n富哥专用的简历生成器登录开始写简历，多端同步，数据云端保存，人死数据还在。\n\nCodeCV简历 - 免费的专业在线Markdown简历制作工具\n简历本_一个专门写简历的网站_简历模板下载_免费简历制作\n写简历从未如此简单 - 简历模板在线制作 - 老鱼简历\n\n以上的简历模板不够花里胡哨？去canva找简历模板罢：範本\n简历主题色选取颜色是很重要的，颜色对人的影响是很大的。在中国，黄色代表色情，在日本，粉红色代表色情，在欧美蓝色代表色情。归根到底就是宣传导致的，早期卖片的都会在店面装饰上特定的颜色来进行宣传，久而久之，特定的颜色就代表上了特殊的意义。\n黄色电影 &#x3D;&#x3D; Blue Film &#x3D;&#x3D; ピンク映画\n所以简历的主题色的选择就很重要了，颜色就是人们的第一印象。好的主题色可以让你在简历脱颖而出。\n不知道什么够色？快上车 👉 色圖網站\n面试指南\n\n","categories":["工具合集"],"tags":["教程","分享","资源检索","二次元","转载"]},{"title":"红米note4X 个人玩机优化教程","url":"/2024/12/13/%E7%BA%A2%E7%B1%B3note4X-root-%E6%95%99%E7%A8%8B/","content":"准备工作（root）现在网上有关root的视频图文教程一大堆，我还再写个鸡毛啊，看视频不就行了😅\n\n\n\n\n\n\n\n省流：\n\n解锁boot loader\n刷入twrp\n\n个人刷入的包是“MIUI12+20.6.11安卓9+极限精简V4”，刷入方式为卡刷，原作者不明，来源酷安红米note4x版块\n天翼云盘 （访问码：7foa）\n移动云盘  提取码:MEx8\n日用体验优化老版本安卓专用的远古的黑域补丁，仿造的苹果的后台管理机制：黑域一键补丁\n因为包的底层为安卓9，Google到了安卓10才在系统添加了全面屏手势，可以下载软件替代，流体手势导航\n再安装scene进行性能管理就行了，主力机日用建议全局开极速模式来保证流畅度，休眠就开启省电模式\n使用体验买来体验刷机玩玩还可以，日用的话是相当难受的，使用微信小程序都能卡半天，4G信号也不好，但是拿来当MP3音乐播放器，遥控器也是相当不错的选择，绝境下的备用机也是不错的选择，勉强能用，不至于和世界失联\n","categories":["玩机"],"tags":["玩机","教程"]},{"title":"英语学习笔记","url":"/2023/04/29/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/","content":"导读语言学习没有捷径，只要听说读写这四大行长期日复一日的练习就行了，兴趣是最重要的，兴趣就是高效学习的基础和长期坚持下去的动力。\n0基础开始痛苦学习大半年英语，没兴趣的结果就是词汇量是上去了，但是英语的听说读写水平还不如学了一年的日语。😅\n学习语言就是为了终有一天能和憧憬的对象语言相通的一天啊。🤤 憧憬，是距离理解最遥远的感情。😎\n该笔记基于此课程： 英语的平行世界官方学习指南丨学习顺序（图文版） - 哔哩哔哩\n英语过去式规则变化1、一般情况下，动词原形词尾加 -ed\n\n\n例词\n过去式形式\n\n\n\nwork\nworked\n\n\nplay\nplayed\n\n\nwant\nwanted\n\n\nact\nacted\n\n\n2、以不发音的 -e 结尾动词，动词词尾加 -d\n\n\n例词\n过去式形式\n\n\n\nlive\nlived\n\n\nmove\nmoved\n\n\ntaste\ntasted\n\n\nhope\nhoped\n\n\n3、以一个辅音字母结尾的重读闭音节动词，双写词尾辅音字母，再加 -ed\n\n\n例词\n过去式形式\n\n\n\nstop\nstopped\n\n\nplan\nplanned\n\n\n4、以辅音字母 + y结尾的动词，把-y变为-i 再加-ed\n\n\n例词\n过去式形式\n\n\n\nstudy\nstudied\n\n\ncopy\ncopied\n\n\ncry\ncried\n\n\ncarry\ncarried\n\n\n英语现在分词变化规则1、一般情况下，直接在动词后加-ing.\n\n\n例词\n进行时形式\n\n\n\nwork\nworking\n\n\nsleep\nsleeping\n\n\nstudy\nstudying\n\n\ngo\ngoing\n\n\nplay\nplaying\n\n\nknow\nknowing\n\n\nwalk\nwalking\n\n\neat\neating\n\n\nbeat\nbeating\n\n\nsing\nsinging\n\n\n2、动词以不发音的-e结尾，要去-e加-ing.\n\n\n例词\n进行时形式\n\n\n\ntake\ntaking\n\n\nmake\nmaking\n\n\ndance\ndancing\n\n\nwrite\nwriting\n\n\narrive\narriving\n\n\ncome\ncoming\n\n\n3、以重读闭音节结尾，且词尾只有一个辅音字母时，先双写这个辅音字母，再加-ing（重闭单辅先双写）.\n\n\n例词\n进行时形式\n\n\n\ncut\ncutting\n\n\nput\nputting\n\n\nbegin\nbeginning\n\n\nrun\nrunning\n\n\nstop\nstopping\n\n\nprefer\npreferring\n\n\n4、以-ie结尾，先将-ie改成y，再加-ing.口诀：现在进行ing,以e 结尾要去e，除去几个特殊词，系住tie-tying死去die-dying要躺下lie-lying，直接ie变成y.\n\n\n\n例词\n进行时形式\n\n\n\nlie\nlying\n\n\ntie\ntying\n\n\ndie\ndying\n\n\nG001 名词复数元音字母:A,E,I,O,U;其余为辅音字母可数名词可数名词单数 : coat, dress, job, hat可数名词复数变化:\n\n\n可数名词复数规则变化 :\n\n\n\n①+s: coats, jobs, bats\n\n\n②s,x,ch,sh结尾+es: dresses, boxes, watches, dishes\n\n\n**③辅音字母+y结尾，y→i+es: **city→cities, baby→babies\n\n\n④元音字母+y结尾，加s: boy→boys, play→plays\n\n\n**⑤O结尾，有生命的+es,无生命+s: **potato→potatoes, tomato→tomatoes ,  photo→photos, zoo→zoos\n\n\n⑥f, fe结尾,变f,fe为ⅴ再加es: wife→wives, leaf→leaves\n\n\n\n\n\n可数名词复数不规则变化 :\n\n\n\n①man→ men  Child→ children  foot→ feet\n\n\n②单复数同形: deer, fish(同种鱼)   fishes(不同种鱼)\n\n\n**③只有复数:**people, police\n\n\n**不可数名词:**air, water……\nG002 be动词的数\n\n\n第一人称单数: am\n**其否定形式: ** am not\n\n\n\n**例: I am a fish. **\n**I am not a fish. **\n\n\nI am a good boy.\nI am not a good boy.\n\n\n\n\n\n第二人称单数or第一,二,三人称复数:are\n\n\n\n其否定形式: aren’t\n\n\n例: 第一人称复数: We are &#x2F;We’re   family.\n\n\n第二人称单数:You are &#x2F;You’re  a pig.\n\n\n第三人称复数:They are&#x2F;They’re (例:The students are)\n\n\n\n\n\n**第三人称单数: **is\n\n\n\n其否定形式: isn’t\n\n\n例:He is &#x2F; He’s\n\n\nShe’s &#x2F; She’s\n\n\nIt is &#x2F; It’s (例:The cat &#x2F; book is)\n\n\nThat &#x2F; This相当于It,所以是 This is ,That is\nThese &#x2F; Those相当于They,所以是 These are,Those are\nG003 动词的数(句子中时态为一般现在时,主语为第三人称单数时,谓语需用第三人称单数)\n\n\n时态: 一般现在时\n主语: 三单\n谓语: 三单\n\n\n\nalways, often, usually, sometimes, never,\nhe\n①+s: rains, snows, likes\n\n\nevery time, every day, every minute,\nshe\n②s, x, sh, ch, o结尾+es: guesses, fixes, washes, teaches,goes, does\n\n\nonce a week &#x2F; month……\nit\n③辅音字母+y结尾，y→i+es:Fly→Flies, carry→carries\n\n\n\n\n④不规则: have→has\n\n\n练习\nI learn English every day.(learn)\nShe learns English every day.(learn)\nMorty studies English twice a week. (study)\nMorty teaches English on the internet. (teach)\nSummer goes to school by bike. (go)\nThe sun never shines in winter. (shine)\nI have a dream. (have)\nWe all have a dream. (have)\nMorty has a dream. (have)\n\nG004 动词时态初级\n\n\n过去时的规则变化\n\n\n\n①+ed: answered, played, looked \n\n\n②不发音e结尾+d: arrived, moved, telephoned, (see≠seed)\n\n\n③重读闭音节，辅元辅结尾，双写辅音字母+ed:stopped, planned\n\n\n④辅音字母+y结尾, y→i+ed: carry→carried, study→studied\n\n\n不规则变化大多,还是翻书吧\nG005 形容词副词的级\n\n\n原型:\n比较级:\nadj.&#x2F;adv.\n最高级:\nadj.&#x2F;adv.\n\n\n\nsmall\n①+er:\nsmaller\n①+est .\nsmallest\n\n\ntall\n\ntaller\n\ntallest\n\n\nsoon\n\nsooner\n\nsoonest\n\n\nlarge\n②不发音e结尾+r\nlarger\n②不发音e结尾+st\nlargest\n\n\nnice\n\nnicer\n\nnicest\n\n\nbig\n③辅元辅结尾,双写辅音字母+er\nbigger\n③辅元辅结尾, 双写辅音字母+est\nbiggest\n\n\nhot\n\nhotter\n\nhottest\n\n\npretty\n④辅音字母+y结尾,y→i+er\nprettier\n④辅音字母+y结尾, y→i+est\nprettiest\n\n\nbusy\n\nbusier\n\nbusiest\n\n\nexpersive\n⑤ 双音节或多音节前+more或+less\nmore&#x2F;less  expersive\n⑤双音节或多音节前+most&#x2F; least\nmost &#x2F;least expersive\n\n\nimportant\n\nmore&#x2F;less  important\n\nmost&#x2F;least  important\n\n\nquickly\n⑥大部分副词的比较级\nquickly→more quickly\n**⑥大部分副词的最高级:  **\nquickly→most quickly\n\n\ngood&#x2F;well\n⑦不规则\nbetter\n⑦不规则\nbest\n\n\nbad\n\nworse\n\nworst\n\n\nlittle\n\nless\n\nleast\n\n\nmany&#x2F;much\n\nmore\n\nmost\n\n\nG01 名词短语一、句子句子  &#x3D; 主语（成分）[词性n.名词] + 谓语（成分）[词性 v.动词]\n二、名词短语名词短语 &#x3D;  限定词 +  修饰词 +  主体词 \n三、限定词的分类：\n冠词: a&#x2F;an，the\n\n形容词性物主代词: my，his\n\n名词所有格: one’s，Tom’s\n\n指示代词: this，that\n\n不定代词: some，every，another\n\n基数词: one，two\n\n疑问代词: what，which\n\n\n\n\n\n限定词\n修饰词\n主体词\n\n\n\na\ngood\nboy\n\n\na\n\nboy\n\n\n1.countable(可数名词\ngood\nboys\n\n\n复数形式省略限定词)\n\nboys\n\n\n2. uncountable(不可数名词\ngood\nnews\n\n\n省略限定词)\n\nnews\n\n\n3. 专有\n\nchina\n\n\n名词\n\nTom\n\n\nthe\nrich\n笼统 people\n\n\nthe\nbest\n明显 student\n\n\nthese\n\nbooks\n\n\n四、限定词的省略：\n可数名词复数\n\n不可数名词\n\n专有名词\n\n\n五、主体词的省略：\n笼统\n明显\n\n六、按要求构造名词短语：\n限定词+修饰词+主体词：a good boy，a beautiful day\n\n限定词+主体词：a boy，the weather\n\n修饰词+主体词：god boys，comfortable weather\n\n主体词：boy，time\n\n修饰词+修饰词+主体词： American country music\n\n限定词+修饰词：the rich，the good，the bad，the ugly\n\n限定词+修饰词+修饰词+主体词：a bright promising future\n\n限定词+限定词+修饰+主体词：all those best memories\n\n\nG02 感叹句一、判断词性What [词性] .n is your name?\nWhat [词性] .adj nationality are you?\nWhat [词性] .n pains us trains us.\nWhatever [词性] .adj mistakes you may make, trust yourself.\nHow [词性] .adv are you today?\nI wonder how [词性] .adv? (这里的how也可以看做是一个名词，因为wonder是一个及物动词，但是也可以看做是一种省略，比如说是I wonder how he did it. 所以这种情况下how仍然是一个副词)\n二、感叹句公式what + 名词短语 +（主+谓）\nHow + .adj &#x2F; .adv &#x2F; .v +（主+谓）\n三、感叹句造句What a beautiful world it is &#x2F; was &#x2F; will be !\nWhat good boys &#x2F; interesting boos &#x2F; beautiful girl they are! (后面用主语是they说明你得用可数名词复数，又因为是两个空，所以你可以在可数名词复数前面加一个形容词)\nWhat a day &#x2F; good boys &#x2F; good news!\nWhat news &#x2F; weather ! (因为后面只有一个空，而且又是在what后面只能填名词，所以只能填一个不可数名词，因为不可数名词可以不加限定词, 也可以是可数名词复数，比如What boys！)\n\nWhat beautiful weather!\nHow beautiful the girl is!\nWhat beautiful music!\n\n(beautiful weather 和 beautiful music都是名词短语所以用what，而beautiful是形容词，所以用how，后面the girl is是主谓)\nG03 可数与不可数名词一、写出下列名词的复数形式\n\n\n1. city\ncities：以辅音字母+y结尾，变y为i再加es\n\n\n\n2. class\nclasses：以s, x, ch, sh结尾，+es\n\n\n3. leaf\nleaves：以f &#x2F; fe结尾，把f &#x2F; fe变为v再加es\n\n\n4. tooth\nteeth：不规则变化，类似的还有foot变成feet\n\n\n5. potato\npotatoes：类似的还有tomatoes\n\n\n6. child\nchildren：不规则变化\n\n\n7. box\nchildren：不规则变化\n\n\n8. match\nmatches 同2\n\n\n9. knife\nknives 同3\n\n\n10. German\nGermans 正常+s\n\n\n11. sheep\nsheep 单复数同形，类似的还有fish, Chinese, Japanese 各种不同的鱼fishes，deer可以deers或者deer\n\n\n12. Chinese\nChinese 同上\n\n\n二、将下列词组译成英语\n\n\n13.一群孩子\na group of children\n\n\n\n14.十杯牛奶\nten glasses of milk 因为glass可数，milk不可数\n\n\n15.六碗米饭\nsix bowls of rice 因为bowl生下来就是碗的样子，所以可数，而rice虽然也是一粒粒的，但是你吃它的时候，都是数不清的一群\n\n\n16.五杯茶\nfive cups of tea 茶基本上还是水，杯子它妈把它生下来就是不杯子\n\n\n17.九块面包\nnine pieces of bread 法国那种长面包可以用loaf，表示一条。面包就是面粉兑水，都不可数，生下来也是一块，一条，一坨的\n\n\n18.一副眼镜\na pair of eyeglasses 眼镜因为是两个镜片，所以只有复数形式才能表示眼镜\n\n\n19.八块木头\neight pieces&#x2F;blocks of wood 树有固定的样子，但是木头没有。另外woods意思是树林、森林。ps：不是半藏森林\n\n\n20.多种植物\nvarious&#x2F;all kinds of plants\n\n\n三、选择填空\nI want to buy ____.\n\nA. two bottles of inkB. two bottle of ink\nD. two bottles of inks\n\nThey don’t have to do ___ today.\n\nA. much homeworkB. many homeworksC. many homeworkD. much homeworks\n\nThere are three __ and seven __ in the picture.\n\nA. cows, sheepsB. cows, sheepC. cow, sheepD. cow, sheeps\n\nSheep ___ white and milk ___ also white.\n\nA. is, areB. are, isC. is, isD. are, are\n选B 因为sheep单复数同形，而sheep前没有加限定词说明这里是复数，而milk是不可数名词\n\nHere are __ for you, Sue.\n\nA. potatosB. some potatoesC. three tomatosD. some tomato\n\nHow wonderful! The __ is made of ___.\n\nA. house, glassB. house, glassesC. houses, glassD. houses, glasses\n选A house可数，但后面用的is说明应该用单数，后面玻璃不可数\n\n\nMaths ___ an important subject taught in the middle school.\n\nA. areB. isC. wasD. were\n选B 数学是一门学科，看作单数。数学是一门重要的学科，是讲一般的状况，所以用一般现在时；后面的taught是非谓语作后置定语，不是过去式\n\nTwo *____* and *____* are studying Chinese at Beijing University.\n\nA. German, EnglishB. Germans, EnglishC. Germans, Englishmen\nD. Germen, Englishmen\n选C German的复数+s，英格兰人是Englishman，复数Englishmen\n\nDon’t hurry! We still have ___ time left.\n\nA. littleB. fewC. a littleD. a few\n选C time次数是可数的，表时间不可数，这里是表时间，不可数。而little和a little修饰不可数名词，前面说Don’t hurry！说明时间还不急，little表否定概念，表示几乎没有时间了；而a little表肯定概念，表示还有些时间\n\nThis is an interesting ___.\n\nA. newsB. informationC. workD. job\n选D 因为前面有个an，说明要接可数名词，这里面只有D是可数名词\nG04 人称代词一、按要求写出相应的词\n\n\n主格\n宾格\n形物代\n名物代\n反身代\n\n\n\nI\nme\nmy\nmine\nmyself\n\n\nYou\nyou\nyour\nyour\nyourself\n\n\nHe\nhim\nhis\nhis\nhimself\n\n\nShe\nher\nher\nhers\nherself\n\n\nIt\nit\nits\nits\nitself\n\n\nWe\nus\nour\nours\nourselves\n\n\nYou\nyou\nyour\nyours\nyourselves\n\n\nThey\nthem\ntheir\ntheirs\nthemselves\n\n\n二、判断正误\n This is my.\n\n错误。因为my是形物代，不能单独使用后面得加名词\n\n This is his.\n\n正确。因为his可以算作名物代\n\n This is his book.\n\n正确。his book为名词短语，可以做表语\n\n You is mine.\n\n错误。you是第二人称，不能用is\n\n Yours is mine.\n\n正确。yours指你的某样东西，比如说your money，可以接is\n\n Yours are mine.\n\n正确。yours也可以指your books，所以说可以用are\n\n Its a cat.\n\n错误。its是形物代或名物代，不等同于it is，改成it’s就正确了\n\n My parents always care about me.\n\n正确。about是介词，后面用宾格\n\n You should take care of you.\n\n错误。你应该照顾好你自己，前面有you了后面再出现用反身代，应改成yourself&#x2F;yourselves.\n\n It’s he.\n\n错误。he是主格做主语，不做表语，应改成him\n\n It is he who should be blamed.\n\n正确。这是强调句，强调的主语，所以可以用he\nG05 指示代词指示代词填空\nThere he is— that is him.\nthat; 首先，there be句型其实是一种完全倒装，不清楚的朋友去看G35，而我也说了，人称代词不用倒，所以这个句子是There he is，而不是There is he. 其次，there表达一个相对较远的距离，所以用that\n\nThis is Morty. —How do you do.\nThis；how do you do是第一次见面打招呼用的，说明前面在介绍，介绍用this is\n\nHello, is that Jim? —This is Tom speaking.\nThis；how do you do是第一次见面打招呼用的，说明前面在介绍，介绍用this is\n\nYou can’t be too careful these days.\nthese；意为这些天你再小心都不为过，讲的是近期的事情\n\nI will never forget those days.\nthose；我绝不会忘记，表回忆过去，是远期的，所以用those\n\nNo, not him. I don’t mean the Mr. Smith.\nthat；句意为不，不是他，我不是说那个史密斯先生\n\nHe’s just not that into you.\nthat；that的特别用法，它还有adv的意思，这里表那么\n\nOne of the most important questions they had to consider was that of public health.\nthat；这个句子相对较复杂，这里面还夹杂了一个定语从句“they had to consider”在修饰questions，引导词that做consider宾语被省略了，注意这里只能用that，因为前面有最高级；这句话的意思是他们不得不考虑的最重要问题之一是公共健康的问题，所以应该填the question，为避免重复，用that来替代\n\nSuccess and happiness belong to those who can realize their own strengths.\nthose，后面who引导定语从句，修饰those，代表那些人\n\nHuman facial expressions differ from those of animals.\nthose；人类的面部表情与动物的面部表情不同，两个比较的主体应该是对等的，expressions对expressions都是复数，所以用those来代替\n\n\nG06 不定代词 &amp; 疑问代词\n\n\n代词\n含义\n例子\n\n\n\nsome\n某些，一些\nCould you give me some advice?\n\n\nany\n任何，一些\nDo you have any questions?\n\n\nno\n没有\nThere is no milk in the fridge.\n\n\nevery\n每个\nEvery child deserves a good education.\n\n\neach\n每一个\nEach student needs a pen and a notebook.\n\n\nall\n所有的\nAll the guests have arrived.\n\n\nboth\n两个\nBoth of my parents are doctors.\n\n\neither\n任一\nYou can take either of these paths.\n\n\nneither\n两个都不\nNeither of us speaks Spanish.\n\n\none\n一个\nI would like to buy that one, please.\n\n\nanother\n另一个\nCan I have another piece of cake?\n\n\nother\n其他的\nThe other day, I saw your sister at work.\n\n\nmany\n许多的\nThere are many people waiting in line.\n\n\nfew\n很少的\nThere are few opportunities like this.\n\n\nseveral\n几个\nI have several things to do today.\n\n\nmost\n大多数\nMost of the students passed the exam.\n\n\nnone\n没有\nNone of the cookies were left.\n\n\n\n\n\n复合不定代词\nbody\nthing\none\n\n\n\nevery\neverybody\neverything\neveryone\n\n\nsome\nsomebody\nsomething\nsomeone\n\n\nany\nanybody\nanything\nanyone\n\n\nno\nnobody\nnothing\nno one\n\n\n填空1.There’s some butter in the fridge.\nsome 因为butter不可数\n2.There weren’t  any books in the house.\nany 因为books可数，且否定句（some和any都表一些，some用在肯定句，any用在否定和疑问）\n3.Would you like something to eat?\nsomething 这里虽然是疑问，但是暗含提供某物的意思，希望得到肯定的回答，用something比anything真诚\n4.Have you got any friends here?\nany 这里friends是复数，且疑问句\n5.There’s someone who wants to see you.\nsomeone 意思是有一个人想见你，后面是定语从句，也可以用somebody，但someone更舒服，更常见\n6.We didn’t have anything to drink.\nanything 这里是否定\n7.Do you know anything about her?\nanything 这里是疑问\n8.There is some food, but not much drink.\nis, much 前面food不可数，后面drink也不可数，意思是有一些食物，但饮料不多\n9.a few people arrived before the party started, but not many. (little, a little, few, a few, many, much)\na few，many 意思是一些人提早到了，表肯定概念，但是不多，人可数，所以用many\n10.We only have litte time left.\nlittle， time不可数，only表否定概念\n11.There are only few people at the beach.\nfew， people可数，only表否定概念\n选择12.____the twins enjoyed __ at the party yesterday.\nA. Both, themB. Both, themselvesC. Neither, themD. All, themselves\nB，twins是两个人，enjoy oneself表示玩得开心，因为前面已经有她们了（the twins），所以后面得用反身代词\n13.Which do you prefer, a bottle of orange or a cup of tea? ___ , thanks. I’d like a cup of water.\nA. EitherB. NeitherC. BothD. None\nB 表两个都不喜欢\n14.Would you like __ milk in your tea? Yes, just ___ .\nA. any, littleB. some, a littleC. much, a fewD. a little, some\nB Would you like这种句型表提供某人某物，希望得到肯定回答，所以用some，后面加一点儿，just a little\n15.____ is Lili like? Oh, she’s tall and thin.\nA. HowB. WhoC. WhichD. What\nD What’s Lili like，不是Lili喜欢什么，而是她长什么样？不是问她是谁，她是哪个\n16.Who is playing the piano in the next room? __ is Li Ping’s brother.\nA. ThisB. ThatC. ItD. He\nC 在某人不在场，彼此没见面的情况下，不用he，用it。比如说你敲门，别人问，who’s this? 你回答，it’s me\n17.– Is this your shoe? – Yes, but where is ______?\nA. the other one \nB. other one \nC. another one \nD. the others\nA the other （one）表示两者中的另一个\n18.There are many trees on_______ side of the street, and_______ of the trees is still growing.\nA．both; the number\nB．either; the number \nC．both; a number\nD．either; a number\nB 因为side用的单数，所以用either，用both也可以表示两者都，但得用sides；另外…的数目是the number of， a number of 是许多的意思\nG07 数词基数词: one,two,three\n\n\n整数\n1,2,3\n\n\n\n小数\n1.1, 1.2, 1.3\n\n\n分数\n分子用基数,分母用序数:1&#x2F;3 one third\n\n\n\n分子大于1, 分母变复数:2&#x2F;3 two thirds\n\n\n百分数\n100%, 80%\n\n\n一、写出对应的序数词\n\n\none\nfirst\n\n\n\ntwo\nsecond\n\n\nthree\nthird\n\n\nfive\nfifth\n\n\neight\neighth\n\n\nnine\nninth\n\n\ntwelve\ntwelfth\n\n\ntwenty\ntwentieth\n\n\nthirty-one\nthirty-first\n\n\nforty-nine\nforty-ninth\n\n\nfifty-eight\nfifty-eighth\n\n\n这里有个基数词变序数词的顺口溜：8去t，9去e，f变ve，变y为ie，后面再加th.\neight去掉t，再加th，就变成eighth；nine，去掉e，再加th，就变成ninth；f变ve其实是ve变f，为了押韵，比如five，就变成fif，再变成fifth；同理，twelve就变成twelfth；变y为ie的意思是，forty，变成fortie，再加th，变成fortieth. 这里要注意，four变成十四是fourteen，但变成四十是forty，中间少了一个u，这种细节要注意。其他整十的数以此类推。\n二、填空题12.December is the twelfth month of the year.\n13.The beautiful skirts are on show in the shop, Jane likes the ninth. (9)\n14.Rick is in his fifties. (50)\n注意：在某人几十岁的时候，是用基数词的复数，不用序数词\n三、选择题15.It took me _____ to finish my homework.\nA. a half and two hour\nB. two hour and a half\nC. two and a half hour\nD. two and a half hours\nD. 表达2.5个小时有两种方法：1，two and a half hours，因为two and a half＞1，所以接hours；2，two hours and a half，这种是two hours and a half hour的省略形式，因为hour重复了\n16.Tom bought _ for himself yesterday.\nA. two pairs of shoes\nB. two pair of shoe\nC. two pair of shoes\nD. two pairs shoes\nA. pair是双的意思，可数，鞋子也可数\n17.December _ is Christmas.\nA. twenty-five\nB. the twenty-fifth\nC. the twentieth-five\nD. twentieth-fifth\nB. 12月的第25天是圣诞节，第X天，是特指，前面要加the，然后第25是把twenty-five变成序数，是twenty-fifth，而前面的twenty不用变成序数形式\n18.There are _____ students in their school.\nA. nine hundred\nB. nine hundreds\nC. nine hundred of\nD. nine hundreds’\nA. 具体的数不加s，笼统的数才加s. 比如500–five hundred；成百上千–hundreds of\n19.There are _____ words in the text of the _ Lesson.\nA. hundred of, Fifth\nB. a hundred of, Fiveth\nC. hundreds of, Fifth\nD. hundreds of, Fiveth\nC. 前面一百个，和几百个单词都可以，一百个单词是one&#x2F;a hundred of，几百个是hundreds of; 后面是第五课，用序数词，第五是the fifth，结合前面讲的顺口溜f变ve\n四、分别指出数词做哪些成分\n\n\n20.80% of the students passed the exam.\n主语\n\n\n\n21.How many books do you want? I want five.\n宾语\n\n\n22.Seven plus five is twelve.\n表语\n\n\n23.There are six books on the desk.\n定语\n\n\n24.You two follow me.\n同位语&#x2F;代词\n\n\nG08 不定式、动名词、句子以及“形式主语”之始末\n\n\n\n\n\n\n\n不定式\nTo learn English well is very important\n\n\n动名词\nSmoking is bad\n\n\n句子\nThat you are a pig  is a fact\n\n\n\n作主语看作单数\n头重脚轻时,用it作形式主语&#x2F;宾语\n\n填空1.One-third is a number.\nis. 三分之一是一个数字，数字看作单数\n2.One-third of the students have come.\nhave. 三分之一的学生已经来了，学生是复数，学生的三分之一也是复数\n3.One-third of my time is wasted.\nis&#x2F;was&#x2F;has been wasted. 三分之一是主语，它的后置定语是时间，时间不可数，所以不管是时间的三分之一还是三分之一的时间都不可数。当然你甚至也可以说是将要被浪费，而用will be也是可以的\n4.To see is to believe.\n5.Seeing is is believing.\n6.That my class has sixty students is a fact.\n4-6 is. 不管是不定式、动名词还是句子，做主语都看作单数\n把下列句子改成it作形式主语或形式宾语的形式\n\n\n原型\n修改后\n解释\n\n\n\n7.To look after my sister is a burden.\nIt is a burden to look after my sister\n不定式to look after my sister做主语，用it来代替，改成：It is a burden to look after my sister.\n\n\n8.I think to look after my sister a burden.\nI think it a burden to look after my sister.\nI think是主谓，to look after my sister是宾语，a burden是宾补，注意： 宾语和宾补之间不用加动词。这个句子是宾语太长，所以应it做形式宾语，\n\n\n9.I think that to look after my sister is a burden.\nI think that it is a burden to look after my sister.\nI think是主谓，that是引导词，引导宾语从句，后面是一个完整的句子，从句里面 to look after my sister是主语，is a burden是系表。这里主语太长，用it做形式主语，改成：it is a burden to look after my sister. 再把前面的I think that加上\n\n\n10.We all think that she didn’t come here a pity\nWe all think it a pity that she didn’t come here.\nwe主语，all 同位语，think谓语，that she didn’t come here宾从，a pity宾补，宾语太长，用it作形式宾语\n\n\n11.Complaing without taking action is no use.\nIt is no use that complaing without taking action is no use.\n这里主语是动名词，太长，用it作形式主语\n\n\nG09 判断主语【主语从句、形式主语】找出下列句子的主语，并指出是由哪种词充当\n80% of the singers have finished their performance.\n\n80%，数词；相信这个不用再解释了吧？\n\nMost of the singers invited to the party are from American.\n\nMost，不定代词. 这个和80%的道理是一样的，most是不定代词，非常笼统，of the singers把它变小了，是后置定语\n\nThere were many people sleeping on the beach.\n\nmany people,  名词短语. there be句型的本质是倒装，be动词后面的才是它的主语\n\nThose were best memories.\n\nThose，指示代词.\n\nCare of the soul is a gradual process.\n\nCare，名词短语.\n\nHe who laughs last laughs best.\n\nHe，人称代词； who，（关系）代词. 这里是一个定语从句，主句的主语是He，从句的主语是who\n\nThat she will go is certain.\n\nThat she will go，主语从句；she，人称代词\n\nThree would be nice.\n\nThree，数词\n\nSit down please.\n\nYou，人称代词. 这是祈使句，主语You被省略了\n\nAll that is needed is a supply of oil.\n\nAll，不定代词； that，（关系）代词. 这是个定语从句，that is needed修饰all，all是主句主语，that在从句里面做主语\n\nGone are the days when we were young.\n\nthe days ，名词短语；we，人称代词. 这是一个倒装句，the days倒到are后面了，原句为The days are gone. 后面是一个定语从句，从句主语为we\n\nTo be or not to be, that is a question.\n\nthat，指示代词. To be or not to be怎么理解是难点，to be 和 not to be都是不定式，不定式有名词词性，而这个to be or not to be等同于question这个抽象名词，所以说做同位语；或者你也可以理解成是that的同位语，但是理解成question的同位语更好\n\nTo be a teacher is my dream.\n\nTo be a teacher，不定式\n\nBeing a teacher means a lot of responsibility but a lot of joy as well.\n\nBeing a teacher，动名词\n\nIt is no use crying over spilt milk\n\nIt，形式主语，人称代词； crying over spilt milk，真主语，动词名\n\nWhat pains us trains us.\n\nWhat pains us，主语从句； What，（连接）代词. 这是个主语从句，所以What pains us，整体做主语；主语从句内部，What又做pains的主语\n\nWhat I want to say is that they don’t really care about us.\n\nWhat I want to say，主语从句； I，人称代词； they，人称代词. What I want to say是主语从句做主语；I是主语从句内部的主语；they是that引导的表语从句的主语\n\nAll I want to say is that they don’t really care about us.\n\nAll，不定代词； I，人称代词； they，人称代词. 这个句子是定语从句+表语从句。I want to say修饰不定代词all，引导词that由于在从句做宾语省略了，All在主句中做is的主语；I在定从中做主语；they在that引导的表从中做主语\nG10 定语（定语的本质、后置定语、定语从句）\n\n\n定语分类\n\n\n\n前置定语: a good boy, America country music  [单个独立]\n\n\n后置定语: a boy under the tree  [短语句子]\n\n\n指出下列句子由哪种短语构成的定语\n\n\n\n\n\n\n\n1.The boy under the tree is Tom.\n介词短语\n\n\n2.The house built last year is impressive.\n过去分词短语\n\n\n3.The man next to me is a scientist.\n形容词&#x2F;介词短语\n\n\n4.There are many clothes to be washed.\n不定式短语\n\n\n划出后置定语5.I have nothing to say.\n6.The stadium being built is bigger than the one before.\nbeing built修饰the stadium很明显，而before修饰the one则不容易看出来，这又是一种省略，原来的句子应该是the one that was built before. 进而可以省略成the one built before，或者直接the one before.\n7.80% of the guests have come.\n8.The boy who offered me his seat is called Tom.\n9.The man sitting next to Mr. Smith is Jason.\n10.All I want to say is that they don’t really care about us.\n11.Among the biggest problems faced by those remote mountainous villages is the lack of experienced teachers.\n这个句子又出现了。首先**faced by…**修饰the biggest problems；其次，of…修饰the lack.\n12.All that is needed is a supply of oil.\nthat is needed；of oil. 同第10题，区别在于，第10题that在从句做宾语被省略了，而这个句子that做主语不可以省略，两个都是定语从句。另外of oil也在修饰a supply\n13.Care of the soul is a gradual process in which even the small details of life should be considered.\nof the soul；in which even the small details of life should be considered；of life. 首先of the soul在修饰care；其次 in which引导的是定语从句在修饰 a gradual process；最后，of life在修饰 the small details\n14.The book tells stories of the earthquake through the eyes of those whose lives were affected.\nof the earthquake；of those；whose lives were affected. 首先of the earthquake在修饰stories；其次，of those在修饰eyes；最后whose lives were affected在修饰those\n15.Ms Shen’s method of teaching is nothing like that of my teachers at Junior High school.首先Ms Shen’s method是名词短语做主语，of teaching把它变小，这是第一个后置定语，翻译的时候要变序，译为：沈老师的教学方法。\n其次，is是系动词，nothing是表语，这是一个主系表结构。所有人都没有看出nothing其实是不定代词，我说了笼统的名词有三种，名词短语，不定代词和数词。nothing也是非常笼统的，那么它后面的like that，就在修饰它，所以like that也是后置定语。\n而that这里替代的是the method，因为教学方法一定是和教学方法拿来比较。为避免和前面的Ms Shen’ method重复，所以用that来代替，那么that也笼统，所以of my teachers就在修饰that，也是后置定语\n最后这里my teachers也笼统，at Junior High school在修饰my teachers，也是后置定语。\n所以最后我们的结论是of teaching；like that；of my teachers；at Junior High school 都是后置定语，这是纯粹理性的判断。\n那么这个句子怎么翻译呢？我们先来看字面意思\nMs Shen’s method of teaching is nothing（沈老师的教学方法是nothing，什么都不是） \nMs Shen’s method of teaching is nothing like that（沈老师的教学方法是像那种教学方法的nothing） \nMs Shen’s method of teaching is nothing like that of my teachers（沈老师的教学方式是像我的老师们的教学方法的nothing，意译过来就是沈老师的教学方法和我的老师们的教学方法一点儿也不像） \nMs Shen’s method of teaching is nothing like that of my teachers at Junior High school. 最终的意思就是沈老师的教学方法和我初中老师们的教学方法一点儿也不像\nG12 动词分类 （助动词、实义动词、系动词）一、助动词（不能单独构成谓语）be动词 + doing&#x2F;done（动词形式）\n\n\n\nam\nis\nare\nwas\nwere\nbe\n\n\n\n情态动词 + do（动词形式）\n\n不单独构成谓语\n +do\n无人称变化\n有本身含义\n\n\n\n\ncan\nwill\nshall\nmay\nmust\nneed\n\n\n\ncould\nwould\nshould\nmight\nhave to\ndare\n\n\n狭义助动词 + do（动词形式）\n\n\n\ndo\ndoes\ndid\n\n\n\n完成助动词 + done（动词形式）\n\n\n\nhave\nhas\nhad\n\n\n\n二、实义动词：表具体动作\n\n\n动词类型\n后面必须加什么\n结构\n例句\n\n\n\n及物动词&#x2F;vt.\n宾语&#x2F;O\n主谓宾&#x2F;SVO\nI eat an apple.\n\n\n不及物动词&#x2F;vi.\n不加宾语\n主谓&#x2F;SV\nThe cat sleeps.\n\n\n不及物动词&#x2F;vi.\n加介词&#x2F;prep.\n主谓宾&#x2F;SVO\nShe listens to music.\n\n\n三、系动词：不表具体动作后加表语&#x2F;P（成分)，构成主系表&#x2F;SVP结构\n\n\n表状态\n表感官\n表变化\n表像\n\n\n\nbe\nfeel\nbecome\nseem&#x2F;appear\n\n\nstay\ntaste\nget\n\n\n\nkeep\nsmell\nturn\n\n\n\nremain\nlook\ngo\n\n\n\n注：以上每列下方填写的为任意选取的示例单词，列举仅供参考，非限定。\nG13 be动词,动词分类常见的be动词有哪些？am,is, are, was, were, be\nbe动词的不定式：to be\nam的ing形式：being\nwere的过去分词形式：been\n指出下列句子当中的助动词或系动词红色助动,橙色系动\n7.Don’t be shy.\n8.Being a teacher means a lot of responsibility.\n9.Don’t worry; be happy.\n10.She had had supper when I invited her yesterday.\n11.She has a dream to be a dancer.\n无。或者说to be里面的be可以算是系动词，has是实义动词。\n12.She did do her homework.\n13.She has done her homework.\n14.She did have done her homework.\ndid狭义助动词；have完成助动词。\n15.Does she do have done her homework?\nDoes狭义助动词；do狭义助动词；have完成助动词；done实义动词。\n16.Get up now.\ndid狭义助动词；have完成助动词。\n17.It‘s getting late.\n改错18.May you happy.\n在happy前面加be，May you be happy. 因为may是情态动词属于助动词，不能单独构成谓语，后面的happy是形容词也不可以构成谓语，所以加一个系动词be，表状态。\n19.Today a good day, I am happy.\n没错。这句话是一个坑，故意整大家的，其实没错。当然你在Today后面加一个is，再把“，”改成“；”或者加一个“and”也是对的，但是Today a good day并没有错，它是我高级语法才会讲到的独立主格结构。\n20.I think it a good story.\n没错。这是另外一个坑。大部分人可能想在it 后面加一个is，这是对的。这是宾从I think that it is a good story省略了that的样子。但是不要is也是对的，a good story做宾补，或者看做it的同位语都可以。\n21.I must say he might right.\nmight后面加一个be，I must say （that）he might be right. 和18题同样的问题，might是助动词，right是形容词，前面加一个be，才能算是正确的句子。因为助动词不能单独构成谓语，助动词+系动词就可以构成谓语了。这里之所以加系动词be，是因为他可能是正确的不表具体动作，所以用主系表结构。\n22.I’m sorry I should do it.\nI’m sorry I should have done it. 我表示抱歉的内容应该是我本来应该做而没做的，而不是我将来应该做的。\nG14 及物动词vt.与不及物动词vi.一、判断下列高亮动词是及物vt.还是不及物vi.\n\n\n判断\n答案\n\n\n\n1.Don’t bother me.\nvt. 因为bother后接了me\n\n\n2.I’m writing a book.\nvt. 因为write接了宾语a book\n\n\n3.I am writing.\nvi. 因为没有接宾语，就是在写作，写东西。没有强调具体在写什么东西。\n\n\n4.I usually get up at half past eight.\nvi. 没宾语。\n\n\n5.I got up late today.\n**vi.**没宾语，late是状语。\n\n\n6.It’s getting late.\n都不是，这里get是系动词，表变化。\n\n\n7.If you don’t speak English, go home.\n**vt. vi.**speak接English及物；home是副词，所以go不算接了宾语，还是不及物。\n\n\n8.Let’s go hiking.\nvt. 接了动名词hiking做宾语。\n\n\n9.She is gone.\n**vi.**没有接宾语，这里gone是vi done，表完成。也可以算作一个形容词，做表语。\n\n\n10.The food has gone bad.\n都不是。系动词，表变化。\n\n\n11.That’s all I have.\n**vt.**这个其实是个定语从句。主句That’s all. 完整。这里的that不是引导词，就是主语。后面的I have是从句，修饰笼统的不定代词all，然后从句have是及物动词，缺宾语，而定语从句引导词本来应该是that，但它做宾语被省略了。原句：That’s all that I have.\n\n\n12.That’s all I have got.\n都不是 。助动词，还是定语从句，have完成助动词，辅助got构成完成时。got是及物动词，缺宾语，引导词做宾语省略了。\n\n\n13.That’s where I study.\nvi. 这里就是学习，没有特别指学习什么。\n\n\n14.That’s where I studied English.\nvt. 这里studied的对象是English，所以及物。\n\n\n15.That’s what I study.\nvt. 这个主句是That’s，后面缺表语，是表语从句。从句里面study及物动词，缺宾语，what做了它的宾语。\n\n\n16.That’s where I was educated.\nvt. 这里was educated，被动即完整，整个句子的意思是，这里我接受教育的地方。虽然被动即完整，但是不能磨灭educate是及物动词这个事实。实际上，只有及物动词才能够有被动语态。所以只要看到被动语态，说明它就是及物动词了。\n\n\n17.Leaves turn yellow.\n都不是。系动词，表变化\n\n\n18.At last, the doctor turned up.\nvi. turn up这里是出现，露面的意思 ，没有接宾语。\n\n\n19.Could you please turn up the radio?\nvt. 这里turn up接了宾语the radio，意为调高收音机音量。\n\n\n20.I can use a cup of coffee.\nvt. use这里就是喝的意思，宾语是a cup of coffee.\n\n\n21.Tell me what use this machine can be of.\n名词。这是一个坑。这是“一人得道鸡犬升天”模型。这是一个宾语从句。从句里面主语是this machine，谓语can be，表语of what use. what use做of的宾语，what是形容词，修饰名词use.\n\n\n二、判断正误（如有错，请改正）\n I reached in Chengdu at 10:30.\n\n错。reach是及物动词，可以直接接宾语，把in去掉。\n\n She has arrived home.\n\n正确。arrive是不及物动词，后面不需要宾语，home是副词。\n\n She arrived in the airport at 19:30.\n\n错。arrive不及物动词，接宾语需要加介词，但是接the airport用介词at.\n\n I have no place to live.\n\n错。原则是是错的。因为no place是名词短语很笼统，to live做后置定语。但逻辑上live和place是形成动宾关系（具体高级语法再讲），而live是不及物动词，不能直接加place，所以需要在live后面加一个in. to live in no place.为什么说原则上是错的，因为实际文章当中，因为用得太多，in也可能被省略了。但理论上应该要有的。\n\n I have no one to talk.\n\n错。和上面同样的道理。to talk修饰no one. 逻辑上是动宾关系，to talk no one. 但是talk是不及物，不能直接接宾语，要在talk后加一个to&#x2F;with.\n\n I have no one to turn.\n\n错。和上面同样道理。turn to no one，所以在turn后面加to.\nG15 谓语的构成填空\n**实义动词（词组）**单独构成谓语\n\n系动词单独构成谓语\n\n助动词+实义动词&#x2F;助动词+系动词一起构成谓语\n\n\n复合谓语公式：情态动词+完成助动词+be动词+实义动词+介词\n按要求构造句子（注意是写句子）\n\n\n要求\n例句\n\n\n\n4.be+doing做谓语\nhe was going to play a game\n\n\n5.be+done做谓语\nShe**’s gone** from my life\n\n\n6.be+being+done做谓语\nYour car is being washed.\n\n\n7.情态动词+do做谓语\nI will take care of it\n\n\n8.情态动词+do+doing做谓语\nThey may be coming for us. 这里的do有点误导人，其实be也是do形式，do代表所有动词的原形，所以be也算一种do.\n\n\n9.情态动词+do+done做谓语\nYou shall be fired tomorrow\n\n\n10.情态动词+do+done+doing做谓语\nI will have been learning English for 15 years by the end of 2020. 这种时态有点变态，不要求掌握哈\n\n\n11.狭义助动词+do做谓语\nShe did come yesterday\n\n\n12.完成助动词+done做谓语\nThe students have all come\n\n\n13.完成助动词+be动词+done做谓语\nMy composition has been handed in\n\n\n14.助动词be+系动词be做谓语\nI am being your man.&#x2F; She is being sick.\n\n\n15.情态动词+系动词做谓语\nI can be the one.&#x2F; I can be your man.\n\n\n16.狭义助动词+系动词做谓语\nYou do look great today\n\n\n17.完成助动词+系动词做谓语\nMorty has been an UP since last year\n\n\nG16 助动词的作用（过去、进行、完成、被动）找出下列句子中的助动词并说出它们所起的辅助作用\n\n\n句子\n作用\n\n\n\n1.My job is teaching English.\n无。is是系动词，表状态。\n\n\n2.He is learning English.\nis.表进行\n\n\n3.I am to meet her at the school gate.\nam. 表将来。be to do是可以表将来的，而且表很确定的马上要发生的事情。\n\n\n4.Your job is easy.\n无。is这里是系动词，表状态。\n\n\n5.We are what we eat.\n无。are是系动词；eat是实义动词。\n\n\n6.What is rewarded is repeated.\nis; is. 两个都表被动。be+done表被动。\n\n\n7.The weather has turned cold.\nhas. 完成助动词表完成。turned是系动词，表变化。\n\n\n8.What needs to be done has been done.\nhas; been. has表完成；been表被动，因为后面接的是done.\n\n\n9.Last night, we had great fun.\n无。这里had是实义动词。\n\n\n10.I have been doing homework all day.\nhave; been. have表完成；been表进行，因为后面接的doing.\n\n\n11.Whatever he says, don’t believe him.\ndon’t. 表否定。\n\n\n12.Do you really need to be interviewed?\nDo. 表疑问。\n\n\n13.I did come for advice.\ndid. 表强调。\n\n\n14.I will never forgive you.\nwill. 表将来。\n\n\n15.If you can dream it, you can do it.\ncan; can. 表将来，表主观意愿。\n\n\n16.You have never thought about it, have you?\nhave; have. 第一个have表完成；第二个have表完成和疑问，主要表疑问，而且是反义疑问。\n\n\n17.Be a man!\n无。be是系动词，表状态。\n\n\n18.You‘ve been crazy.\nhave. 表完成。been不是助动词，是系动词，表状态。\n\n\n19.My boss is flying to Beijing tomorrow.\nis. 表将来。请注意，be doing也可以表比较确定的将来。\n\n\n20.My boss is having a meeting.\nis. 表进行。\n\n\n21.When she hurried to the party, the guests had already left.\nhad. 表完成。注意：这里不用说had表过去，过去是动词的天然属性，had天然表过去，就像have天然表现在一样。\n\n\nG17 虚拟语气基础一、填空1.虚拟语气通常用于条件（if）状语从句中。2.实现虚拟的方法通常是将主从句的谓语时态前移。\n二、具体前移规则\n\n\n时态\n转化方式\n\n\n\n一般现在(do, does)\n变成一般过去(did)\n\n\n一般过去(did)\n变成过去完成(had done)\n\n\n一般将来(will do)\n变成过去将来（would do）\n\n\n现在完成(have&#x2F;has done)\n变成过去完成(had done)\n\n\n过去完成(had done)\n无法前移\n\n\n过去将来(would do)\n变成过去将来完成(would have done)\n\n\n三、翻译填空-如果我是你，我会去向老师求助。\n-If I were you, I would ask the teacher for help.\n这是对现在情况的假设，是对现在的虚拟。\n-我们去抢银行吧！\n-好呀，如果你去，我就跟你去。\n-How about robbing a bank?\n-OK, if you went there, I would go with you.\n这是对将来的作者认为不可能的情况的假设，是对将来的虚拟\n-要是你早给她道歉的话，她就不会如此生气了。\n-If you had apologized to her, she wouldn’t have been so angry.\n这是假设过去未发生的情况发生了，真实的情况是你过去没有对她道歉，她过去非常生气。这是对过去的虚拟。\nG18 倒装句基础（部分倒装、完全倒装）一、填空1.倒装是与陈述相对而言。\n2.什么叫陈述语序？陈述语序就是主语在前，谓语在后。\n3.倒装分为：完全倒装和**部分（半）**倒装；这两种倒装我把它们称之为经典倒装。\n4.疑问其实也是一种部分倒装。\n5.倒装本质上是一种强调。\n6.否定介词和否定副词提到句首，诱发句子的部分倒装。\n7.方位介词和方位副词提到句首，诱发句子的完全倒装。\n8.介词和副词提前是诱发句子倒装的条件，但倒装的核心部位在于主谓的顺序。\n9.把整个谓语提到主语前，叫做完全倒装; 仅把助动词提到主语前，实义动词&#x2F;系动词放主语后，叫**部分（半）**倒装。\n10.把系动词提到主语前既算是完全倒装也算是**部分（半）**倒装。\n二、倒装下面的句子\nThe teacher came in and the class began.\n\nIn came the teacher and the class began. \n\n这里in是方位副词，提前诱发句子完全倒装。\n\n12.The boy is reading a book under the tree.\n\n这个句子虽然有方位介词under the tree,但没法倒装。因为方位介词提前是诱发句子完全倒装，所以如果倒装，句子将变成：Under the tree is reading the boy a book. 这个句子明显很奇怪，所以这个句子要么不倒装，要么改成Under the tree the boy is reading a book. 就可以了。也就是说，方位词提前诱发句子完全倒装得先满足句子**主干是主谓**（SV）结构才行，而主干是主谓宾（SVO）结构则不行。\n\n13.The boys rushed out.\nOut rushed the boys. \n\n这里out是方位副词，提前诱发句子完全倒装。\n\n14.They rushed out.\nOut they rushed. \n\n完全倒装时，如果主语是人称代词，则不倒。\n\n15.Students are permitted to go out only accompanied by adults.\nOnly accompanied by adults are students permitted to go out. \n\n这里only是否定副词，提前诱发句子部分倒装，部分倒装只需要把助动词are提到主语students之前就可以了，而实义动词permitted仍然放在主语后面。\n\n16.He didn’t read a single book that month.\nNot a single book did he read that month. \n\n这里的否定副词是not，提前诱发句子部分倒装，但是不能单独提not，不好，not a single book以前提前读起来更顺畅。\n\n17.I realized only then the importance of math.\nOnly then did I realize the importance of math. \n\n这里only then是否定副词，提前诱发句子部分倒装。所以我们得把realized拆成did和realize才行，再把did提到主语I的前面就可以了。\n\n18.I remembered all this only after she was seen no more.\nOnly after she was seen no more did I remember all this. \n\n这里道理同上，only提前诱发句子部分倒装，remembered拆成did和remember.\n\n19.I have never told anyone about it before, I have nor tried to explain to myself why not.\nNever have I told anyone about it before, nor have I tried to explain to myself why not. \n\n这里两个都是否定副词提前诱发句子的部分倒装，但是nor也是连词，也可以起连接作用。但是倒装不是越多越好，这里也可以前面不倒，只到nor这个句子。\n\n20.特别奉献：把这两个句子改成一个句子。 \nA small piece of paper was in the middle. \nThe words “English Writing Prize 1949: History Is a Series of Biographies.” were written on the paper.\n\n最简答的改法当然就是两个句子间加一个and就可以了，但是这个改法太普通了。我们观察第一个句子里面有in the middle，这是一个方位介词，这就提醒我们可以完全倒装。所以变成：In the middle was a small piece of paper. 第二句话就不明显了，但特别观察的话，还是可以发现on the paper是一个方位介词，所以这个句子也可以完全倒装，变成：On the paper were written the words “English Writing Prize 1949: History Is a Series of Biographies.” 但问题的关键是怎么把这两个句子结合起来，我们可以发现，这两个句子里面都有paper，所以我们可以把on the paper改成on which，这样就变成了定语从句里介词+which的情况了。所以最终我们可以得到一个非常漂亮的句子：\n\nIn the middle was a small piece of paper on which were written the words “English Writing Prize 1949: History Is a Series of Biographies.”\n这个句子相当漂亮，因为它一个句子里面用了两个完全倒装。所以写作高手的标志之一就是灵活巧妙地运用倒装句。\nG19 非谓语之上帝视角（抽象思维）一、填空\n\n\n项目\n内容\n\n\n\nbe的不定式形式\nto be\n\n\nbe的动名词形式\nbeing\n\n\nbe的现在分词形式\nbeing\n\n\nbe的过去分词形式\nbeen\n\n\n动词原形抽象成\ndo\n\n\n动词第三人称单数抽象成\ndoes\n\n\n动词过去式抽象成\ndid\n\n\n动词不定式抽象成\nto do\n\n\n动名词抽象成\ndoing\n\n\n动词现在分词抽象成\ndoing\n\n\n动词过去分词抽象成\ndone\n\n\n二、把下列动词短语抽象\n\n\n动词短语\n抽象\n\n\n\n\nto be a better man\nto do\n\n\n\nwould have been persuing\ndid\n\n\n\nbrought\ndid&#x2F;done\n\n\n\nbroke\ndid\n\n\n\nbuilding\ndoing\n虽然building有可能是名词，但是我题目中说了抽象下列动词，所以我们默认为它是动词。\n\n\nhad been built\ndid\n单独的had是可以抽象成did和done的，但因为这后面的been也是done形式了，没有done done形式，我们反推had是过去式；或者你直接看出had been built是过去完成时，所以得出had是did形式也可以。\n\n\nbuilt\ndid&#x2F;done\nbuild是ABB型。过去式和过去分词一样，都是built.\n\n\nbuilt the building\ndid\nbuilt后面接了宾语，说明是主动的，主动是did.\n\n\ncan be done\ndo\n不要被后面的be done所迷惑，你直接看can就可以了，can相当于动词原形，所以说整个短语也是一种谓语形式。\n\n\ncould come\ndid\n\n\n\ncome\ndo&#x2F;done\ncome是ABA型，动词原形和动词过去分词长一样。但现实句子当中come基本是do形式，因为come如果为done形式的话，前面肯定有完成助动词have&#x2F;has&#x2F;had.\n\n\nhas come\ndoes\n\n\n\nate\ndid\n\n\n\nfound\ndid&#x2F;done&#x2F;do\n这个题有点特殊，首选found可能是find的过去式或过去分词形式，所以可能是did或done，又因为found本身也是一个动词原形，它是建立的意思。\n\n\nfounded the association\ndid\n这里found是建立的意思，它是ABB型，它的过去式和过去分词都是founded，又因为founded接了宾语，说明是主动，主动是did.\n\n\nfounded in April\ndone\n这个短语的意思是四月被建立，因为found作建立讲是及物动词，及物动词一定要接宾语，没有接宾语的话说明就是被动，被动就是done. 这里也不可能是找到、发现的意思，因为find的被动形式是found，不是founded.\n\n\nspoken\ndone\n\n\n\nshut\ndo&#x2F;did&#x2F;done\nshut是AAA型。\n\n\nrun\ndo&#x2F;done\nrun是ABA型，同第22题，基本上run是do形式。\n\n\ndriven\ndone\ndrive是ABC型，drive, drove, driven.\n\n\nbeing busy\ndoing\n\n\n\n三、找出下列句子中的动词（包括谓语和非谓语）并把它们抽象33.It is hoped that the report made by Mr.Chen, the engineer, will stimulate the students’s interest in electronic computer.\n\nis hoped抽象成does; made是被动，抽象成done; will stimulate抽象成do\n\n34.The news that China has successfully launched a new experiment communications satellite is very exciting to the people all over the world.\n\nhas launched抽象成does; is抽象成does.\n\n35.Having seen the world, I know what I want.\n\nhaving seen抽象成doing; know和want抽象成do.\n\n36.Seen from my view, the problem is not difficult.\n\nseen抽象成done，因为它是被动的；is抽象成does.\n\n37.To see is to believe.\n\nto see和to believe都抽象成to do；is抽象成does.\n\n38.Does she look like an actor?\n\ndoes look,抽象成does.\n\nG20 非谓语动词的本质一、填空1.只有主语能产生谓语\n谓语产生的三种情况：\n2.S+V\n3.S+V+连接词+V\n4.S+V+连接词+S+V\n5.英语第一原则：一山不容二虎，除非一公一母\n非谓语动词包括了：6.不定式、动名词、分词\n分词分为：7.现在分词和8.过去分词\n9.不定式的本质是：不确定\n10.不定式的运用是表：表目的，将来，一次性（的动作）\n动名词的本质是：确定\n11.动名词的运用是表：长期，习惯（性的动作）\n12.分词的本质是：省略\n13.不及物动词的过去分词vi done 表： 完成\n14.及物动词的过去分词vt done 表：完成&#x2F;被动\n二、找出下列句子中的非谓语，并说出它们由什么充当eg：I want to go home.\n\nto go home.不定式\n\n15.He is asked to give the lazy boy a lesson.\n\nto give the lazy boy a lesson.不定式。\n\n16.The man was claimed to have been badly treated.\n\nto have been badly treated.不定式。\n\n17.Your being lazy recently annoys me.\n\nbeing lazy.动名词。因为这里being lazy做的主语，所以是名词词性，所以是动名词。\n\n18.Being lazy, I failed to get up this morning.\n\nBeing lazy现在分词；to get up，不定式。因为Being lazy在句中做的状语，所以是现在分词。to get up做宾语。\n\n19.Having seen the world, I know what I want.\n\nHaving seen the world. 现在分词，因为做的状语。\n\n20.I just had my hair cut.\n\ncut.过去分词，vt done表被动。\n\n21.I found the leaves fallen.\n\nfallen. 过去分词，vi done表完成。fall是不及物动词。\n\n三、用所给动词的适当形式填空22.I heard someone (sing) just now.\n\nsinging.根据just now判断应该是刚正在唱，这里是现在分词做宾补，但这题也可以用sing表唱歌的全过程。这个具体知识点在“非谓语难点下”有讲到\n\n23.The report (make) by Morty made us (laugh).\n\nmade; laugh. 这里made by Morty是后置定语，属于非谓语，made表被动，是过去分词。laugh是因为make sb. do sth. 具体讲解在“非谓语难点下”。\n\n24.She is sitting by the lake, (listen) to the music.\n\nlistening，现在分词做伴随状语。\n\n25.Suddenly,I (notice) that a man (sit) at the table next to the window kept (glance) in my direction, as if he (know) me.\n\nnoticed; sitting; glancing; knew. 这道题考验大家的综合能力，首先I是主语，所以后面notice得用谓语形式，根据题意可以看出这件事已经发生了，所以用noticed；sitting at the table放在名词短语a man后面做后置定语，这里sitting是现在分词；keep doing sth.表持续做某事，因为kept是a man的谓语形式，根据一山不容二虎，所以glance用了现在分词形式；因为as if是引导词，所以后面又可以接一个主谓结构了，而he是主语，所以后面可以接谓语形式，这件事发生在过去，所以用knew.\n\nG21 非谓语难点&#x2F;改错（上）一、谓语变非谓语\ndo&#x2F;does&#x2F;did：doing\n系+表: 表\nbe done：done\nbe doing：doing\n情态动词+do：to do\n\n二、改错6.David pointed to a path which he thought would probably leading to a village.\n\nleading改成lead.因为would后面接动词原形。\n\n7.Charles and Linda Mason do all these things as well as climbed building.\n\n**climbed改成climb；**或do改成did. as well as是and的意思，两边的时态要对称。\n\n8.In those days we were forced work twelve hours a day. \n\nwork前面加to；be forced to do sth.被强迫做某事。因为你被强迫做某事一定是在被强迫之后，所以是将来的，也就是不确定的。\n\n9.Walk quickly is difficult for an old man. \n\nWalk改成Walking. 这里is是谓语，前面是主语，所以动词原形Walk错了，且这里讲的是一个一般的事实，所以说用动名词形式。\n\n10.Be careful in cross the street. \n\ncross改成crossing. in是介词，后面加动名词形式，做它的宾语。\n\n11.The film is very interested. \n\ninterested改成interesting. 电影很有趣，是令人觉得有趣，不是电影自身对某个东西感兴趣。\n\n12.The Wild Goose Lake is worth see twice.\n\nsee改成seeing. be worth doing sth.意为值得做某事。这里做这件事是有价值的，是表达一个确定的概念。\n\n13.To cooking is not easy.\n\n**To cooking改成Cooking；**或把cooking改成cook. 动名词或不定式都可以做主语。\n\n14.Things keep changed.\n\nchanged改成changing. keep doing sth.坚持&#x2F;保持做某事。一直在做的某件事一定是确定的，所以用的doing.\n\n15.The room is been painting.\n\nbeen painting改成being painted. 这句话的意思是这个房间正在被粉刷，某事正在被做，应该是is being done.\n\n16.Before listened to radio, he read newspapers.\n\nlistened改成listening. 这个句子中，before看作是介词，所以后面用动名词形式，而read的过去式也是read，所以可以不算错。\n\n17.Do you love laying in bed?\n\nlaying改成lying. 躺下lie的动名词和现在分词形式都是lying. 这里喜爱某件事，是确定的，所以算是动名词形式。\n\n18.I find this book interested.\n\ninterested改成interesting. 我发现这本书很有趣。\n\n19.Modern people know more about health, have better food, and to live in clearer surroundings.\n\nto live改成live. know, have和 live三个动词由and连接，是并列关系。\n\n20.These are the problems I have been experienced.\n\nexperienced改成experiencing. 题意为：这些是我一直在经历的问题，我经历是主动的。\n\n21.We are both looking forward to be going on vacation next week.\n\n把be去掉； 或把be改成being. 因为look forward to里面的to是介词，所以后面用ing.\n\n22.The driver has been trying start the car for nearly an hour.\n\nstart改成to start. try to do意思是尽力做某事，try doing是试着做某事。他已经花了半个小时了，所以可以看出不是抱着随便试一试的态度，而是尽力做了，所以用to do.\n\n23.That building being repairing is our library.\n\nrepairing改成repaired. 这个句子being repaired做The building的后置定语，意思是正在被维修的建筑，正在被修用being done.\n\n24.To answer correctly is more important than finish quickly.\n\nfinish改成to finish. to answer和to finish对称。\n\n25.The book is said to have translated into many foreign languages.\n\nhave translated改成have been translated. 这句话的意思是据说这本书已经被翻译成了很多外文了。被翻译，所以加been.\n\nG22 非谓语难点&#x2F;改错（下）\n\n\n某人(主语)\n看见(谓语)\n某人(宾语)\n做某事(非谓语)\n\n\n\nsubject\nlet,make\nsb\n正在做**(doing)**\n\n\n\nwatch,notice\n\n做完了**(to do)**to do是不确定的,做完了是确定的,所以省略to\n\n\n\nsee,have\n\n被做**(done)**\n\n\n主动省to,被动还原(倾向于不确定)\nI saw her go into the room\nshe was seen to go into the room\n一、改错1.Never stop to look for the laws which control facts.\nlooking\n2.We have heard of your having done something for our class.\ndo\n3.She’s going to the photographer’s to have her photograph taking.\ntaken\n4.The boy was seen play on the sports ground. \nto \n5.The boy was seen playing on the sports ground.\nto\n6.I heard someone sing a revolutionary song when the school was over yesterday afternoon.\n7.Be a man.\nbeing a man\n8.Be a teacher is not an easy job.\nbeing\n9.Do you mind me smoking here?\nto smoke\n10.Do you mind I smoke here?\nsmoking\n11.Mother warned him not touch the electric lamp.\ntouching\n11.I spoke to him kindly so as not frighten him.\nfrighting\n12.You’d better to have your television set repairing .\nrepair\n13.You’d better have your television set set.\nseting\n14.He was made wash the boss’s car once a day. \nwashing\n15. I’ll let you to know as soon as I hear from her.\nhear\n16.What I want know is when all this happened.\n17.I heard him says so.\n18.I heard he says so.\n19.Did you notice the little boy took the candy and ran away?\n二、用所给词的适当形式填空20**. ________** more attention，the trees could have grown better.（give）\n21.Professor Black had us ________ compositions every Friday.（write）\n22.This book isn’t well written. I don’t think it worth ________ .（buy）\n23.The house needs ________ but we plan to wait until next summer to do it.（paint）\n24.I know it isn’t important but I can’t help ________ about it.（think）\n25.The blind man stood ________ by the side of the road.（beg）\n26.When the teacher came into the classroom, the students stopped ________ and got ready for class.（talk）\n27.Because of my poor English I’m afraid I can’t make myself ________ .(understand)\n28.She promised *________* in the bedroom until the baby stopped *________* .(stay;cry)\nG23副词和状语一、填空副词和状语这个知识点被我称之为：0.幸福的摩天轮模型\n副词修饰1.动词 2.形容词 3.副词 4.句子 在句子中作5.状语（成分）\n副词是词性；状语是成分。副词绝大多数情况下都是作状语，而状语除了副词以外，还可以由6.介词短语 和7.句子 充当。\n常见的频率副词有：always,8.usually,often,9.sometimes, seldom, hardly, 10.never.\n频率副词在句中的正常位置位于11.助动词、系动词之后，12.实义动词之前\n否定副词提前诱发句子13.部分倒装\n状语分类\n时间、地点、原因、目的、结果、14.条件、15.方式、16.让步、程度、比较、17.伴随\n二、判断以下句子状语类型18.Though she is a child, she knows a lot. \n让步\n19.The more I can do for the class, the happier I’ll be. \n条件\n20.He talks as if (as though) he knew all about it. \n条件\n21.He is such a good teacher that the students love and respect him. \n原因\n22.I shall go to the park unless it rains. \n条件\n23.I had no sooner got home than it began to rain. \n伴随\n24.Where there is water, there is life. \n结果\n25.He studied hard so that he could catch up with his classmates. \n目的\n26.Since you are very busy, I won’t trouble you. \n原因\n27.Even if (though) I fail. I’ll never lose heart. \n28.Once you begin the work, you must continue. \n29.Although the sun was shining, it wasn’t very warm. \nG24 状语的本质方式状语与伴随状语的区别如果对方式状语提问，我们倾向于用 how;\n而伴随则强调我们在做某事的时候 同时 发生了一个什么状况\n让步状语的本质最能体现让步状语本质的连接词我个人认为是：even if 和 even though\n让步状语是说话的人自己设想了一种最 糟糕 的状况，都能满足，何况其他 更好 的状况，所以产生了让步。\n让步状语从句也可以用1.落差法，\n比如帅对应的是2.有女朋友，\n而丑对应的应该是3.没有（无）女朋友。\n而如果虽然他很帅，却没有女朋友，那么这时候就产生了落差，就算是让步状语了。\n在G25中，我还跟大家分享了一个句子，叫：\nMoney 4.earned is a byproduct of value creation.\n这里修饰Money的这个词，采用的是5.过去分词做后置定语的语法现象。\n状语和行为的时间先后关系原因状语和 条件状语发生在行为&#x2F;动作之前；\n目的状语和 结果状语发生在行为&#x2F;动作之后；剩下的状语都发生在行为&#x2F;动作之中。\n按要求构造状语请你造句，句中得包含“你输在起跑线上”这几个字。\n11.时间状语\n\n当你听Morty讲课的时候，你就输在起跑线上了。\n\n12.地点状语\n\n你在Morty讲课的地方，B站，输在了起跑线上。\n\n13.原因状语\n\n因为你听了Morty的讲课，所以你输在起跑线上了。\n\n14.目的状语\n\n为了让你输在起跑线上，你得听Morty讲英语。\n\n15.结果状语\n\n你听了Morty的讲课，输在起跑线上了。\n\n16.条件状语\n\n如果你想输在起跑线上，你得听Morty讲英语。\n\n17.方式状语\n\n你是通过听Morty讲课而输在起跑线上的。\n\n18.让步状语\n\n虽然你听了Morty讲课，但你还是输在起跑线上了。\n\n19.比较状语\n\n相比于听其他老师，你听Morty讲更容易输在起跑线上。\n\n20.程度状语\n\n听了Morty的讲课，你彻底地输在起跑线上了。\n\n21.伴随状语\n\n你在听Morty讲课，同时就输在起跑线上了。\n\nG26 宾语的产生所有的谓语都是6.主语产生的；\n所有的宾语都是7.**及物动词(vt)**或8.介词产生的。\n实义动词分为:9.**及物动词(vt)**和10.不及物动词(vi)\n及物动词vt分为:\nvt1:接11.一个宾语；\nvt2:接12.**两（二）**个宾语\nvt1后的宾语我们称之为:13.动宾\nvt2后我们分别要接:14.**间接宾语（IO）**和15.直接宾语（DO）\n不及物动词vi+介词再加的宾语我们称之为:16.介宾\n以上讲的宾语都是我们平时学习里所提到的宾语，我把它称之为:17.狭义宾语; 而在介词短语做的除谓语外的其他成分，如定语和状语中，我把介词后面的名词成分称之为:18.广义宾语（这个知识点没理解不影响）\nG27 动宾和介宾一、找出下列句子的宾语（狭义：包含动宾和介宾）\nWe should listen to our parents.\n\nour parents;should listen to 是谓语，our parents名词短语做介词宾语。\n\n\nI believe that you are telling the truth.\n\nthat you are telling the truth; the truth; 宾语从句，做及物动词believe的宾语。在从句中the truth做are telling的宾语。\n\n\nThey began studying computer last week.\n\nstudying computer; 动名词做及物动词began的宾语。\n\n\nTell me whether you like it or not.\n\nme; whether you like it or not; it; me人称代词宾格，做及物动词tell的间接宾语；whether you like it or not 句子，做tell的直接宾语；it做like的宾语, like在从句里面也做谓语，所以它的宾语也算狭义宾语。\n\n\nI bought twelve.\n\ntwelve; 数词，做bought 的宾语。\n\n\nWe have learnt to ride the bike.\n\nto ride the bike; 不定式做have learnt的宾语。\n\n\nShe only laughed at what we said.\n\nwhat we said; what; what we said 句子，做laugh at的宾语，所以说是宾语从句。what在从句里面做said的宾语。\n\n\nHe promised to come.\n\nto come; 不定式做 promised 的宾语。\n\n\nGot it.\n\nit; 宾格，做got的宾语。\n\n\nIt is no use crying for spilt milk.\n\n无。这个句子是it做形式主语，原来的样子是Crying for spilt milk is no use. 是一个主系表结构，没有宾语。需要注意的是，spilt milk做了crying for的宾语，可以看做是广义宾语。\n\n\nTake it or lose it.\n\nit; it; 前面的it做take的宾语；后面的it做lose的宾语，都是动宾。\n\n\nWhat she said is not true.\n\nwhat; 这是一个主语从句，在从句what she said里面，what做了said的宾语。\n\n\nI am not the one you love.\n\nthat&#x2F;who&#x2F;whom; 这是一个定语从句，引导词在从句里面做宾语被省略了。原句为：I am not the one (that&#x2F;who&#x2F;whom) you love. 需要注意的是the one不是宾语而是表语。当然也可以说这个句子里面没宾语，因为被省略了。\n\n\nMy name is Morty.\n\n无。Morty是表语。\n\n\nWe all love you Morty.\n\nyou; 人称代词宾格，做love的宾语，Morty是you的同位语。\n\n\nI bought a book yesterday.\n\na book; 名词短语做bought的宾语。\n\n\nListen! Someone’s singing.\n\n无。前面listen是祈使句，后面是一个主谓结构，没有宾语。\n\n\nShe likes singing.\n\nsinging; 动名词做likes的宾语。\n\n\nShe likes to sing.\n\nto sing; 不定式做likes的宾语。\n\n\n\n二、分别找出下面这个句子的狭义宾语和广义宾语\nAnimals can often react more appropriately than they otherwise would to situations they encounter if they draw on generalizations from past experiences of similar situations.\n\nG28间接宾语IO与直接宾语DO一、填空用字母表示主谓间宾直宾：1. S V IO DO\n双宾语结构的三大要素：\n第一，2. 双胞胎 准生证：即谓语动词是：3. vt2\n第二，两个宾语是4. 两 个主体 \n第三，两个宾语可以5. 交换顺序\n主谓直宾+间宾的时候，直宾和间宾中间要＋6. to 或7. for\n判断加什么介词的方法分别是：8. **参与（to）**和9. 不参与（for）\n举五个常见的接双宾语的动词：\n\ntell；11. give；12. make；13. ask；14. show\n\n二、转换间宾直宾顺序15.bring sb.sth.&#x3D; bring sth.to sb.\n\n给某人带某物，那个人要参与；比如我给你带了一些特产过来，你得接受。\n\n16.award sb.sth.&#x3D; award sth.to sb.\n\n奖励某人某物，某人也要参与；你想想你得奖的时候你参与了没嘛。\n\n17.book sb.sth.&#x3D; book sth. for sb.\n\n为某人定某物，不参与；比如我为你定票，你没参与，我帮你定的。\n\n18.choose sb.sth.&#x3D; choose sth. for sb.\n\n为某人选某物，不参与；我为你选了一个礼物，你没参与。\n\n19.owe sb.sth.&#x3D; owe sth. to sb.\n\n欠某人某物，我欠你钱，你参与了；比如我欠你一份情，你其实也参与了，你是这份情的承受者。\n\n20.serve sb.sth.&#x3D; serve sth. to sb.\n\n招待某人某物，参与；我招待你吃饭，你肯定参与了。\n\n21.fix sb.sth.&#x3D; fix sth. for sb.\n\n为某人修某物，不参与；我为你修自行车，收音机，你没参与。\n\n22.pick sb.sth.&#x3D; pick sth. for sb.\n\n为某人捡&#x2F;摘某物，不参与；我为你摘果子，我为你摘风筝，你没参与。\n\n23.fetch sb.sth.&#x3D; fetch sth. for sb.\n\n为某人取某物，不参与；比如我为你取快递，你没参与。我替你去取的。\n\n24.offer sb.sth.&#x3D; offer sth. to sb.\n\n提供某人某物，参与；比如我提供给你一个机会，你接受了这个机会，所以参与了。\n\n三、按要求造句25.写一个双宾语结构，直宾为不定式\n\nTell me how to run the machine.要用不定式做直宾，最好带上一个特殊疑问词, 比如说how.\n\n26.写一个直宾从\n\nShow me what you got. 这是Rick and Morty有一集里的句子，大石头怪，在空中，要毁灭地球，要地球人展示才艺，当时他就说的这句话：Show me what you got.\n\n27.写一个间宾从\n\nI’ll give whoever comes first a gift. whoever comes first就是间宾从，a gift是直接宾语。\n\n28.写一个双宾语结构，间宾和直宾都是句子\n\nI’ll give whoever comes first whatever he or she wants. whoever comes first是间宾从，whatever he or she wants就是直宾从。当然这种句子是很少见的，这是我硬造出来的。意思是：我会给任何先到的人他&#x2F;她想要的任何东西。\n\nG29 宾语补足语一、双宾语和宾补的区别：双宾语结构的谓语动词是：vt2；而宾补结构的谓语动词是vt1\n双宾语的间宾和直宾是两个主体；而宾语和宾补是一个主体\n双宾语的间宾和直宾可以交换顺序&#x2F;变序，而宾语与宾补不能变序\n二、找出下列句子的宾补，并说明用什么充当。6.We elected him monitor.\n\nmonitor;名词。\n\n7.I’m going to paint it pink.\n\npink;形容词。\n\n8.You made me blue.\n\nblue;形容词。\n\n9.She made me a fool.\n\na fool; 名词。\n\n10.I found her out.\n\nout; 副词（在外面）。当然也可能是形容词，就是过时的意思。\n\n11.I think it right.\n\nright; 形容词。\n\n12.I think it right to learn English well.\n\nright; 形容词。it是形式宾语，真正的宾语是to learn English well\n\n13.My mum ordered me to learn English well.\n\nto learn English well; 不定式。\n\n14.The teacher thought this good advice.\n\ngood advice;名词短语。这个句子读起来会有点奇怪，this是宾语，good advice和this是一个主体，补充说明它，这就是一个好的建议。而advice是不可数名词，所以前面没加a.\n\n15.You should keep your room clean and tidy.\n\nclean and tidy; 形容词。\n\n16.The man found himself in the middle of nowhere.\n\nin the middle of nowhere; 介词短语。\n\n17.He opened the window to let the fresh air in.\n\nin; 副词。怎么区别in是介词还是副词呢，有个很简单的方法就是看它后面跟了东西没，如果是介词一般后面会跟名词短语。\n\n18.I’m sorry to have you waiting for so long.\n\nwaiting for so long; 现在分词短语。have sb.doing sth.让某人一直保持做某事。\n\n19.I always try to make my lessons as easy as possible to make myself understood.\n\nas easy as possible; 副词； understood 过去分词。其实easy是在补充说明lessons的，应该是形容词，但是as…as又在修饰easy，又是副词，所以这个东西了解下就可以了，不必纠结。\n\n20.The murderer was brought in, with his hands tied behind his back.\n\ntied behind his back; 过去分词。这个句子和前面讲的不太一样。这个是介词with后面的宾语his hands的宾补，因为his hinds就是被绑起来的，所以是一个主体。\n\nG30宾语从句的种类一、填空一个句子 做宾语叫做宾语从句\n宾语从句按照我的体系可以分成 6 种\n它们分别是介词后的宾从叫 介宾从\nvt1后面的宾从叫 动宾从\nvt1+宾从+oc（宾补），这种从句因为宾语头重脚轻，我们可以用it作 形式宾从\nvt2后面需要接两个宾语，两个宾语都可以变成宾语从句，分别叫做 间宾从 和 直宾从\n第六种是主系表之后的宾从，我们称之为 形容词宾从\n二、判断宾从类型(以上提到的六种）9.I can’t understand what he said.\n\n动宾从。因为 understand是及物动词（vt1）\n\n10.I can’t understand all he said.\n\n定从。这个句子不是宾从，因为宾语是不定代词all，而它很笼统，后面he said在修饰它，所以是定从，而引导词that被省略了。\n\n11.I think that you are a pig.\n\n动宾从。think为vt1\n\n12.The truth is that you are a pig.\n\n表从。这里不是宾从，很多同学会把它看做宾从，is是系动词，后面接表语。\n\n13.I am afraid that you are a pig.\n\n形容词宾从。afraid是形容词，am afraid是系表结构。\n\n14.What we are talking about is that you are a pig.\n\n表从。is是系动词 ，后面接表语。\n\n15.He is sure that you are a pig.\n\n形容词宾从。sure是形容词，is sure是系表结构。\n\n16.Show me what you got.\n\n直宾从。这个句子是祈使句，主语被省略了。show是vt2，me是间宾，what you got作直接宾语。\n\n17.I’ll give a gift to whoever comes.\n\n间宾从&#x2F;介宾从。这个句子有两个理解方法。第一还是看做双宾语结构，give sb. sth.&#x3D;give sth. to sb. 这里的sb.就是间宾，而它变成一个句子当然可以叫做间宾从；第二种理解就把to看做一个介词，所以说是介宾从。\n\n18.We are talking about whom we can trust.\n\n介宾从。about是介词，所以后面是介宾从。\n\n19.I think it important to learn a second language.\n\n这个句子是it做形式宾语，但却不是形式宾从。因为it代的是to learn a second language，这个是一个不定式。\n\n20.We all think it a fact that Liwenliang is a good man.\n\n形式宾从。这里it代的是that Liwenliang is a good man.这个句子。而a fact是宾补。\n\n21.We are curious about when the virus can be killed.\n\n介宾从。不过这里与18题不同的是18题是talk about这个动词短语后面的介宾从；而这题是be curious（系表结构）后面的介宾从。\n\n三、造句22.用buy造一个直宾从\n\neg: I will buy you whatever this street sells. \nI will buy whatever you want for you\n\n23.用find造一个it形式宾从\n\nWe find it a trouble that novel coronavirus spreads so quickly.\nI find it important to get my own computer\n\nG31被动即完整一、填空被动即完整的意思是：如果谓语动词是被动形式，那么它后面不缺宾语这种主要成分。\n被动即完整，但**间宾（间接宾语&#x2F;IO）**的被动除外。\n被动即完整，但被动语态的谓语后面如果加了介词，还是缺宾语。\n被动即完整，说的是谓语后面的成分，而不是指其前面的主语部分，比如单看was cleaned，是缺主语的（填主要成分）\n二、判断句子完不完整\n注：在我的体系里，句子完不完整指的是主干成分（主谓宾，主系表等），而不是指定语，状语等修饰成分。\n\n5.Go！\n\n完整。这个是祈使句，主语被省略了，又是不及物动词，后面不缺宾语。\n\n6.I showed her.\n\n不完整。一般来看是不完整的，因为show是vt2，需要两个宾语，应该是show her sth. 但特殊的语境下，比如你展示了她，那么也可以算作是完整的。\n\n7.I was shown.\n\n不完整。这种是间宾被动。\n\n8.The movie was shown.\n\n完整。这是直宾被动，满足被动即完整。\n\n9.The movie has been shown.\n\n完整。直宾被动，满足被动即完整。\n\n10.I was interested.\n\n完整。主系表结构。\n\n11.It was interesting.\n\n完整。主系表。\n\n12.I was interested in.\n\n不完整。in是介词，后面缺宾语。\n\n13.I am afraid.\n\n完整&#x2F;不完整。如果看做主系表，表示我害怕，就完整。如果表示恐怕…就不完整，后面可以接宾语从句（参看G30）\n\n14.I choose; I like.\n\n不完整。这是典型的口语化表达，choose和like都是及物动词，后面都缺宾语。\n\n15.The letter was delivered.\n\n完整。\n\n16.is being repaired.\n\n不完整。虽然is being repaired是被动，但被动即完整是指其后面不缺成分了，但是前面还是缺主语的。\n\n17.My uncle is repairing.\n\n不完整。repair是及物动词，在修什么？但如果只是说他笼统地在修东西，也可以算作完整。\n\n18.My sister is watching.\n\n不完整。她在watch什么？\n\n19.The house built last year.\n\n不完整。built是ABB型，也就是说它既可能did（谓语）；也可能是done（非谓语）。如果它是done形式 ，那么这个句子没有谓语，不完整；如果它是did形式，那么它是及物动词，后面缺宾语，所以不完整。\n\n20.It is reported.\n\n完整。\n\n21.It is reported that the virus has been found.\n\n完整。注意这个句子不是宾语从句，因为is reported是被动即完整，后面不缺宾语。而这个句子是it做形式主语的主语从句。\n\n22.I have spoken.\n\n完整。speak在这里不是指说某种语言的意思，是不及物动词。\n\n三、把下列句子改成被动形式23.Morty delivered the message.\n\nThe message was delivered (by Morty).\n\n24.Morty has delivered the message.\n\nThe message has been delivered (by Morty).\n\n25.Morty sent Rick a message.(Rick做主语）\n\nRick was sent a message (by Morty).\n\n26.Morty sent Rick a message.（A message做主语）\n\nA message was sent to Rick (by Morty).\n\n27.Morty told Rick that the message had been sent.\n\nRick was told (by Morty) that the message had been sent.\n\nG32主语补足语一、填空在主动语态当中的宾语补足语，在句子变成被动语态之后，宾语补足语要变成主语补足语。\nsee, watch, notice, have, observe, make等动词做谓语，后面如果有动词做宾补，且在表示动作全过程时，要满足，主动省to，被动还原。\n在英语当中，被动语态倾向于表达不确定。\n二、将下列句子改成被动形式8.She made me a fool.\n\nI was made a fool (by her).\n\n9.I think it reasonable.\n\nIt was thought reasonable (by me).\n\n10.It sounds plausible.\n\n不可改。这是主系表结构。\n\n11.We all wish you well.\n\nYou are wished well by us all.\n\n12.I had my hair cut the other day.\n\nMy hair was had cut (by me) the other day. 可以很容易的看出，这个句子不适宜变成被动。不是所有的句子都适合变成被动的，必须要强调动作的被承受者的时候才比较适合，而这里强调明显不是my hair，如果要强调my hair，直接用my hair was cut the other day就可以了，不需要用在have sth. done.这个句型中。\n\n13.My mum made me do it.\n\nI was made to do it (by my mum). 这里就是主动省to，被动还原。\n\n14.I saw her dancing in the rain.\n\nShe was seen dancing in the rain (by me).\n\n15.Marsellus Wallace, my boss, asked me to take her out to do whatever she wanted.\n\nI was asked by Marsellus Wallace, my boss, to take her out to do whatever she wanted. 这里要注意，to take her out to do whatever she wanted. 才是主语补足语。\n\n16.I found him out.\n\nHe was found out.\n\n17.They painted their house pink.\n\nTheir house was painted pink.\n\n18.We all believe it a disaster that he would do such a stupid thing.\n\nIt is believed a disaster by us all that he would do such a stupid thing. **这里要注意，**a disaster才是主语补足语。原来的句子it是形式宾语，a disaster是宾补，而that是真正的宾语从句。\n\n三、翻译19.我看见他们一起进了电影院。\nI saw them go into the cinema.\n20.我看见他们正在看电影。\nI saw them watching a movie.\nG33表语一、填空在英语中，我们把系动词后面的成分称之为表语。\n主系表与主谓&#x2F;主谓宾的本质区别是：主谓&#x2F;主谓宾要表具体动作；而主系表不表具体动作，只是描述主语的状态。\n最常见的一种系动词是：Be动词。\n某些动词可能既是系动词，也是实义动词，判断的技巧是：\n把那个动词替换成Be动词，如果意思变化不大，它就是系动词；\n如果意思变化大，它就是实义动词。\n一个句子做表语叫做：表语从句。\n二、找出下列句子中的表语10.It sounds plausible.\n\nplausible, 形容词做表语\n\n11.To be or not to be, that is a question.\n\na question, 名词短语做表语\n\n12.All I have to do is dream.\n\ndream, 这里很多同学可能会觉得莫名其妙。首先这是一个定语从句，这一步很多人都看不出来了。主句是All is dream.完整且all是不定代词，很笼统，I have to do修饰all，所以说是定从，引导词只能是that，因为先行词是不定代词，且that在从句中做do的宾语，所以被省略了。然后is是系动词，所以dream是表语。但第二个难点是dream是动词原形，怎么可能做表语？其实它是to dream的省略，前面的意思是我不得不做的一切就是做梦。这里的意思倾向于表达唯一了，因为我能做的一切就只是这个了，意思就没有他选了，所以to被省略了，还不懂的请去看《非谓语难点下》。这里你可以当做固定搭配，就是“不定式做表语时，如果主干部分有do的任何形式（这里All I have to do, 有do），那么表语的不定式得省略to”如果这个句子把do改成choose等其他非do的词，那么to就不能省略，比如：All I have to choose is to dream.\n\n13.What I have to do is dream.\n\ndream, 同上，不过是主语从句了。\n\n14.I like dreaming.\n\n无。这个dreaming是动名词做宾语。\n\n15.You must be dreaming.\n\n无。这里表示你肯定在做梦，表具体动作了，是主谓结构。\n\n16.You are my dream.\n\nmy dream, 名词短语。\n\n17.You are dreaming.\n\n无，主谓结构。\n\n18.Your dream is mine.\n\nmine, 名词性物主代词。\n\n19.Now and forever, I will be your man.\n\nyour man, 名词短语。\n\n20.I’m here waiting for you.\n\nhere, 副词，waiting for you是伴随状语。\n\n21.My money is right here, in my pocket.\n\nright here, in my pocket. 这两个都算，right here算副词，in my pocket是介词短语。\n\n22.My only choice is to hand in my work.\n\nto hand in my work,这里就是前面讲的不定式做表语，因为前面没do，所以这个to不能省略。\n\n23.It seems that all the waiters in the restaurant know about him.\n\n无。这个句子可以算作it做形式主语的主语从句，而seems看做不及物动词，所以没表语。当然也可以把it当成抽象的主语，seems是表像的系动词，所以that all the waiters in the restaurant know about him可以看做表语从句。\n\n24.I am being his boyfriend.\n\nhis boyfriend, 名词短语。这里需要注意的是am是助动词，being是系动词。\n\n25.The truth is that I have never been in her heart.\n\nthat I have never been in her heart; in her heart. 首先这是一个表语从句，这很容易看出来；从句里have是助动词，been是系动词，所以in her heart是介词短语做的表语。\n\n26.The code is 89757\n\n89757，数词。\n\nG34表语的构成一、填空表语可以由名词、形容词、副词、和介词短语构成（充当）。\n二、按要求构造主系表结构5.The answer is _.（adj）\n\neg: right; wrong; correct; interesting; plausible; undoubted 只要是形容词且说得通都可以哈。\n\n6.The answer is _.（adv）\n\neg: here; there 这个范围比较有限，注意以ly结尾的副词不能做表语。\n\n7.The answer is _.（prep）\n\neg: in my pocket; on the next page 等。\n\n8.The answer is ___.（that引导句子）\n\neg：that you will never get what you want. 用that引导表语从句，只需要后面的句子成分和意思完整就可以了，that在名词性从句中不做成分。很多人无法理解，因为我说了从属连词要引导从句，且在从句中做成分。然后很多人就说that没做成分呀。其实不做成分也是一种成分，类似于数学中的0的概念。当然这个句子也可以写复杂一点，只要你能驾驭，比如说：The answer is that you will never get what you want without being good enough to deserve it.\n\n9.The answer is _.（名词短语）\n\neg:a myth; a surprise; a comfort.\n\n10.The answer is _.（宾格）\n\neg: him; her; me; 比如说，我们猜谁是凶手，答案是他，就是him. 人称代词作表语要用宾格。\n\n11.The answer is ___.（名物代）\n\neg: mine；theirs; 比如有人问，这狗是谁的，答案是我的，他们的。注意，形物代是不可以单独用的，必须后面加一个名词，而名物代相当于形物代+名词的结果。This dog is mine 就相当于This dog is my dog.\n\n12.The answer is _.（指示代词）\n\neg: this; that\n\n13.The answer is _.（不定代词）\n\neg: no; none; not much; everything\n\n14.The answer is _.（what引导句子）\n\neg: what really matters; what we’ve been looking for; what troubles me.\n\n15.The answer is _.（不定式）\n\neg: **to study hard; to wear a mask everywhere.**比如说怎样阻止新冠病毒，The answer is to wear a mask everywhere. 当然你可以说复杂一样，比如：to wear a mask wherever you go or whomever you are meeting with.\n\n16.The answer is _.（动名词）\n\neg: washing your hands twice a day; loving her like a child; treating him like a friend; living each day as if it’s the last one of your life.\n\n17.The answer is ___.（数词）\n\neg: five; 80%; 911\n\nG35 There be句型一、填空题在我的体系里，there be翻译成:有\nthere的本质是：形式表语\nthere be的实质是把方位介词提前，诱发了句子的完全倒装，再用there来替代这个方位介词（表语）\nthere be里面的be动词可以有不同的时态与形式，因此可以翻译成不同的意思：\nthere was&#x2F;were 以前&#x2F;曾今有\nthere has&#x2F;have been 已经有\nthere used to be 以前&#x2F;曾今有\nthere will be 将有\nthere must be.肯定有\nthere seems&#x2F;seem to be 似乎有\n二、把下列there be句型换成原来的样子12.There is a bird in the tree.\n\nA bird is in the tree.\n\n13.There you will be.\n\nYou will be there. 完全倒装的时候，如果主语是人称代词，则不倒。\n\n14.There is going to be a meeting tonight.\n\nA meeting is going to be there（in the meeting room）tonight. 很多时候There be句型只是单纯强调有，而不强调在哪里了，这已经不是重点了，比如有一场会议，一般是在会议室，但是通知开会的时候，你只会说什么时候有个会，你不会说什么时候有个会在会议室，因为每次都在会议室，那已经不重要了，除非换了个地方开会，那肯定得说出来，总之就是there be句型不强调地方的时候，可以不用说出来。\n\n15.There has been a big tree on the top of the hill.\n\n因为there做的是形式表语，替代的是真正的表语&#x2F;方位介词，\n所以说我们还原成：\nOn the top of the hill has been a big tree.\n而这个句子是完全倒装的结果，我们再把方位介词还原，变成：\nA big tree has been on the top of the hill. \n其他题以此类推。\n\n16.There used to be a church across from the bank.\n\nA church used to be across from the bank.\n\n17.There doesn’t seem to be much hope.\n\nMuch hope doesn’t seem to be there (in our lives&#x2F;in our company&#x2F;in this situation).\n\n三、把下列句子改成there be句型18.A beautiful girl named Liziqi lived at the foot of the mountain.\n\n首先把这个句子的方位介词提前诱发完全倒装：\nAt the foot of the mountain lived a beautiful girl named Liziqi. \n然后用there来代替这个方位介词，并把方位介词还原：\nThere lived a beautiful girl named Liziqi at the foot of the montain. \n其他以此类推。\n\n19.A small village lies between the mountains.\n\nThere lies a small village between the mountains.\n\n20.A rumor that Covid-19 comes from 5G technology seems to be across Britain.\n\nThere seems to be a rumor that Covid-19 comes from 5G technology across Britain.\n\n21.Some money happened to be in my pocket. That’s what we call serendipity.\n\nThere happened to be some money in my pocket. That’s what we call serendipity.\n\nG36 同位语一、填空同位语在我的体系中，被称之为金龙鱼模型\n同位语肯定是名词（性）的\n同位语从句三要素主语；谓语；宾语 （这些是后面的知识）\n二、按要求添加同位语\nI, Luozhixiang, am your man.（名词短语）\n\nI hate you, Morty.（名词短语）\n\nYou two follow me.（数词）\n\nWe both&#x2F;all got it wrong.（不定代词）\n\nIt’s my dream to become a billionaire that wakes me up every day.（不定式）\n\nThe plan, travelling to her town at Christmas eve and asking her out without informing her in advance, was a disaster.（动名词）\n\nWe, you and I, will do it together.（人称代词）\n\nWhat you said hurt us both&#x2F;all&#x2F;each.（不定代词）\n\nSome researchers believe that there is no doubt that a cure for AIDS will be found.（句子）\n\n\n三、为下列句子填上恰当的同位语We,15.all&#x2F;both know the fact 16.that you are a pig&#x2F;that I am not what you need. \nNobody believed his reason for being absent from the class 17.that he 18.himself had to meet his uncle 19.Mr. James at the airport, 20.one far away from town.\nG37-38 同位语、宾语与后置定语一、填空同位语的词性一定是：名词\n宾补的词性有：名词、形容词、副词、介词短语、不定式、现在分词和过去分词.\n后置定语的词性有副词、形容词短语、介词短语、不定式短语、现在分词短语和过去分词短语.\n同位语翻译可变序，可不变序；宾补翻译要变序；后置定语翻译不变序。\n同位语不会把它修饰的词范围变小；宾补不会把宾语的范围变小；后置定语会把它修饰的词范围变小。\n二、按要求填空12.I hate the boy ______.（同位语）\n\nMorty\n\n13.I hate the boy ______.(后置定语）\n\nwho keeps looking at me&#x2F;keeping glancing in my direction&#x2F;in red…\n\n14.I think the boy ______.(宾补）\n\nmy style&#x2F;my type&#x2F;my taste&#x2F;my destiny&#x2F;my destination&#x2F;my doom…\n\n15.I hate the boy ______ (同位语）______.（后置定语）\n\nMorty; who is keeping calling me recently.\n\n16.I find you （同位语）.(宾补）\n\nMorty; my lighthouse&#x2F;my source of happiness.\n\n17.I find the boy （后置定语）.（宾补）\n\nwearing a hat; a former neighbor of mine.\n\n18.I find the boy ______ (同位语），（后置定语）.（宾补）\n\nMorty; living in Chengdu&#x2F; getting up at 5:30 every morning, a bad bad boy.\n\n19.How can you ______(同位语）constantly keep me （同位语）.(宾补：介词短语）？\n\nmy woman; your man; in the dark\n\n","categories":["语言"],"tags":["笔记","教程","分享","语言学习"]}]